<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java多线程三：线程池</title>
    <url>/2020/04/02/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<pre><code>终于到了这一步了吗，海王的第一步。
</code></pre>
<a id="more"></a>
<h1>线程池</h1>
<h4 id="为什么要有线程池？"><a class="header-anchor" href="#为什么要有线程池？">¶</a>为什么要有线程池？</h4>
<p>创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。<br>
通过线程池复用一组线程，没有任务时，线程处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p>
<h4 id="线程池的创建"><a class="header-anchor" href="#线程池的创建">¶</a>线程池的创建</h4>
<p>ExecutorService只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>CachedThreadPool：线程数根据任务动态调整的线程池；</p>
</li>
<li>
<p>SingleThreadExecutor：仅单线程执行的线程池。</p>
</li>
<li>
<p>ThreadPoolExecutor：动态设置线程池大小范围。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> min = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">10</span>;</span><br><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(min, max, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>
<h6 id="线程池任务提交和结束"><a class="header-anchor" href="#线程池任务提交和结束">¶</a>线程池任务提交和结束</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">es.submit(<span class="keyword">new</span> Task(<span class="string">""</span> + i));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭线程池:</span></span><br><span class="line">es.shutdown();</span><br><span class="line"><span class="comment">// awaitTermination()则会等待指定的时间让线程池关闭。</span></span><br><span class="line">es.awaitTermination();</span><br></pre></td></tr></table></figure>
<h4 id="ScheduledThreadPool-定期反复执行线程池"><a class="header-anchor" href="#ScheduledThreadPool-定期反复执行线程池">¶</a>ScheduledThreadPool: 定期反复执行线程池</h4>
<h5 id="线程池创建"><a class="header-anchor" href="#线程池创建">¶</a>线程池创建</h5>
<p>创建一个ScheduledThreadPool仍然是通过Executors类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h5 id="线程任务分配"><a class="header-anchor" href="#线程任务分配">¶</a>线程任务分配</h5>
<p>使用ScheduledThreadPool时，我们要根据需要选择<br>
执行一次;<br>
FixedRate执行;<br>
还是FixedDelay执行。</p>
<ol>
<li>一次性任务，在指定延迟后只执行一次：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">"one-time"</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>以固定的每3秒执行，无论是否完成</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">"fixed-rate"</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>以固定的3秒为间隔执行，完成后才记3秒的间隔</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">"fixed-delay"</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h5 id="与java-util-Timer类的区别"><a class="header-anchor" href="#与java-util-Timer类的区别">¶</a>与java.util.Timer类的区别</h5>
<ol>
<li>一个Timer会对应一个Thread，所以，一个Timer只能定期执行一个任务</li>
<li>一个ScheduledThreadPool就可以调度多个定时任务<br>
所以，可以用ScheduledThreadPool取代旧的Timer。</li>
</ol>
<h1>线程池任务</h1>
<h3 id="Runnable接口"><a class="header-anchor" href="#Runnable接口">¶</a>Runnable接口</h3>
<p>要实现Runnable接口，覆写run()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callable-泛型接口"><a class="header-anchor" href="#Callable-泛型接口">¶</a>Callable 泛型接口</h3>
<p>有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Future类型</h1>
<p>未来能获取结果的对象，如果异步任务没有完成就阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>
<p>方法有：</p>
<ul>
<li>get()</li>
<li>get(long timeout, TimeUnit unit): 获取结果，但只等指定的时间</li>
<li>cancel(boolean mayInterruptIfRunning): 取消当前任务</li>
<li>isDone(): 判断任务是否已完成</li>
</ul>
<p>Java 8后：</p>
<h1>CompletableFuture</h1>
<p>Future缺点：线程阻塞或者轮询看isDone()是否为true，导致主线程被迫等待。</p>
<p>异步任务完成时或者发生异常时自动调用回调对象的回调方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">       <span class="comment">// 如果执行成功:</span></span><br><span class="line">       cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">"price: "</span> + result);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">// 如果执行异常:</span></span><br><span class="line">       cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>创建一个CompletableFuture通过CompletableFuture.supplyAsync（）实现，需要实现Supplier接口。<br>
完成时，回调调用Consumer对象。<br>
异常时，回调调用Function对象。<br>
所以主线程设置好回调就不再关心异步任务的执行。</p>
<h4 id="串行执行和并行"><a class="header-anchor" href="#串行执行和并行">¶</a>串行执行和并行</h4>
<p>串行：对象依次处理<br>
CompletableFuture<String> cfQuery = CompletableFuture.supplyAsync 第一步<br>
CompletableFuture<Double> cfFetch == cfQuery.thenApplyAsync 下一步<br>
cfFetch.thenAccept 获取结果</Double></String></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个任务:</span></span><br><span class="line">    CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryCode(<span class="string">"中国石油"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// cfQuery成功后继续执行下一个任务:</span></span><br><span class="line">    CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> fetchPrice(code);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// cfFetch成功后打印结果:</span></span><br><span class="line">    cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"price: "</span> + result);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>并行：anyOf()可以实现“任意个CompletableFuture只要一个成功”，allOf()可以实现“所有CompletableFuture都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">"https://finance.sina.com.cn/price/"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">"https://money.163.com/price/"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br></pre></td></tr></table></figure>
<p>CompletableFuture的命名规则：</p>
<ul>
<li>xxx()：表示该方法将继续在已有的线程中执行；</li>
<li>xxxAsync()：表示将异步在线程池中执行。</li>
</ul>
<p>Java7 引入的线程池：</p>
<h1>ForkJoin线程池 划小并行</h1>
<p>Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">long</span> expectedSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Expected sum: "</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> SumTask(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Long result = ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Fork/join sum: "</span> + result + <span class="string">" in "</span> + (endTime - startTime) + <span class="string">" ms."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">long</span>[] array;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="keyword">long</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="keyword">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">"split %d~%d ==&gt; %d~%d, %d~%d"</span>, start, end, start, middle, middle, end));</span><br><span class="line">        <span class="comment">// “分裂”子任务:</span></span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, start, middle);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, middle, end);</span><br><span class="line">        <span class="comment">// invokeAll会并行运行两个子任务:</span></span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="comment">// 获得子任务的结果:</span></span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        Long result = subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + subresult1 + <span class="string">" + "</span> + subresult2 + <span class="string">" ==&gt; "</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码SumTask继承自RecursiveTask，在compute()方法中，关键是如何“分裂”出子任务并且提交子任务。</p>
<p>Java标准库提供的java.util.Arrays.parallelSort(array)可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>
<h1>ThreadLocal</h1>
<p>上下文：在一个线程中，横跨若干方法调用，需要传递的对象。它是一种状态，可以是用户身份、任务信息等。</p>
<p>ThreadLocal表示线程的“局部变量”，它确保每个线程的ThreadLocal变量都是各自独立的；<br>
ThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；<br>
使用ThreadLocal要用try … finally结构，并在finally中清除。</p>
<h4 id="初始化："><a class="header-anchor" href="#初始化：">¶</a>初始化：</h4>
<p>使用静态对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="典型使用方式："><a class="header-anchor" href="#典型使用方式：">¶</a>典型使用方式：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，特别注意ThreadLocal一定要在finally中清除。因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p>
<h4 id="对ThreadLocal的封装"><a class="header-anchor" href="#对ThreadLocal的封装">¶</a>对ThreadLocal的封装</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserContext</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以把ThreadLocal看成一个全局Map&lt;Thread, Object&gt;：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key：<br>
因此，ThreadLocal相当于给每个线程都开辟了一个独立的存储空间，各个线程的ThreadLocal关联的实例互不干扰。</p>
<h4 id="自动清除线程"><a class="header-anchor" href="#自动清除线程">¶</a>自动清除线程</h4>
<p>可以通过AutoCloseable接口配合try (resource) {…}结构，让编译器自动为我们关闭。<br>
使用的时候，我们借助try (resource) {…}结构，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> ctx = <span class="keyword">new</span> UserContext(<span class="string">"Bob"</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser():</span></span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的逆序对｜《剑指offer》</title>
    <url>/2020/04/01/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
</code></pre>
<a id="more"></a>
<h1>题解</h1>
<p>归并排序的过程中记数，需要注意的是随时都要检查total是否有大于1000000007，total的计算时机，merge的边界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[]copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">return</span> Invert(array, copy, <span class="number">0</span>, array.length - <span class="number">1</span>)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Invert</span><span class="params">(<span class="keyword">int</span>[]array, <span class="keyword">int</span>[]copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">                copy[start]=array[start];</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = (end  + start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> leftcount = Invert(array,copy, start, mid);</span><br><span class="line">            <span class="keyword">int</span> rightcount = Invert(array, copy, mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">int</span> leftrigth = leftcount+rightcount;</span><br><span class="line">            leftrigth = leftrigth&gt;<span class="number">1000000007</span>?leftrigth%<span class="number">1000000007</span>:leftrigth;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &lt;= array[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> leftrigth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> crosscount = merge(array, copy, start, mid, end);</span><br><span class="line">            <span class="keyword">return</span> leftrigth+crosscount;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[]array,<span class="keyword">int</span>[]copy, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rstart = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;=end;++i)&#123;</span><br><span class="line">                copy[i] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;=end;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(start&gt;mid)&#123;</span><br><span class="line">                    array[i] = copy[rstart++];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rstart&gt;end)&#123;</span><br><span class="line">                    array[i] = copy[start++];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(copy[start]&lt;= copy[rstart])&#123;</span><br><span class="line">                    array[i] = copy[start++];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    array[i] = copy[rstart++];</span><br><span class="line">                    total += (mid - start + <span class="number">1</span>);</span><br><span class="line">                    total=total&gt;<span class="number">1000000007</span>?total%<span class="number">1000000007</span>:total;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串中第一个只出现一次的字符｜《剑指offer》</title>
    <url>/2020/04/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.
这题大佬的解很妙，把存Integer改为存Boolean，太妙了！
</code></pre>
<a id="more"></a>
<h1>常规题解 hash存次数</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>||str.length()&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(i))&#123;</span><br><span class="line">                map.put(i,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(i,map.get(i)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(i)==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>妙解</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>||str.length()&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:chars)&#123;</span><br><span class="line">            map.put(i,!map.containsKey(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(i)) <span class="keyword">return</span> pos;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>ASCII码作映射</h1>
<p>ASCII码字符共256个，随意存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>||str.length()&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:chars)&#123;</span><br><span class="line">            map[(<span class="keyword">int</span>)i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[(<span class="keyword">int</span>)i]==<span class="number">1</span>) <span class="keyword">return</span> pos;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程二：代码级别的锁</title>
    <url>/2020/04/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8C/</url>
    <content><![CDATA[<pre><code>JDK1.5之后，欢迎来到java.util.concurrent包。可重入锁，悲观读锁，乐观读锁，线程安全数据结构。
</code></pre>
<a id="more"></a>
<ul>
<li>⚠️注意final</li>
</ul>
<h1>ReentrantLock 可重入锁</h1>
<p>保证只有一个线程可以执行临界区代码：<br>
更安全版本的syncronized，增加了尝试获取锁的功能，更不容易死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与syncronized的区别：</p>
<ol>
<li>synchronized是Java语言层面提供的语法，所以我们不需要考虑异常，而ReentrantLock是Java代码实现的锁，我们就必须先获取锁，然后在finally中正确释放锁。</li>
<li>ReentrantLock可以尝试获取锁：<br>
这里表示单位为秒，最多等待一秒，否则返回false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Condition condition.await(), condition.signalAll();</h1>
<p>新版wait and notify<br>
创建一个Condtion对象，进行信号量管理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理和行为都是一致的。<br>
而且 condition.await() 也可以指定等待的时间，规定时间内没有被condition.signal()或condition.signalAll()唤醒，会自己唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condtion.await(<span class="number">1</span>,TimeUnit.SECOND))&#123; </span><br><span class="line">    被其他线程唤醒  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    指定时间内没有被其他线程唤醒。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>ReadWriteLock读写锁 （悲观读锁，可重入锁）</h1>
<p>允许多个线程同时读，但只能一个线程写，其他线程必须等待。<br>
创建一个ReadWriteLock实例，然后用这个实例分别获取读/写锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        wlock.lock;         <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get()&#123;</span><br><span class="line">        rlock.lock();       <span class="comment">// 加读锁  </span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReadWriteLock，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>
<h1>StampedLock （乐观读锁，不可重入锁）</h1>
<p>读的过程中也允许获取写锁后写入！</p>
<ol>
<li>写入的加锁是完全一致的。</li>
<li>读取的时候会先通过stampedLock.tryOptimisticRead()获取乐观读锁，会返回一个版本号。</li>
<li>通过乐观读锁读取数据，如果发生写入，版本号不一致，会再使用悲观读锁获取数据。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="代价"><a class="header-anchor" href="#代价">¶</a>代价</h5>
<ol>
<li>代码复杂</li>
<li>不可重入锁</li>
</ol>
<p>StampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p>
<h1>Concurrent集合包</h1>
<p>线程安全版，操作是一样的。</p>
<table>
<thead>
<tr>
<th>interface</th>
<th>non-thread-safe</th>
<th>thread-safe</th>
</tr>
</thead>
<tbody>
<tr>
<td>List</td>
<td>ArrayList</td>
<td>CopyOnWriteArrayList</td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>ConcurrentHashMap</td>
</tr>
<tr>
<td>Set</td>
<td>HashSet/TreeSet</td>
<td>CopyOnWriteArraySet</td>
</tr>
<tr>
<td>Queue</td>
<td>ArrayDeque/LinkedList</td>
<td>ArrayBlocingQueue/LinkedBlockingQueue</td>
</tr>
<tr>
<td>Deque</td>
<td>ArrayDeque/LinkedList</td>
<td>LinkedBlockingQueue</td>
</tr>
</tbody>
</table>
<h4 id="线程安全集合转换器"><a class="header-anchor" href="#线程安全集合转换器">¶</a>线程安全集合转换器</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map unsafeMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>
<p>它实际上是用一个包装类包装了非线程安全的Map，然后对所有读写方法都用synchronized加锁，这样获得的线程安全集合的性能比java.util.concurrent集合要低很多，所以不推荐使用。</p>
<h1>Atomic 原子操作封装类</h1>
<ol>
<li>无锁的线程安全</li>
<li>适用于计数器，累加器<br>
如：线程安全的全局唯一ID生成器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    AtomicLong <span class="keyword">var</span> = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以AtomicInteger为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：int addAndGet(int delta)</li>
<li>自增并返回值：int incrementAndGet()</li>
<li>获取当前值：int get()</li>
<li>用CAS方式设置：int compareAndSet(int expect, int update)</li>
</ul>
<p>CAS是指，在这个操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。如果AtomicInteger的当前值不是prev，就什么也不干，返回false。通过CAS操作并配合do … while循环，即使其他线程修改了AtomicInteger的值，最终的结果也是正确的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程一：语言级别的锁</title>
    <url>/2020/03/31/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<pre><code>一个线程都搞不好，搞什么多线程。
</code></pre>
<a id="more"></a>
<h1>1 创建线程</h1>
<p>直接创建很简单 Thread a = new Thread();就是创建一个线程对象<br>
a.start()，启动多线程，但是要在子线程里调用方法，要覆写run()方法，同时继承Thread类或者继承runnable接口,或者用函数式编程lambda。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="线程休眠"><a class="header-anchor" href="#线程休眠">¶</a>线程休眠</h6>
<p>静态方法，单位是毫秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h6 id="设置线程优先级"><a class="header-anchor" href="#设置线程优先级">¶</a>设置线程优先级</h6>
<p>1-10，越大优先级越高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t.setPriority(<span class="number">10</span>);</span><br><span class="line">Thread.currentThread().setPriority(<span class="number">10</span>);</span><br><span class="line">设置当前线程</span><br></pre></td></tr></table></figure>
<h1>线程的状态</h1>
<p>New：新创建的线程，尚未执行；<br>
👇<br>
Runnable：运行中的线程，正在执行run()方法的Java代码；<br>
Blocked：运行中的线程，因为某些操作被阻塞而挂起；<br>
Waiting：运行中的线程，因为某些操作在等待中；<br>
Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；<br>
👇<br>
Terminated：线程已终止，因为run()方法执行完毕。</p>
<h4 id="线程终止条件"><a class="header-anchor" href="#线程终止条件">¶</a>线程终止条件</h4>
<p>线程正常终止：run()方法执行到return语句返回；<br>
线程意外终止：run()方法因为未捕获的异常导致线程终止；<br>
对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。</p>
<h4 id="t-join-当前线程等待其他线程结束才执行"><a class="header-anchor" href="#t-join-当前线程等待其他线程结束才执行">¶</a>t.join() 当前线程等待其他线程结束才执行</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main线程先打印start，t线程再打印hello，main线程最后再打印end。</p>
<ul>
<li>join(long)的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</li>
</ul>
<h4 id="t-interrupt-发出中断请求"><a class="header-anchor" href="#t-interrupt-发出中断请求">¶</a>t.interrupt() 发出中断请求</h4>
<p>只是所在线程发出中断请求，要响应，还需要在该线程检测 isInterrupted()。</p>
<p>t.join() + t.interrupt() 抛出 InterruptedException。<br>
如果线程处于等待状态，例如，t.join()会让main线程进入等待状态，此时，如果对main线程调用interrupt()，join()方法会立刻抛出InterruptedException，因此，目标线程只要捕获到join()方法抛出的InterruptedException，就说明有其他线程对其调用了interrupt()方法，通常情况下该线程应该立刻结束运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread hello = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">" hello!"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="另一个中断请求的方法"><a class="header-anchor" href="#另一个中断请求的方法">¶</a>另一个中断请求的方法</h4>
<p>设置标志位，但是要记得使用 volatile 关键字，避免标识位无法及时更新，即可见性问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        HelloThread t = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">" hello!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要对线程间共享的变量用关键字volatile声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p>
<p>因此，volatile关键字的目的是告诉虚拟机：</p>
<ul>
<li>每次访问变量时，总是获取主内存的最新值；</li>
<li>每次修改变量后，立刻回写到主内存。</li>
</ul>
<p>volatile关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>
<h1>守护线程</h1>
<p>用来关闭剩下的定时触发任务之类的线程，确保JVM能正常关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
<h1>线程同步</h1>
<p>多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：<br>
┌───────┐     ┌───────┐<br>
│Thread1│     │Thread2│<br>
└───┬───┘     └───┬───┘<br>
│             │<br>
│-- lock –   │<br>
│ILOAD (100)  │<br>
│IADD         │<br>
│ISTORE (101) │<br>
│-- unlock – │<br>
│             │-- lock –<br>
│             │ILOAD (101)<br>
│             │IADD<br>
│             │ISTORE (102)<br>
│             │-- unlock –<br>
▼             ▼<br>
在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</p>
<p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用synchronized关键字对一个对象进行加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized保证了代码块在任意时刻最多只有一个线程能执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何使用synchronized：</p>
<ol>
<li>找出修改共享变量的线程代码块；</li>
<li>选择一个共享实例作为锁；</li>
<li>使用synchronized(lockObject) { … }。</li>
</ol>
<p>在使用synchronized的时候，不必担心抛出异常。因为无论是否有异常，都会在synchronized结束处正确释放.</p>
<h3 id="不需要-synchronized-的操作"><a class="header-anchor" href="#不需要-synchronized-的操作">¶</a>不需要 synchronized 的操作</h3>
<p>JVM规范定义了几种原子操作：</p>
<ol>
<li>基本类型（long和double除外）赋值，例如：int n = m；</li>
<li>引用类型赋值，例如：List<String> list = anotherList。<br>
long和double是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把long和double的赋值作为原子操作实现的。</String></li>
</ol>
<p>但是，如果是多行赋值语句，就必须保证是同步操作，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.last = last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] pair;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ps = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; first, last &#125;;</span><br><span class="line">        <span class="keyword">this</span>.pair = ps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">就不再需要同步，因为<span class="keyword">this</span>.pair = ps是引用赋值的原子操作。而语句：</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ps = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; first, last &#125;;</span><br></pre></td></tr></table></figure>
<p>这里的ps是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p>
<h1>Java的线程锁是可重入锁</h1>
<p>同一个线程可以重复获取同一个锁，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出synchronized块，记录-1，减到0的时候，才会真正释放锁。<br>
比如方法里还调用了方法，当前使用的锁对新调用的方法依然可用。</p>
<h1>死锁</h1>
<p>两个线程都想获取对方的资源，导致无限的等待下去。即线程获取锁的顺序要一致。即严格按照先获取lockA，再获取lockB的顺序。</p>
<h1>wait和notify</h1>
<p>多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。<br>
t.wait(): 使线程进入等待  只有在已获得的锁对象的内部才能调用<br>
t.notify(), t.notifyAll(): 唤醒其他线程，只能在已获得锁对象内部调用<br>
唤醒之后的线程也要重新获得锁对象才能继续执行</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数｜《剑指offer》</title>
    <url>/2020/03/31/%E4%B8%91%E6%95%B0%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
</code></pre>
<a id="more"></a>
<h1>题解 动态规划</h1>
<pre><code>一个十分巧妙的动态规划问题
1. 我们将前面求得的丑数记录下来，后面的丑数就是前面的丑数*2，*3，*5
2. 但是问题来了，我怎么确定已知前面k-1个丑数，我怎么确定第k个丑数呢
3. 采取用三个指针的方法，p2,p3,p5
4. index2指向的数字下一次永远*2，p3指向的数字下一次永远*3，p5指向的数字永远*5
5. 我们从2*p2 3*p3 5*p5选取最小的一个数字，作为第k个丑数
6. 如果第K个丑数==2*p2，也就是说前面0-p2个丑数*2不可能产生比第K个丑数更大的丑数了，所以p2++
7. p3,p5同理
8. 返回第n个丑数
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)&#123;</span><br><span class="line">            dp[i]=Math.min(dp[p2]*<span class="number">2</span>,Math.min(dp[p3]*<span class="number">3</span>,dp[p5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==dp[p2]*<span class="number">2</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==dp[p3]*<span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==dp[p5]*<span class="number">5</span>) p5++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>把数组排成最小的数｜《剑指offer》</title>
    <url>/2020/03/31/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
</code></pre>
<a id="more"></a>
<h1>题解</h1>
<p>排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.lang.StringBuilder;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: numbers)&#123;</span><br><span class="line">            aList.add(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        aList.sort((x,y)-&gt; (x+y).compareTo(y+x));</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s:aList)&#123;</span><br><span class="line">            str.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>整数中1出现的次数｜《剑指offer》</title>
    <url>/2020/03/30/%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
</code></pre>
<a id="more"></a>
<h1>题解1 转成字符串</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            result += numberof1(n);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberof1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: Integer.toString(a).toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'1'</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>题解2 总结每位出现1的个数</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>)&#123;</span><br><span class="line">             <span class="keyword">long</span> diviver = i * <span class="number">10</span>;           </span><br><span class="line">             count += (n / diviver) * i + Math.min(Math.max(n % diviver - i + <span class="number">1</span>, <span class="number">0</span>), i);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1>题解3 总结每位出现1的个数</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> a = n / m;</span><br><span class="line">            <span class="keyword">long</span> b = n % m;</span><br><span class="line">            res += (a + <span class="number">8</span>) / <span class="number">10</span> * m + (a % <span class="number">10</span> == <span class="number">1</span> ? b + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>今朝酒</title>
    <url>/2020/03/30/top/</url>
    <content><![CDATA[<p>大概过了一下多线程，我回来容器君。</p>
]]></content>
  </entry>
  <entry>
    <title>连续子数组的最大和｜《剑指offer》</title>
    <url>/2020/03/29/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：给一个数组，返回它的最大连续子序列的和(子向量的长度至少是1)
</code></pre>
<a id="more"></a>
<pre><code>动态规划, d[0] = array[0] 
         d[i] = max(d[i-1]+array[i],array[i]) i&gt;0;

简化一点,省个数组：
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = array[<span class="number">0</span>]; <span class="comment">//记录当前所有子数组的和的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max=array[<span class="number">0</span>];   <span class="comment">//包含array[i]的连续数组最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            max=Math.max(max+array[i], array[i]);</span><br><span class="line">            res=Math.max(max, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的排列｜《剑指offer》</title>
    <url>/2020/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
</code></pre>
<a id="more"></a>
<h1>题解一 递归</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于无重复值的情况</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 固定第一个字符，递归取得首位后面的各种字符串组合；</span></span><br><span class="line"><span class="comment">     * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假如有重复值呢？</span></span><br><span class="line"><span class="comment">     * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。</span></span><br><span class="line"><span class="comment">     * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。</span></span><br><span class="line"><span class="comment">     * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。</span></span><br><span class="line"><span class="comment">     * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数，</span></span><br><span class="line"><span class="comment">     * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str!=<span class="keyword">null</span>&amp;&amp;str.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            PermutationHelper(alist,str.toCharArray(),i);</span><br><span class="line">            Collections.sort(alist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> alist;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PermutationHelper</span><span class="params">(ArrayList&lt;String&gt; alist,<span class="keyword">char</span>[] str,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == str.length-<span class="number">1</span>)&#123;</span><br><span class="line">            alist.add(String.valueOf(str));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();    <span class="comment">//判断是否是重复字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;str.length;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==i||!set.contains(str[j]))&#123;</span><br><span class="line">                set.add(str[j]);</span><br><span class="line">                swap(str,i,j);</span><br><span class="line">                PermutationHelper(alist, str, i+<span class="number">1</span>);</span><br><span class="line">                swap(str,j,i);                        <span class="comment">//交换回原来的字符串以满足上层循环的条件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[]str, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str[a];</span><br><span class="line">        str[a] = str[b];</span><br><span class="line">        str[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中出现次数超过一半的数｜《剑指offer》</title>
    <url>/2020/03/28/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
</code></pre>
<a id="more"></a>
<h1>解法一 hashmap</h1>
<p>时间复杂度：O(n)<br>
空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(i))&#123;</span><br><span class="line">                map.put(i,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(i,map.get(i)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: array) &#123;</span><br><span class="line">        	<span class="keyword">int</span> max = map.get(i);</span><br><span class="line">            <span class="keyword">if</span>(max&gt;(array.length&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>解法二 partition</h1>
<p>时间复杂度：O(nlogn)<br>
空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">int</span> middle = length&gt;&gt;<span class="number">1</span>;<span class="keyword">int</span> left = <span class="number">0</span>;<span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = partition(array, left, right);</span><br><span class="line">        <span class="keyword">while</span>(i!=middle)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;middle)&#123;</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">                i = partition(array,left, right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">                i = partition(array, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = array[i];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a==result)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;(length&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left+<span class="number">1</span>;<span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">int</span> flag = array[left];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(array[i]&lt;=flag) </span><br><span class="line">                <span class="keyword">if</span>(i&lt;right)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">while</span>(array[j]&gt;flag) --j;</span><br><span class="line">            swap(array, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, left, i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[a];</span><br><span class="line">        array[a] = array[b];</span><br><span class="line">        array[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>题解三：摩尔投票法</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> votes = <span class="number">1</span>;<span class="keyword">int</span> num = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes==<span class="number">0</span>)&#123;</span><br><span class="line">               num = array[i];</span><br><span class="line">               votes = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            votes += (array[i]==num)? <span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: array)&#123;</span><br><span class="line">            count += (i==num) ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; (array.length &gt;&gt;<span class="number">1</span>)) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>最小的k个数｜《剑指offer》</title>
    <url>/2020/03/27/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
</code></pre>
<a id="more"></a>
<h1>题解1 快排partition</h1>
<p>可以找到第m大的数，然后与k比较，从而递归划分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr.length &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原地不断划分数组</span></span><br><span class="line">    partitionArray(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组的前 k 个数此时就是最小的 k 个数，将其存入结果</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做一次 partition 操作</span></span><br><span class="line">    <span class="keyword">int</span> m = partition(arr, lo, hi);</span><br><span class="line">    <span class="comment">// 此时数组前 m 个数，就是最小的 m 个数</span></span><br><span class="line">    <span class="keyword">if</span> (k == m) &#123;</span><br><span class="line">        <span class="comment">// 正好找到最小的 k(m) 个数</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; m) &#123;</span><br><span class="line">        <span class="comment">// 最小的 k 个数一定在前 m 个数中，递归划分</span></span><br><span class="line">        partitionArray(arr, lo, m-<span class="number">1</span>, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在右侧数组中寻找最小的 k-m 个数</span></span><br><span class="line">        partitionArray(arr, m+<span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partition 函数和快速排序中相同，具体可参考快速排序相关的资料</span></span><br><span class="line"><span class="comment">// 代码参考 Sedgewick 的《算法4》</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v = a[lo];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == hi) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a[--j] &gt; v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, lo, j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法的复杂度分析：</p>
<ul>
<li>空间复杂度<br>
O(1)，不需要额外空间。</li>
<li>时间复杂度的分析方法和快速排序类似。由于快速选择只需要递归一边的数组，时间复杂度小于快速排序，期望时间复杂度为<br>
O(n)，最坏情况下的时间复杂度为 O(n2)。</li>
</ul>
<h1>题解2 最大堆</h1>
<p>每次拿数组里的数与堆顶比较，小于堆顶则插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">    <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆</span></span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (i1, i2) -&gt; Integer.compare(i2, i1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : arr) &#123;</span><br><span class="line">        <span class="comment">// 当前数字小于堆顶元素才会入堆</span></span><br><span class="line">        <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; k || e &lt; heap.peek()) &#123;</span><br><span class="line">            heap.offer(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">            heap.poll(); <span class="comment">// 删除堆顶最大元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将堆中的元素存入数组</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123;</span><br><span class="line">        res[j++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度：O(k)<br>
时间复杂度：单次操作，O(logk)。故总复杂度：O(nlogk)</p>
<p>两种方法的优劣性比较<br>
在面试中，另一个常常问的问题就是这两种方法有何优劣。看起来分治法的快速选择算法的时间、空间复杂度都优于使用堆的方法，但是要注意到快速选择算法的几点局限性：<br>
第一，算法需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。<br>
第二，算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树与双向链表｜《剑指offer》</title>
    <url>/2020/03/27/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<pre><code>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
</code></pre>
<a id="more"></a>
<h1>题解 1 非递归</h1>
<p>中序遍历二叉搜索树，才能按照排序，访问结点<br>
使用一个结点记录前一个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = pRootOfTree;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isFirst = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.offerFirst(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>(isFirst)&#123;</span><br><span class="line">                pRootOfTree = node;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">                isFirst = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre.right = node; </span><br><span class="line">                node.left = pre; <span class="comment">//当前结点只能腾出左边</span></span><br><span class="line">                pre = node;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a class="header-anchor" href="#递归">¶</a>递归</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        travel(pRootOfTree);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode pRootOfTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        travel(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(pre== <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = pRootOfTree;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        travel(pRootOfTree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人的运动范围｜《剑指offer》</title>
    <url>/2020/03/25/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E8%BF%87%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？
</code></pre>
<a id="more"></a>
<h1>题解一 DFS</h1>
<p>从左往右，从上到下递归遍历。</p>
<h1>Code</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> threshold, rows, cols;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;<span class="keyword">this</span>.rows = rows;<span class="keyword">this</span>.cols = cols;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">return</span> DFS(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归计算次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rowSum,<span class="keyword">int</span> colSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=rows||j&lt;<span class="number">0</span>||j&gt;=cols||rowSum + colSum&gt;threshold||visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+DFS(i+<span class="number">1</span>,j,digitSum(i+<span class="number">1</span>),colSum)+DFS(i,j+<span class="number">1</span>,rowSum,digitSum(j+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算位数和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum += num%<span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题解二-BFS"><a class="header-anchor" href="#题解二-BFS">¶</a>题解二 BFS</h2>
<p>使用队列，记录参数，依层次扩展。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue= <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] x = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> i = x[<span class="number">0</span>], j = x[<span class="number">1</span>], si = x[<span class="number">2</span>], sj = x[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            res ++;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i + <span class="number">1</span>, j, digitSum(i+<span class="number">1</span>), sj &#125;);</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j + <span class="number">1</span>, si, digitSum(j+<span class="number">1</span>) &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算位数和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum += num%<span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径｜《剑指offer》</title>
    <url>/2020/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
</code></pre>
<a id="more"></a>
<h1>题解：</h1>
<p>创建两个ArrayList，一个用来存所有路径result，一个用来存结点cur。<br>
利用二叉树的前序遍历，因为前序遍历是从根节点开始的。<br>
每经过一个结点，就将结点放入cur，然后递归的调用左子树和右子树，同时目标值应该减去当前加入结点的值。<br>
终止条件是目标值和当前结点的值相等，且该结点为叶子结点。若True，说明当前路径符合条件，加入result中。<br>
最后需要排序，因为要求返回的list中，数组长度大的数组靠前。</p>
<h1>Code</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; cur=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        helper(root,target,cur,res);</span><br><span class="line">        Collections.sort(res, <span class="keyword">new</span> Comparator&lt;ArrayList&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ArrayList&lt;Integer&gt; o1, ArrayList&lt;Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.size()&lt;o2.size())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;Integer&gt; cur,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> value=root.val;</span><br><span class="line">        cur.add(value);</span><br><span class="line">        <span class="keyword">if</span> (target==value&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(cur));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            helper(root.left,target-value,cur,res);</span><br><span class="line">            helper(root.right,target-value,cur,res);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>sql好题总结</title>
    <url>/2020/03/25/sql%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<pre><code>合格的SQL BOY练成之路。
</code></pre>
<a id="more"></a>
<h3 id="1-找所有部门内salary最大的员工（存在多值）"><a class="header-anchor" href="#1-找所有部门内salary最大的员工（存在多值）">¶</a>1. 找所有部门内salary最大的员工（存在多值）</h3>
<p>注意使用group by子句时，select子句中只能有聚合键、聚合函数、常数。否则groupby默认取第一条数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> de.dept_no, de.emp_no, s.salary</span><br><span class="line"><span class="keyword">from</span> dept_emp de <span class="keyword">inner</span> <span class="keyword">join</span> salaries s</span><br><span class="line"><span class="keyword">on</span> de.emp_no = s.emp_no</span><br><span class="line"><span class="keyword">and</span> de.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">where</span> s.salary = (<span class="keyword">select</span> <span class="keyword">max</span>(s2.salary)</span><br><span class="line">                <span class="keyword">from</span> dept_emp de2 <span class="keyword">inner</span> <span class="keyword">join</span> salaries s2</span><br><span class="line">                <span class="keyword">on</span> de2.emp_no = s2.emp_no</span><br><span class="line">                <span class="keyword">and</span> de2.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">                <span class="keyword">and</span> s2.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">                <span class="keyword">where</span> de2.dept_no = de.dept_no</span><br><span class="line">                <span class="keyword">group</span> <span class="keyword">by</span> de2.dept_no)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> de.dept_no</span><br></pre></td></tr></table></figure>
<h3 id="2-查找当前薪水-to-date-‘9999-01-01’-排名第二多的员工-不准使用order-by"><a class="header-anchor" href="#2-查找当前薪水-to-date-‘9999-01-01’-排名第二多的员工-不准使用order-by">¶</a>2. 查找当前薪水(to_date=‘9999-01-01’)排名第二多的员工, 不准使用order by</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.emp_no, <span class="keyword">max</span>(s.salary) <span class="keyword">as</span> salary, e.last_name, e.first_name</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> e <span class="keyword">join</span> salaries <span class="keyword">as</span> s <span class="keyword">using</span>(emp_no)</span><br><span class="line"><span class="keyword">where</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> s.salary <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">max</span>(salary) </span><br><span class="line">                     <span class="keyword">from</span> salaries </span><br><span class="line">                     <span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-查找所有员工入职以来的薪水涨幅"><a class="header-anchor" href="#3-查找所有员工入职以来的薪水涨幅">¶</a>3. 查找所有员工入职以来的薪水涨幅</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sCurrent.emp_no, (sCurrent.salary-sStart.salary) <span class="keyword">AS</span> growth</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> s.emp_no, s.salary <span class="keyword">FROM</span> employees e, salaries s <span class="keyword">WHERE</span> e.emp_no = s.emp_no <span class="keyword">AND</span> s.to_date = <span class="string">'9999-01-01'</span>) <span class="keyword">AS</span> sCurrent,</span><br><span class="line">(<span class="keyword">SELECT</span> s.emp_no, s.salary <span class="keyword">FROM</span> employees e, salaries s <span class="keyword">WHERE</span> e.emp_no = s.emp_no <span class="keyword">AND</span> s.from_date = e.hire_date) <span class="keyword">AS</span> sStart</span><br><span class="line"><span class="keyword">WHERE</span> sCurrent.emp_no = sStart.emp_no</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> growth</span><br></pre></td></tr></table></figure>
<h3 id="4-对所有员工的当前-to-date-‘9999-01-01’-薪水按照salary进行按照1-N的排名"><a class="header-anchor" href="#4-对所有员工的当前-to-date-‘9999-01-01’-薪水按照salary进行按照1-N的排名">¶</a>4. 对所有员工的当前(to_date=‘9999-01-01’)薪水按照salary进行按照1-N的排名</h3>
<p>自我联结，计算大于主表的工资的数量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s2.emp_no, s2.salary, <span class="keyword">count</span>(<span class="keyword">distinct</span> s1.salary) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">as</span> s1, salaries <span class="keyword">as</span> s2</span><br><span class="line"><span class="keyword">where</span> s1.to_date=<span class="string">'9999-01-01'</span> <span class="keyword">and</span> s2.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> s2.salary &lt;= s1.salary</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s2.emp_no,s2.salary</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> s2.salary <span class="keyword">desc</span>, s2.emp_no <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量-5部"><a class="header-anchor" href="#5-查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量-5部">¶</a>5. 查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量&gt;=5部</h3>
<p>这里要注意，这里的大于等于5部是指分类的电影数量大于5部而不是包含robot的分类的电影数量大于5部。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c.name, <span class="keyword">count</span>(f.film_id)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">category</span> c, (<span class="keyword">select</span> <span class="keyword">count</span>(film_id), category_id </span><br><span class="line">                       <span class="keyword">from</span> film_category</span><br><span class="line">                      <span class="keyword">group</span> <span class="keyword">by</span> category_id</span><br><span class="line">                       <span class="keyword">having</span> <span class="keyword">count</span>(film_id)&gt;=<span class="number">5</span>) <span class="keyword">as</span> fc, film f, </span><br><span class="line">film_category cc</span><br><span class="line"><span class="keyword">where</span> f.description <span class="keyword">like</span> <span class="string">'%robot%'</span></span><br><span class="line"><span class="keyword">and</span> c.category_id = fc.category_id</span><br><span class="line"><span class="keyword">and</span> f.film_id = cc.film_id</span><br><span class="line"><span class="keyword">and</span> cc.category_id = fc.category_id;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>树的数据结构补充</title>
    <url>/2020/03/25/%E6%A0%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1>前缀树</h1>
<p>Trie树的基本性质：<br>
①根节点不包含字符，除根节点外的每一个子节点都包含一个字符。<br>
②从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>
③每个节点的所有子节点包含的字符互不相同。<br>
④从第一字符开始有连续重复的字符只占用一个节点，比如上面的to，和ten，中重复的单词t只占用了一个节点。</p>
<h3 id="前缀树的应用"><a class="header-anchor" href="#前缀树的应用">¶</a>前缀树的应用</h3>
<p>1、前缀匹配<br>
2、字符串检索<br>
3、词频统计<br>
4、字符串排序</p>
<p>可以利用前缀树的性质来解决现实中的问题。比如说查找一个字符串数组中是否含有前缀单词，什么是前缀单词：上面的 in，就是 inn 的前缀单词。如果有十几万条单词，并且每个单词的长度都是5-10以内，这样必定存在大量重复的字符，因此利用前缀树来求解不仅速度快而且空间复杂度也比较好。</p>
<p>每个结点维持两个变量的记录：path表示字符路过这个结点的次数（即表示存在以当前结点为前缀的字符有多少个）；end记录以当前结点为结束的字符有多少个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        trie.add(<span class="string">"a"</span>);</span><br><span class="line">        trie.add(<span class="string">"ab"</span>);</span><br><span class="line">        trie.add(<span class="string">"ac"</span>);</span><br><span class="line">        trie.add(<span class="string">"abc"</span>);</span><br><span class="line">        trie.add(<span class="string">"acb"</span>);</span><br><span class="line">        trie.add(<span class="string">"abcc"</span>);</span><br><span class="line">        trie.add(<span class="string">"aab"</span>);</span><br><span class="line">        trie.add(<span class="string">"abx"</span>);</span><br><span class="line">        trie.add(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(trie.get(<span class="string">"abc"</span>));</span><br><span class="line">        System.out.println(trie.getPre(<span class="string">"ab"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * path表示字符路过这个结点的次数（即表示存在以当前结点为前缀的字符有多少个）；</span></span><br><span class="line"><span class="comment"> * end记录以当前结点为结束的字符有多少个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] nexts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        path = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只能存英文小写字母，如果是ASCII码可以生成256大小的数组</span></span><br><span class="line">        <span class="comment">//如果想存更多种类的字符可以改为map结构</span></span><br><span class="line">        nexts = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典树的加入过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            index = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.nexts[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[index];</span><br><span class="line">            node.path++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典树查询目标单词出现的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            index = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            node = node.nexts[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典树查询以目标前缀的单词有多少个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPre</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            index = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.nexts[index]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            node = node.nexts[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>优先级队列</h1>
<p>最大优先队列，最大的优先出列，最大堆实现降序。<br>
最小堆实现升序</p>
<p>最小堆是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节的值。</p>
<p>入队和出队的时间复杂度都是O(logn)，下沉和上浮操作</p>
<h3 id="Java中"><a class="header-anchor" href="#Java中">¶</a>Java中</h3>
<p>PriorityQueue 是基于优先堆的一个无界队列，不允许插入不可比较的对象，否则会抛出 ClassCastException 异常(如果队列只有一个元素则不会报错，因为此时没有比较)；也不允许插入 null，否则会抛出NullPointerException。<br>
PriorityQueue使用时要实现比较器，定义排序方法。<br>
注：PriorityQueue 是非线程安全的，如果想要在多线程的环境下使用，可以使用 PriorityBlockingQueue。</p>
<h3 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> Object[<span class="number">11</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = size;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = t;</span><br><span class="line">        size++;</span><br><span class="line">        moveUp(k, t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从堆底一层层上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveUp</span><span class="params">(<span class="keyword">int</span> k, T t)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) t;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) e) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从堆顶一层层下沉</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        T result = (T) queue[<span class="number">0</span>];</span><br><span class="line">        T end = (T) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            moveDown(<span class="number">0</span>, end);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveDown</span><span class="params">(<span class="keyword">int</span> k, T end)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) end;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">            Object c = queue[left];</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) queue[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                c = queue[left = right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = left;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinHeap minHeap = <span class="keyword">new</span> MinHeap();</span><br><span class="line">        minHeap.offer(<span class="number">1</span>);</span><br><span class="line">        minHeap.offer(<span class="number">5</span>);</span><br><span class="line">        minHeap.offer(<span class="number">3</span>);</span><br><span class="line">        minHeap.offer(<span class="number">2</span>);</span><br><span class="line">        minHeap.offer(<span class="number">4</span>);</span><br><span class="line">        minHeap.offer(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> length = minHeap.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            System.out.println(minHeap.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的后序遍历序列｜《剑指offer》</title>
    <url>/2020/03/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<h1>题解</h1>
<p>二叉搜索树的后序遍历序列，最后一个结点为root，则往前找第一个小于root即为左子树的最右结点，即可将序列分为左子树和右子树。</p>
<h1>code</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Bst(sequence,<span class="number">0</span>,sequence.length -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">Bst</span><span class="params">(<span class="keyword">int</span>[] sequence,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = end-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((sequence[mid]&gt;sequence[end])&amp;&amp;(mid&gt;start)) mid--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;mid;i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;sequence[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Bst(sequence,start, mid)&amp;&amp; Bst(sequence,mid+<span class="number">1</span>, end-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的压入、弹出序列｜《剑指offer》</title>
    <url>/2020/03/23/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
</code></pre>
<a id="more"></a>
<p>创建一个辅助栈，模拟压入、弹出的行为：<br>
关键在于栈不能出现两个逆序，所以for循环执行到最后一次，while循环将pop完stack中的所有结点，否则弹出序列不成立。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; s = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//用于标识弹出序列的位置</span></span><br><span class="line">        <span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; pushA.length;i++)&#123;</span><br><span class="line">            s.addFirst(pushA[i]);</span><br><span class="line">            <span class="comment">//如果栈不为空，且栈顶元素等于弹出序列</span></span><br><span class="line">            <span class="keyword">while</span>(!s.isEmpty() &amp;&amp;s.getFirst() == popA[popIndex])&#123;</span><br><span class="line">                <span class="comment">//出栈</span></span><br><span class="line">                s.pollFirst();</span><br><span class="line">                <span class="comment">//弹出序列向后一位</span></span><br><span class="line">                popIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>python复习</title>
    <url>/2020/03/22/python%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<pre><code>再过一遍python语法，记点有趣的。
</code></pre>
<a id="more"></a>
<h1>基本类型和变量</h1>
<h3 id="1-计算"><a class="header-anchor" href="#1-计算">¶</a>1.计算</h3>
<p>除法：/（无论怎么除结果都是浮点型）；//（地板除，无论怎么除结果都是整数）<br>
乘法：*，** 乘方</p>
<h3 id="2-字符串"><a class="header-anchor" href="#2-字符串">¶</a>2. 字符串</h3>
<p>unicode编码，encode()编成指定bytes，decode()编成unicode。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">b'ABC'</span> <span class="comment">#以bytes形式存，占内存大小不一样。</span></span><br></pre></td></tr></table></figure>
<p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。（含参数errors='ignore’可以无视一部分报错）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  #提示操作系统是python可执行文件</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- #提示编码方式</span></span><br><span class="line"></span><br><span class="line">str1.replace(<span class="string">'a'</span>,<span class="string">'A'</span>) <span class="comment">#换字符</span></span><br></pre></td></tr></table></figure>
<h3 id="3-格式化"><a class="header-anchor" href="#3-格式化">¶</a>3. 格式化</h3>
<p>%s可以把其他数强制转换成字符串。<br>
%%：表示%</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:right">占位符</th>
<th style="text-align:left">替换内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">%d</td>
<td style="text-align:left">整数</td>
</tr>
<tr>
<td style="text-align:right">%f</td>
<td style="text-align:left">浮点数</td>
</tr>
<tr>
<td style="text-align:right">%s</td>
<td style="text-align:left">字符串</td>
</tr>
<tr>
<td style="text-align:right">%x</td>
<td style="text-align:left">十六进制整数</td>
</tr>
</tbody>
</table>
<h3 id="4-python里的四大集合"><a class="header-anchor" href="#4-python里的四大集合">¶</a>4. python里的四大集合</h3>
<h5 id="1-List"><a class="header-anchor" href="#1-List">¶</a>1. [] -List</h5>
<pre><code>如果一个list中一个元素也没有，就是一个空的list，它的长度为0。
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加元素</span></span><br><span class="line">classmates.append(<span class="string">'Adam'</span>)</span><br><span class="line"><span class="comment">#插入特定位置</span></span><br><span class="line">classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</span><br><span class="line"><span class="comment">#删除末尾元素</span></span><br><span class="line">classmates.pop()</span><br><span class="line"><span class="comment">#删除特定位置</span></span><br><span class="line">classmates.pop(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="2-tuple"><a class="header-anchor" href="#2-tuple">¶</a>2. () -tuple</h5>
<ul>
<li>tuple一旦初始化就不能修改, 这里是指指向不变，所以如果元素中有List，是可以改变List中的内容的。</li>
<li>只有1个元素的tuple定义时必须加一个逗号‘,’，来消除歧义, 否则表示数字1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,)</span><br></pre></td></tr></table></figure>
<h5 id="4-dict"><a class="header-anchor" href="#4-dict">¶</a>4. {} -dict</h5>
<ul>
<li>key无重复。</li>
<li>dict内部是无序的，key必须是不可变对象，list就是可变的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dict创建</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="comment">#dict添加元素</span></span><br><span class="line">d[<span class="string">'Adam'</span>] = <span class="number">10</span></span><br><span class="line"><span class="comment">#dict查找元素, 第二个参数表示没找到，默认返回值None，可以自定义</span></span><br><span class="line">d.get(<span class="string">'Tomas'</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">#删除元素</span></span><br><span class="line">d.pop(<span class="string">'bob'</span>)</span><br></pre></td></tr></table></figure>
<h5 id="5-set"><a class="header-anchor" href="#5-set">¶</a>5. ([]) - set</h5>
<p>数学意义上无重复，无序的集合。</p>
<ul>
<li>无value版的dict，内部无序，key不可变</li>
<li>同样key无重复</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建</span></span><br><span class="line">s = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">#添加元素</span></span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#删除元素</span></span><br><span class="line">s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#集合操作</span></span><br><span class="line">s1 &amp; s2</span><br><span class="line">s1 | s2</span><br></pre></td></tr></table></figure>
<h1>函数</h1>
<h2 id="返回值"><a class="header-anchor" href="#返回值">¶</a>返回值</h2>
<p>可以返回多个值，其原理其实是返回一个tuple，按位置传给特定的参数。</p>
<h2 id="五大参数"><a class="header-anchor" href="#五大参数">¶</a>五大参数</h2>
<h3 id="必选参数"><a class="header-anchor" href="#必选参数">¶</a>必选参数</h3>
<p>按位置匹配，不可不填。</p>
<h3 id="默认参数"><a class="header-anchor" href="#默认参数">¶</a>默认参数</h3>
<p>如果默认参数是类似list可变的，多次调用可能达不到想要的效果，因为每一次调用都会修改同一个list。所以一般默认参数指向不可变对象。</p>
<ul>
<li>一般来说不可变对象可以规避修改数据倒置的错误，由于对象不变，多任务的环境下，同时读取对象不需要加锁。</li>
</ul>
<h3 id="可变参数-arg"><a class="header-anchor" href="#可变参数-arg">¶</a>可变参数 *arg</h3>
<p>如果想直接传入不定数的参数，一种方式是定义list[],或者tuple()。<br>
还可以定义可变参数：可以不传</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*nums)</span>:</span></span><br><span class="line">   sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">      sum += n;</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">calc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#当传入list或者tuple时，在其前面加个*</span></span><br><span class="line">calc(*nums1)</span><br></pre></td></tr></table></figure>
<p>可变参数在函数调用时，自动封装成tuple。</p>
<h3 id="关键字参数-args"><a class="header-anchor" href="#关键字参数-args">¶</a>关键字参数 **args</h3>
<p>可以传入不定数的含参数名的参数，这些关键字参数会被自动封装成dict。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name,city,**kw)</span>:</span></span><br><span class="line">   print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line"><span class="comment">#可以做判断：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'city'</span> <span class="keyword">in</span> kw:</span><br><span class="line">        <span class="comment"># 有city参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'job'</span> <span class="keyword">in</span> kw:</span><br><span class="line">        <span class="comment"># 有job参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line"></span><br><span class="line">person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>调用该函数可以只传必选参数。<br>
可以直接传入dict：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</span><br><span class="line"><span class="comment"># name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="命名关键字参数"><a class="header-anchor" href="#命名关键字参数">¶</a>命名关键字参数</h3>
<p>顾名思义，规定传入关键字参数的名字，用<em>隔开必选参数.<br>
如果前面紧跟可变参数，可以省略</em>。<br>
可以有缺省值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'Beijing'</span>, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用必须使用关键字，否则会默认为位置参数。</span></span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, job=<span class="string">'Engineer'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参数组合"><a class="header-anchor" href="#参数组合">¶</a>参数组合</h3>
<p>五大参数组合一起用时，要按照既定顺序：必选参数，默认参数，可变参数，关键字参数，命名关键字参数。</p>
<h1>特性</h1>
<h3 id="1-切片"><a class="header-anchor" href="#1-切片">¶</a>1. 切片</h3>
<p>抽取部分值<br>
切片操作基本表达式：object[start_index:end_index:step]<br>
负数为反向</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>)[<span class="number">2</span>::<span class="number">3</span>][<span class="number">-5</span>:]: </span><br><span class="line">       print(i)</span><br><span class="line">n[::<span class="number">-1</span>] <span class="comment">#逆序切片</span></span><br></pre></td></tr></table></figure>
<p>[:]和.copy()都属于“浅拷贝”，只拷贝最外层元素，内层嵌套元素则通过引用方式共享，而非独立分配内存，如果需要彻底拷贝则需采用“深拷贝”方式，deepcopy().</p>
<h3 id="2-迭代"><a class="header-anchor" href="#2-迭代">¶</a>2. 迭代</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</span><br><span class="line">   print(x, y)</span><br><span class="line"><span class="comment">#enumerate函数可以把一个list变成索引-元素对</span></span><br><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</span><br><span class="line">   print(i, value)</span><br></pre></td></tr></table></figure>
<h3 id="3-列表生成器"><a class="header-anchor" href="#3-列表生成器">¶</a>3. 列表生成器</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line"><span class="comment">#还可以做判断</span></span><br><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment">#两层循环</span></span><br><span class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line"><span class="comment">#循环dict的key-value pair</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">   print(k, <span class="string">'='</span>, v)</span><br><span class="line">[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line"><span class="comment">#把list所有的str转成小写</span></span><br><span class="line">[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line"><span class="comment">#后面if是筛选条件</span></span><br><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment">#if..else是表达式</span></span><br><span class="line">[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="4-生成器"><a class="header-anchor" href="#4-生成器">¶</a>4. 生成器</h3>
<p>记录的是算法，只有在调用的时候才开始计算结果。<br>
next(g)返回一次计算值。for i in g</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line">next(g) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator，<br>
每次调用next()的时候执行，遇到yield语句返回.<br>
再次执行时从上次返回的yield语句处继续执行。</p>
<h3 id="5-迭代器"><a class="header-anchor" href="#5-迭代器">¶</a>5. 迭代器</h3>
<p>Iterator甚至可以表示一个无限大的数据流，可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</p>
<p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isinstance(iter([]), Iterator)</span><br><span class="line"><span class="comment">#True</span></span><br></pre></td></tr></table></figure>
<h1>函数式编程</h1>
<h3 id="高阶函数"><a class="header-anchor" href="#高阶函数">¶</a>高阶函数</h3>
<p>函数是一个变量，函数名可以看作变量能被当作参数传入函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = abs</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y,f)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数-Lambda"><a class="header-anchor" href="#匿名函数-Lambda">¶</a>匿名函数 Lambda</h3>
<p>关键字lambda表示匿名函数，冒号前面的n表示函数参数，可以有多个参数。<br>
匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p>
<h5 id="好处："><a class="header-anchor" href="#好处：">¶</a>好处：</h5>
<ol>
<li>不必担心函数名冲突。匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</li>
<li>有些函数在代码中只用一次，使用匿名函数可以减少代码量</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**y</span><br><span class="line"><span class="comment">#换成匿名函数</span></span><br><span class="line">calc = <span class="keyword">lambda</span> x,y:x**y</span><br><span class="line">print(calc(<span class="number">2</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> x*y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x / y    </span><br><span class="line"><span class="comment">#三元运算换成匿名函数</span></span><br><span class="line">calc = <span class="keyword">lambda</span> x,y:x * y <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> x / y</span><br><span class="line">print(calc(<span class="number">2</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h3 id="常用函数"><a class="header-anchor" href="#常用函数">¶</a>常用函数</h3>
<ol>
<li>map(f,Iterable)<br>
映射，将结果作为新的Iterator返回。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list[map(str,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])]</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>reduce(f,Iterable)<br>
叠加调用，重复的对上一次调用函数的结果与下一个序列调用函数计算结果。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> x + y</span><br><span class="line">reduce(add,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])<span class="comment"># 1+2+3+4+5</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>filter(f,Iterable)<br>
筛选，f的返回值应该会true或false，最后生成一个全为true的Iterator。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在一个list中，删掉偶数，只保留奇数</span></span><br><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]</span><br><span class="line">print(list(filter(<span class="keyword">lambda</span> x:x % <span class="number">2</span>==<span class="number">1</span>,li)))  <span class="comment"># [1, 5, 9, 15]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数</span></span><br><span class="line">li = list(range(<span class="number">1</span>, <span class="number">200</span>))</span><br><span class="line">print(list(filter(<span class="keyword">lambda</span> x:int(str(x))==int(str(x)[::<span class="number">-1</span>]),li)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">111</span>, <span class="number">121</span>, <span class="number">131</span>, <span class="number">141</span>, <span class="number">151</span>, <span class="number">161</span>, <span class="number">171</span>, <span class="number">181</span>, <span class="number">191</span>]</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>sorted(Iterable, key = None, reverse = false)<br>
对一个Iterable自定义排序：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对列表按照绝对值进行排序</span></span><br><span class="line">li= [<span class="number">-21</span>, <span class="number">-12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line">print(sorted(li, key = <span class="keyword">lambda</span> x:abs(x)))</span><br><span class="line"><span class="comment"># [5, 9, -12, -21, 36]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把下面单词以首字母排序</span></span><br><span class="line">li = [<span class="string">'bad'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>]</span><br><span class="line">print(sorted(li, key = <span class="keyword">lambda</span> x : x[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># 输出['Credit', 'Zoo', 'about', 'bad']</span></span><br></pre></td></tr></table></figure>
<h3 id="返回函数"><a class="header-anchor" href="#返回函数">¶</a>返回函数</h3>
<p>函数可以返回一个闭包，只有在调用这个函数的时候，闭包才会执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<h3 id="装饰器"><a class="header-anchor" href="#装饰器">¶</a>装饰器</h3>
<p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span> <span class="comment">#装饰器传入参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func) #装饰器会将传入的函数改名，这句改回来</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span> </span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            temp = func(*args, **kw)  <span class="comment">#在这个位置执行</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> temp <span class="comment">#返回执行传入的函数</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log('execute')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="偏函数"><a class="header-anchor" href="#偏函数">¶</a>偏函数</h3>
<p>为函数的参数设定默认值，返回一个新函数。仍然可以传入这个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>) <span class="comment">#表示int传入的str是二进制，转回十进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure>
<p>创建偏函数时，可以接收函数对象、*args和**kw这3个参数。</p>
<h1>模块</h1>
<p>将py文件放入文件夹下，文件夹名即是包名。<br>
只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py模块的名字就变成了mycompany.abc</p>
<p>每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<strong>init</strong>.py可以是空文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">' a test module '</span> <span class="comment">#模块注释</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Michael Liao'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    args = sys.argv</span><br><span class="line">    <span class="keyword">if</span> len(args)==<span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'Hello, world!'</span>)</span><br><span class="line">    <span class="keyword">elif</span> len(args)==<span class="number">2</span>:</span><br><span class="line">        print(<span class="string">'Hello, %s!'</span> % args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Too many arguments!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>: <span class="comment">#用于测试，其他地方导入这个模块时则不会执行</span></span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<h3 id="作用域"><a class="header-anchor" href="#作用域">¶</a>作用域</h3>
<p>默认是public的，可以被直接引用。<br>
<strong>xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author</strong>，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；<br>
类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等。<br>
Python并没有一种方法可以完全限制访问private函数或变量。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>包含min函数的栈｜《剑指offer》</title>
    <url>/2020/03/22/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。
</code></pre>
<a id="more"></a>
<h1>题解</h1>
<p>用一个辅助栈存取主栈的非严格递增序列。用min（）时，peek（）辅助栈。</p>
<h1>Code</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; mainStack,subStack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mainStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        subStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        mainStack.add(node);</span><br><span class="line">        <span class="keyword">if</span>(subStack.empty()||node&lt;=subStack.peek())&#123;</span><br><span class="line">            subStack.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bepop = mainStack.pop();</span><br><span class="line">        <span class="keyword">if</span>(bepop == subStack.peek())&#123;</span><br><span class="line">            subStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mainStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵｜《剑指offer》</title>
    <url>/2020/03/22/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
</code></pre>
<a id="more"></a>
<p>画圆取数，缩小范围，注意边界条件，取过的数不必再取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span>||matrix.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;<span class="keyword">int</span> bottom = row-<span class="number">1</span>;<span class="keyword">int</span> left = <span class="number">0</span>;<span class="keyword">int</span> right = column-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(top&lt;=bottom&amp;&amp;left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left;i&lt;=right;++i)</span><br><span class="line">                result.add(matrix[top][i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top+<span class="number">1</span>;i&lt;=bottom;++i)</span><br><span class="line">                result.add(matrix[i][right]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right-<span class="number">1</span>;top&lt;bottom&amp;&amp;i&gt;=left;--i)</span><br><span class="line">                result.add(matrix[bottom][i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom-<span class="number">1</span>;left&lt;right&amp;&amp;i&gt;top;--i)</span><br><span class="line">                result.add(matrix[i][left]);</span><br><span class="line">            ++left;++top;--right;--bottom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的镜像｜《剑指offer》</title>
    <url>/2020/03/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：操作给定的二叉树，将其变换为源二叉树的镜像。
</code></pre>
<a id="more"></a>
<h1>题解1 递归</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 先前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子节点，</span></span><br><span class="line"><span class="comment">当交换完所有的非叶子结点的左右子结点之后，就得到了树的镜像 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        TreeNode pTemp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = pTemp;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            Mirror(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>题解 2 迭代</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将二叉树中的节点逐层放入栈中，再迭代处理栈中的元素</span></span><br><span class="line">		LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode tmp = root;</span><br><span class="line">		stack.addFirst(tmp);</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">//每次都从栈中拿一个节点，并交换这个节点的左右子树</span></span><br><span class="line">			tmp = stack.removeFirst();</span><br><span class="line">			swapLR(tmp);</span><br><span class="line">			<span class="comment">//如果当前节点的左子树不为空，则放入栈等待后续处理</span></span><br><span class="line">			<span class="keyword">if</span>(tmp.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				stack.addFirst(tmp.left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果当前节点的右子树不为空，则放入栈等待后续处理</span></span><br><span class="line">			<span class="keyword">if</span>(tmp.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				stack.addFirst(tmp.right);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapLR</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        TreeNode temp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象思想</title>
    <url>/2020/03/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<a id="more"></a>
<h1>三大特性</h1>
<h3 id="1-封装"><a class="header-anchor" href="#1-封装">¶</a>1 封装</h3>
<p>利用抽象数据类型将数据和使用数据的方法封装，对外开放接口而不暴露对象内部实现的细节。使得用户无须关心对象内部的细节，而可以通过接口访问对象的数据和方法。</p>
<h3 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h3>
<ol>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ol>
<h3 id="2-继承"><a class="header-anchor" href="#2-继承">¶</a>2 继承</h3>
<p>实现is-A关系，子类可以继承自超类，获得超类非private的字段和方法。<br>
要遵循里氏替换原则：子类对象必须能够替换掉所有父类对象。只要有父类出现的地方，都可以用子类来替代，而且不会出现任何错误和异常。<br>
即可以实现向上转型。</p>
<h3 id="3-多态"><a class="header-anchor" href="#3-多态">¶</a>3 多态</h3>
<p>包括编译时多态和运行时多态：</p>
<ul>
<li>编译时多态是指方法的重载，overload。</li>
<li>运行时多态是指动态绑定，程序运行时能自动选择合适的方法。即程序中定义的对象引用所指向的实际类型在运行期间才确定。</li>
</ul>
<h5 id="运行时多态的三个条件："><a class="header-anchor" href="#运行时多态的三个条件：">¶</a>运行时多态的三个条件：</h5>
<ul>
<li>继承</li>
<li>覆写override</li>
<li>向上转型<br>
乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</li>
</ul>
<hr>
<h1>类图</h1>
<ol>
<li>泛化关系 (Generalization)<br>
用来描述继承关系，在 Java 中使用 extends 关键字。</li>
<li>实现关系 (Realization)<br>
用来实现一个接口，在 Java 中使用 implements 关键字。</li>
<li>聚合关系<br>
表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</li>
<li>组合关系<br>
和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</li>
<li>关联关系<br>
表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</li>
<li>依赖关系<br>
和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</li>
</ol>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法的参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。<br>
.</li>
</ul>
<hr>
<h1>六大设计原则</h1>
<h3 id="S-O-L-I-D"><a class="header-anchor" href="#S-O-L-I-D">¶</a>S.O.L.I.D</h3>
<table>
<thead>
<tr>
<th style="text-align:right">简写</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">SRP</td>
<td style="text-align:center">The Single Responsibility Principle</td>
<td style="text-align:center">单一责任原则</td>
</tr>
<tr>
<td style="text-align:right">OCP</td>
<td style="text-align:center">The Open Closed Principle</td>
<td style="text-align:center">开放封闭原则</td>
</tr>
<tr>
<td style="text-align:right">LSP</td>
<td style="text-align:center">The Liskov Substitution Principle</td>
<td style="text-align:center">里氏替换原则</td>
</tr>
<tr>
<td style="text-align:right">ISP</td>
<td style="text-align:center">The Interface Segregation Principle</td>
<td style="text-align:center">接口分离原则</td>
</tr>
<tr>
<td style="text-align:right">DIP</td>
<td style="text-align:center">The Dependency Inversion Principle</td>
<td style="text-align:center">依赖倒置原则</td>
</tr>
</tbody>
</table>
<h3 id="1-单一责任原则：修改一个类的原因只有一个"><a class="header-anchor" href="#1-单一责任原则：修改一个类的原因只有一个">¶</a>1 单一责任原则：修改一个类的原因只有一个</h3>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。<br>
降低耦合</p>
<h3 id="2-开放封闭原则：类应该对拓展开放，对修改关闭"><a class="header-anchor" href="#2-开放封闭原则：类应该对拓展开放，对修改关闭">¶</a>2 开放封闭原则：类应该对拓展开放，对修改关闭</h3>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。<br>
符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<h3 id="3-里氏替换原则：子类对象可以完全替换超类对象"><a class="header-anchor" href="#3-里氏替换原则：子类对象可以完全替换超类对象">¶</a>3 里氏替换原则：子类对象可以完全替换超类对象</h3>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。<br>
如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<h3 id="4-接口分离原则：不应该强迫客户依赖于它们不用的方法。"><a class="header-anchor" href="#4-接口分离原则：不应该强迫客户依赖于它们不用的方法。">¶</a>4 接口分离原则：不应该强迫客户依赖于它们不用的方法。</h3>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<h3 id="5-依赖倒置原则：高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。"><a class="header-anchor" href="#5-依赖倒置原则：高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。">¶</a>5 依赖倒置原则：高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</h3>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。<br>
面向抽象<br>
依赖于抽象意味着：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现的方法。<br>
.</li>
</ul>
<hr>
<h1>其他原则</h1>
<ol>
<li>迪米特法则<br>
迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</li>
<li>合成复用原则<br>
尽量使用对象组合，而不是通过继承来达到复用的目的。</li>
<li>共同封闭原则<br>
一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</li>
<li>稳定抽象原则<br>
最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</li>
<li>稳定依赖原则<br>
包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</li>
</ol>
]]></content>
      <tags>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>树的子结构｜《剑指offer》</title>
    <url>/2020/03/20/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
</code></pre>
<a id="more"></a>
<h1>Code</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1!=<span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                result = doesRoot2IssubTree(root1,root2);&#125;</span><br><span class="line">            <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">                result = HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">                result = HasSubtree(root1.right,root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doesRoot2IssubTree</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//root2为null必为子结构1，一定要在root1判断之前。</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root2.val != root1.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> doesRoot2IssubTree(root1.left,root2.left)</span><br><span class="line">            &amp;&amp;doesRoot2IssubTree(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>树的遍历总结</title>
    <url>/2020/03/19/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<pre><code>今天刷到二叉树，顺手总结一波树的遍历，实现一下。
</code></pre>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1>前序遍历</h1>
<p>根左右</p>
<h2 id="递归"><a class="header-anchor" href="#递归">¶</a>递归</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        traversal(root, aList);</span><br><span class="line">        <span class="keyword">return</span> aList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; aList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        aList.add(root.val);</span><br><span class="line">        traversal(root.left, aList);</span><br><span class="line">        traversal(root.right, aList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归"><a class="header-anchor" href="#非递归">¶</a>非递归</h2>
<p>压栈，先访问当前结点再压一路往左压，压到底pop出来，再迭代右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                aList.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.right;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>中序遍历</h1>
<p>左根右</p>
<h2 id="递归-v2"><a class="header-anchor" href="#递归-v2">¶</a>递归</h2>
<p>换一下访问的位置，先递归到左子树底再访问结点。</p>
<h2 id="非递归-v2"><a class="header-anchor" href="#非递归-v2">¶</a>非递归</h2>
<p>先把所有左子结点压栈，再pop出来访问，再递归右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            aList.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> aList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>后序遍历</h1>
<h2 id="解法一"><a class="header-anchor" href="#解法一">¶</a>解法一</h2>
<p>根右左的访问顺序得到刚好是与后序遍历相反的结果，最后逆序输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; aList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> aList;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);  </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            root = stack.pop();  </span><br><span class="line">            aList.push(root.val);      <span class="comment">//从头压</span></span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root.right);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法二"><a class="header-anchor" href="#解法二">¶</a>解法二</h2>
<ol>
<li>用cur记录前一个结点。</li>
<li>需要注意的是，右结点是cur而左结点不是cur的情况，说明刚从右子树遍历回来，没要再将左结点压栈。</li>
<li>而右结点的只要不是cur，说明没有遍历过右子树，需要将右结点压栈。</li>
<li>左右结点均不能压栈，说明左右都已遍历过，添加当前结点入结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> aList;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        stack.push(root);  </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            root = stack.peekFirst();  </span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span> &amp;&amp; root.left!= cur &amp;&amp; root.right!=cur)&#123;</span><br><span class="line">                stack.push(root.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>&amp;&amp; root.right!=cur)&#123;</span><br><span class="line">                stack.push(root.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                aList.add(stack.pop().val); </span><br><span class="line">                cur = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>层次遍历</h1>
<h2 id="BFS-宽度优先搜索"><a class="header-anchor" href="#BFS-宽度优先搜索">¶</a>BFS 宽度优先搜索</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; aQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> aList;</span><br><span class="line">        <span class="keyword">int</span> levels = <span class="number">0</span>;</span><br><span class="line">        aQueue.offerLast(root);</span><br><span class="line">        <span class="comment">//队列空前一直遍历</span></span><br><span class="line">        <span class="keyword">while</span>(!aQueue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//每层while循环代表一层遍历</span></span><br><span class="line">            aList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            <span class="keyword">int</span> size = aQueue.size();</span><br><span class="line">            <span class="comment">//每层结点的数量即为队列的大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123;</span><br><span class="line">                root = aQueue.pollFirst();</span><br><span class="line">                aList.get(levels).add(root.val);</span><br><span class="line">                <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>) aQueue.offerLast(root.left);</span><br><span class="line">                <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>) aQueue.offerLast(root.right);   </span><br><span class="line">            &#125;</span><br><span class="line">            levels++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> aList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DFS-深度优先搜索"><a class="header-anchor" href="#DFS-深度优先搜索">¶</a>DFS 深度优先搜索</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode root, <span class="keyword">int</span> levels)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(aList.size() == levels)</span><br><span class="line">            aList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        aList.get(levels).add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            travel(root.left, levels+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            travel(root.right, levels+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> aList;</span><br><span class="line">        <span class="keyword">int</span> levels = <span class="number">0</span>;</span><br><span class="line">        travel(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> aList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有些题目要求自底向上"><a class="header-anchor" href="#有些题目要求自底向上">¶</a>有些题目要求自底向上</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加个链表反转完事</span></span><br><span class="line">Collections.reverse(ans);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表｜《剑指offer》</title>
    <url>/2020/03/19/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入一个链表，反转链表后，输出新链表的表头。
</code></pre>
<a id="more"></a>
<h1>题解</h1>
<p>pre head next来交换。</p>
<h1>Code</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span></span><br><span class="line">        <span class="comment">//需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span></span><br><span class="line">        <span class="comment">//即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了</span></span><br><span class="line">        <span class="comment">//所以需要用到pre和next两个节点</span></span><br><span class="line">        <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5</span></span><br><span class="line">        <span class="comment">//1&lt;-2&lt;-3 4-&gt;5</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span></span><br><span class="line">            <span class="comment">//如此就可以做到反转链表的效果</span></span><br><span class="line">            <span class="comment">//先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span></span><br><span class="line">            next = head.next;</span><br><span class="line">            <span class="comment">//保存完next，就可以让head从指向next变成指向pre了，代码如下</span></span><br><span class="line">            head.next = pre;</span><br><span class="line">            <span class="comment">//head指向pre后，就继续依次反转下一个节点</span></span><br><span class="line">            <span class="comment">//让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span></span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点</span></span><br><span class="line">        <span class="comment">//直接输出pre就是我们想要得到的反转后的链表</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统总结-进程管理</title>
    <url>/2020/03/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>《Java核心技术卷一》读书笔记二</title>
    <url>/2020/03/18/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    <content><![CDATA[<a id="more"></a>
<h1>第五章 继承</h1>
<ol>
<li>
<p>子类没有调用超类的构造方法，默认会调用超类无参构造器，如果不存在则报错。</p>
</li>
<li>
<p>多态：一个对象变量可以指示多种实际类型，父类既可引用父类类型，也可引用子类类型，但是父类不可调用子类的方法。动态绑定：运行时能自动地选择合适的方法。Java默认动态绑定，否则要标记final。</p>
</li>
<li>
<p>标记了private，final，static的方法调用则是静态绑定，编译器无须搜寻其子类的方法，只能使用这个方法。</p>
</li>
<li>
<p>override：子类覆写的方法访问性不得高于超类，即超类为private，则子类不得是public。对于使用频繁，较短的，且没有被override的方法，编译器会自动内联处理，将函数体插入并取代调用函数的地方，增加效率。</p>
</li>
<li>
<p>final：对类或者方法标记final，则不能有继承的子类，或者不能被覆写。</p>
</li>
<li>
<p>Object: 要比较对象是否相等，覆写equals()方法，记得用静态方法判断字段相等Object.equals(a,b)。覆写hashcode方法同样使用静态方法，而且两者应该一致，即相等性使用判断的字段应该与用于计算hashcode的字段相同。<br>
字典类对象可以用静态方法Array.equals()和Array.hashcode()，无须override.</p>
</li>
<li>
<p>包装类对象类似Integer, Long, Float是不可变的，在该使用对象类型的方法中使用基本类型，编译器会自动装箱，同时也有自动拆箱。但是比较时不能使用 == ，要用equals方法。除了boolean,byte,char&lt;=127的，或者short，int在-128和127之间的可用 ==，编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
</li>
<li>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
</li>
</ol>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。<br>
在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</size></li>
</ul>
<p>基本类型对应的缓冲池如下：<br>
boolean values true and false<br>
all byte values<br>
short values between -128 and 127<br>
int values between -128 and 127<br>
char in the range \u0000 to \u007F</p>
<ol start="7">
<li>
<p>判断两对象是否是同一类：用反射，if(e.getclass() == Emloyee.class)，instanceof是包括子类的。</p>
</li>
<li>
<p>String：<br>
声明为final，不可继承。不可变。<br>
value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p>
<h1>第六章 接口</h1>
<ol>
<li>x.compareTo(y) 方法一定要实现comparable接口否则Jvm会报错。当子类继承超类也要实现compareTo方法时，类型要相同，if(getclass()!= other.getclass) throw new ClassCastException 否则违反反对称原则。超类的方法是通用方法，则记得要生命 final。</li>
<li>需要使用深拷贝：类的字段中引用了其他类对象。则要实现clonable接口，并覆写clone()方法。</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>《Java核心技术》</tag>
      </tags>
  </entry>
  <entry>
    <title>调整数组顺序使奇数位于偶数前面｜《剑指offer》</title>
    <url>/2020/03/18/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
</code></pre>
<a id="more"></a>
<h1>题解</h1>
<p>计算已放好位置的奇数个数，当当前位置为奇数且前面个数多于奇数个数，证明存在偶数，偶数的数量即为当前个数-奇数个数，将偶数一次往后挪，把奇数放于对应位置。<br>
解法类似插入排序。</p>
<h1>Code</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>||array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> obb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((array[i]%<span class="number">2</span>==<span class="number">1</span>))&#123;</span><br><span class="line">                num = i;</span><br><span class="line">                <span class="keyword">int</span> current = array[i];</span><br><span class="line">                <span class="keyword">while</span>(num&gt;obb)&#123;</span><br><span class="line">                    array[num] = array[num-<span class="number">1</span>];</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">                array[num] = current;</span><br><span class="line">                obb++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>数值的整数次方｜《剑指offer》</title>
    <url>/2020/03/18/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0
</code></pre>
<a id="more"></a>
<h1>code：</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//浮点数比较不能用 ==，会损失精度</span></span><br><span class="line">        <span class="keyword">if</span>(equal(base,<span class="number">0.0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">            exponent = <span class="number">0</span> - exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> exp = base;</span><br><span class="line">        <span class="comment">//注意：== 的优先级比&amp;大</span></span><br><span class="line">        <span class="keyword">if</span>((exponent&amp;(exponent-<span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">            base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(exponent&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            exp *= exp;</span><br><span class="line">            exponent &gt;&gt;=<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exp*base;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1-num2&gt;-<span class="number">0.000001</span>&amp;&amp;num1-num2&lt;<span class="number">0.000001</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制中1的个数｜《剑指Offer》</title>
    <url>/2020/03/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
</code></pre>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n&amp;(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Design_Patterns</title>
    <url>/2020/03/17/Java-Design-Patterns/</url>
    <content><![CDATA[<h1>创新型模式</h1>
<p>关注点是如何创建对象，对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>
<h3 id="工厂方法-Factory-Method"><a class="header-anchor" href="#工厂方法-Factory-Method">¶</a>工厂方法 Factory Method</h3>
<p>解决关键字new造成的客户端和实际类型耦合问题。<br>
接口定义标准，子类通过实现接口，通过利用子类的对象向上转型创建接口的实例化对象。<br>
产品：返回的对象。<br>
静态工厂方法：在接口处，通过静态方法直接返回产品。<br>
如: valueOf()来创建Integer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好处：工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。拓展子类，也只需要修改valueOf即可。</p>
<p>里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。尽可能的面向抽象编程。<br>
静态工厂方法也可以接收可变参数，返回接口。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br></pre></td></tr></table></figure>
<p>通过向上转型的实现，调用方总是获取List接口，而不关心它的实际类型。<br>
再如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageDigest md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">MessageDigest sha1 = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</span><br></pre></td></tr></table></figure>
<p>调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是MessageDigest这个抽象类。</p>
<h4 id="抽象工厂-Abstract-Factory"><a class="header-anchor" href="#抽象工厂-Abstract-Factory">¶</a>抽象工厂 Abstract Factory</h4>
<pre><code>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
</code></pre>
<p>客户端创建工厂，只需要与工厂接口静态方法对接，根据需求传入不同的参数，创建特定的实例化对象工厂。创建产品，也根据不同工厂使用不同的方法创建特定的产品。</p>
<h4 id="Builder模式"><a class="header-anchor" href="#Builder模式">¶</a>Builder模式</h4>
<p>创建复杂对象时，将步骤分解成多个方法，据特性把每一行都“委托”给一个XxxBuilder去转换，最后，把所有转换的结果组合起来，返回给客户端。</p>
<h4 id="原型模式-Prototype"><a class="header-anchor" href="#原型模式-Prototype">¶</a>原型模式 Prototype</h4>
<p>创建新对象时，根据现有的一个原型来创建。<br>
实现原型的拷贝，用Object提供的clone()方法，需要实现Cloneable接口来标识一个对象是可复制的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制新对象并返回:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student std = <span class="keyword">new</span> Student();</span><br><span class="line">        std.id = <span class="keyword">this</span>.id;</span><br><span class="line">        std.name = <span class="keyword">this</span>.name;</span><br><span class="line">        std.score = <span class="keyword">this</span>.score;</span><br><span class="line">        <span class="keyword">return</span> std;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时，要强制转型，因为Object返回类型也是Object：</span></span><br><span class="line">Student std2 = (Student) std1.clone();</span><br></pre></td></tr></table></figure>
<p>更好的方法，定义一个copy()方法，明确类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student std = <span class="keyword">new</span> Student();</span><br><span class="line">        std.id = <span class="keyword">this</span>.id;</span><br><span class="line">        std.name = <span class="keyword">this</span>.name;</span><br><span class="line">        std.score = <span class="keyword">this</span>.score;</span><br><span class="line">        <span class="keyword">return</span> std;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p>
<h4 id="单例-Singleton"><a class="header-anchor" href="#单例-Singleton">¶</a>单例 Singleton</h4>
<pre><code>保证某个类仅有一个实例，并提供一个访问它的全局访问点。
</code></pre>
<p>有两种实现方法：</p>
<ul>
<li>静态字段引用全局唯一实例。</li>
</ul>
<ol>
<li>只有private构造方法，确保外部无法实例化；</li>
<li>通过private static变量持有唯一实例，保证全局唯一性；</li>
<li>通过public static方法返回此唯一实例，使外部调用方能获取到实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态方法返回实例:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者将static变量暴露给外部</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写只有一个枚举的类</li>
</ul>
<p>除非确有必要，否则Singleton模式一般以“约定”为主，让框架来实例话这些类，不会刻意实现它。</p>
<h1>结构型模式</h1>
<p>通过接口间的组合完成需求。</p>
<h3 id="适配器-Adapter"><a class="header-anchor" href="#适配器-Adapter">¶</a>适配器 Adapter</h3>
<p>顾名思义，接收一个接口，在目标接口的实现内部调用带转换接口的方法。</p>
<ol>
<li>实现目标接口，这里是Runnable；</li>
<li>内部持有一个待转换接口的引用，这里是通过字段持有Callable接口；</li>
<li>在目标接口的实现方法内部，调用待转换接口的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BAdapter implements B &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BAdapter</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有A、B接口均为抽象接口时，才能非常简单地实现Adapter模式。</p>
<h3 id="代理模式Proxy"><a class="header-anchor" href="#代理模式Proxy">¶</a>代理模式Proxy</h3>
<pre><code>对其他对象提供一种代理以控制对这个对象的访问。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AProxy implements A &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AProxy</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有点像Adapter,但是它还是转换成A接口。<br>
程序设计的原则：</p>
<ul>
<li>职责清晰：一个类负责一件事</li>
<li>易于测试<br>
作用：获得更清晰、简洁的代码</li>
<li>A接口：只定义接口；</li>
<li>ABusiness类：只实现A接口的业务逻辑；</li>
<li>APermissionProxy类：只实现A接口的权限检查代理。</li>
</ul>
<h4 id="权限检查"><a class="header-anchor" href="#权限检查">¶</a>权限检查</h4>
<p>如a方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getCurrentUser().isRoot()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a.a();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Forbidden"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="远程代理"><a class="header-anchor" href="#远程代理">¶</a>远程代理</h4>
<p>远程代理即Remote Proxy，Java内置的RMI机制就是一个完整的远程代理模式。</p>
<h4 id="虚代理"><a class="header-anchor" href="#虚代理">¶</a>虚代理</h4>
<p>直到客户端真正调用方法时才创建真正的对象，JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p>
<h4 id="智能引用"><a class="header-anchor" href="#智能引用">¶</a>智能引用</h4>
<p>如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>距形覆盖｜《剑指offer》</title>
    <url>/2020/03/17/%E8%B7%9D%E5%BD%A2%E8%A6%86%E7%9B%96%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
</code></pre>
<h1>题解</h1>
<p>斐波那契数列变相形式，同类型的还有跳阶梯。</p>
<h1>Code</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target  == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target*<span class="number">2</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target*<span class="number">2</span> == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> RectCover((target-<span class="number">1</span>))+RectCover(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组最小的数字｜《剑指offer》</title>
    <url>/2020/03/16/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
</code></pre>
<a id="more"></a>
<h2 id="题解"><a class="header-anchor" href="#题解">¶</a>题解</h2>
<p>在start处的元素&gt;=end处元素的位置二分法查找，middle大于start位置的元素，则查右半区。middle小于start位置的元素，则查左半区。</p>
<h2 id="Code"><a class="header-anchor" href="#Code">¶</a>Code</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[start] &gt;= array[end])&#123;</span><br><span class="line">            <span class="keyword">if</span>(end - start &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                middle = end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[middle] &gt;= array[start])&#123;</span><br><span class="line">                start = middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[middle] &lt;= array[end])</span><br><span class="line">                end = middle;</span><br><span class="line">            </span><br><span class="line">    &#125;    </span><br><span class="line">         <span class="keyword">return</span> array[middle];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的函数式编程</title>
    <url>/2020/03/15/Java%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<pre><code>又名Lambda计算，函数式编程还是挺好玩的，可以把函数本身作为参数传入另一个函数，还允许返回一个函数，很方便。不过这类编程不稳定，函数内部的变量状态不确定，相同的输入可能得到不同的输出。而且抽象程度高，那么运行效率就会偏低。
</code></pre>
<a id="more"></a>
<h3 id="Lambda表达式"><a class="header-anchor" href="#Lambda表达式">¶</a>Lambda表达式</h3>
<p>单方法接口(FunctionalInterface)：一个接口只定义了一个方法：</p>
<ul>
<li>Comparator</li>
<li>Runnable</li>
<li>Callable<br>
如，使用Arrays.sort()时，可以传入Comparator实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">Arrays.sort(array, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以用Lambda表达式替换单方法接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(array, (s1, s2) -&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>如果只有一行return xxx的代码，完全可以用更简单的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure>
<p>编译器可以自动推断出参数类型和返回值类型。</p>
<h3 id="FunctionalInterface"><a class="header-anchor" href="#FunctionalInterface">¶</a>@FunctionalInterface</h3>
<p>单方法接口会在接口定义前加上@FunctionalInterface的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparing</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然Comparator接口有很多方法，但只有一个抽象方法int compare(T o1, T o2)，其他的方法都是default方法或static方法。另外注意到boolean equals(Object obj)是Object定义的方法，不算在接口方法内。因此，Comparator也是一个FunctionalInterface。</p>
<h1>方法引用</h1>
<p>是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用。<br>
因为Comparator<String>接口定义的方法是int compare(String, String)，和静态方法int cmp(String, String)相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入：</String></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(array, Main::cmp);</span><br></pre></td></tr></table></figure>
<p>String.compareTo()方法也符合Lambda定义。<br>
这个方法的签名只有一个参数，为什么和int Comparator<String>.compare(String, String)能匹配呢？<br>
因为有隐含参数this,相当于静态方法。</String></p>
<h3 id="构造方法引用"><a class="header-anchor" href="#构造方法引用">¶</a>构造方法引用</h3>
<p>可以用来快速转换类型：如果要把一个List<String>转换为List<Person>。</Person></String></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = names.stream().map(Person::<span class="keyword">new</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>正常来说是要创建一个新的ArrayList<Person>,然后一个个添加。</Person></p>
<h1>stream</h1>
<p>流式API：在java.util.stream包中。<br>
它不同于java.io的InputStream和OutputStream,它代表的是任意Java对象的序列。</p>
<table>
<thead>
<tr>
<th style="text-align:right">*</th>
<th style="text-align:center"><a href="http://java.io" target="_blank" rel="noopener">java.io</a></th>
<th style="text-align:center">java.util.stream</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">存储</td>
<td style="text-align:center">顺序读写的byte或char</td>
<td style="text-align:center">顺序输出的任意Java对象实例</td>
</tr>
<tr>
<td style="text-align:right">用途</td>
<td style="text-align:center">序列化至文件或网络</td>
<td style="text-align:center">内存计算/业务逻辑</td>
</tr>
</tbody>
</table>
<p>Stream与List的不同：Stream输出的元素可能是实时计算出来的，没有预存在内存中。是惰性计算，即真正的计算发生在最后结果的获取。<br>
一个Stream 转换为另一个Stream 实际上只存储了转换规则，并没有任何计算发生。</p>
<h3 id="stream的用法"><a class="header-anchor" href="#stream的用法">¶</a>stream的用法</h3>
<p>我们通常把Stream的操作写成链式操作，代码更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream();</span><br><span class="line">naturals.map(n -&gt; n.multiply(n)) <span class="comment">// 1, 4, 9, 16, 25...</span></span><br><span class="line">        .limit(<span class="number">100</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = createNaturalStream() <span class="comment">// 创建Stream,所有自然数</span></span><br><span class="line">             .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .map(n -&gt; n * n) <span class="comment">// 任意个转换</span></span><br><span class="line">             .limit(<span class="number">100</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .sum(); <span class="comment">// 最终计算结果</span></span><br></pre></td></tr></table></figure>
<h3 id="Stream-map"><a class="header-anchor" href="#Stream-map">¶</a>Stream.map()</h3>
<p>映射，对一组基本类型或者对象应用特定函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 将T类型转换为R:</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其定义了一个方法，把T类型转换成R类型。<br>
如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);</span><br><span class="line"></span><br><span class="line">List.of(<span class="string">"  Apple "</span>, <span class="string">" pear "</span>, <span class="string">" ORANGE"</span>, <span class="string">" BaNaNa "</span>)</span><br><span class="line">        .stream()</span><br><span class="line">        .map(String::trim) <span class="comment">// 去空格</span></span><br><span class="line">        .map(String::toLowerCase) <span class="comment">// 变小写</span></span><br><span class="line">        .forEach(System.out::println); <span class="comment">// 打印</span></span><br></pre></td></tr></table></figure>
<p>转化字符串并输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = <span class="keyword">new</span> String[] &#123; <span class="string">" 2019-12-31 "</span>, <span class="string">"2020 - 01-09 "</span>, <span class="string">"2020- 05 - 01 "</span>, <span class="string">"2022 - 02 - 01"</span>,</span><br><span class="line">				<span class="string">" 2025-01 -01"</span> &#125;;</span><br><span class="line">		<span class="comment">// 请使用map把String[]转换为LocalDate并打印:</span></span><br><span class="line">		Arrays.stream(array)</span><br><span class="line">			.map(s -&gt; s.replaceAll(<span class="string">"\\s+"</span>, <span class="string">""</span>))</span><br><span class="line">			.map(LocalDate::parse)</span><br><span class="line">			.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="Stream-reduce"><a class="header-anchor" href="#Stream-reduce">¶</a>Stream.reduce()</h3>
<p>将Stream所有的元素按照聚合函数聚合成一个结果。<br>
reduce()方法传入的对象是BinaryOperator接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryOperator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Bi操作：两个输入，一个输出</span></span><br><span class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t, T u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作：首先设定初始值，然后是参数和方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>).reduce(<span class="number">1</span>, (acc, n) -&gt; acc * n);</span><br><span class="line">        System.out.println(s); <span class="comment">// 362880</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MapReduce操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按行读取配置文件:</span></span><br><span class="line">        List&lt;String&gt; props = List.of(<span class="string">"profile=native"</span>, <span class="string">"debug=true"</span>, <span class="string">"logging=warn"</span>, <span class="string">"interval=500"</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = props.stream()</span><br><span class="line">                <span class="comment">// 把k=v转换为Map[k]=v:</span></span><br><span class="line">                .map(kv -&gt; &#123;</span><br><span class="line">                    String[] ss = kv.split(<span class="string">"\\="</span>, <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">return</span> Map.of(ss[<span class="number">0</span>], ss[<span class="number">1</span>]);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 把所有Map聚合到一个Map:</span></span><br><span class="line">                .reduce(<span class="keyword">new</span> HashMap&lt;String, String&gt;(), (m, kv) -&gt; &#123;</span><br><span class="line">                    m.putAll(kv);</span><br><span class="line">                    <span class="keyword">return</span> m;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 打印结果:</span></span><br><span class="line">        map.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">" = "</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filter"><a class="header-anchor" href="#filter">¶</a>filter</h3>
<p>顾名思义，筛选。<br>
filter()方法接收的对象是Predicate接口对象，它定义了一个test()方法，负责判断元素是否符合条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 判断元素t是否符合条件:</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">                .filter(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以应用于任何Java对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(<span class="keyword">new</span> LocalDateSupplier())</span><br><span class="line">        .limit(<span class="number">31</span>)</span><br><span class="line">        .filter(ldt -&gt; ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="输出集合"><a class="header-anchor" href="#输出集合">¶</a>输出集合</h3>
<p>转化操作如map, filter是不会进行任何计算，只是改变了Stream内部的规则，而进行了聚合操作如reduce，则会真正的向Stream请求数据，所以其输出结果也不再是Stream，而是一个Java对象。<br>
聚合操作是不断的向上游请求数据，直至在实例中请求到真正的元素。</p>
<h4 id="输出为List"><a class="header-anchor" href="#输出为List">¶</a>输出为List</h4>
<p>把Stream的每个元素收集到List的方法是调用collect()并传入Collectors.toList()对象，它实际上是一个Collector实例，通过类似reduce()的操作，把每个元素添加到一个收集器中（实际上是ArrayList）。<br>
类似的，collect(Collectors.toSet())可以把Stream的每个元素收集到Set中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tream&lt;String&gt; stream = Stream.of(<span class="string">"Apple"</span>, <span class="string">""</span>, <span class="keyword">null</span>, <span class="string">"Pear"</span>, <span class="string">"  "</span>, <span class="string">"Orange"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.filter</span><br><span class="line">        (s -&gt; s != <span class="keyword">null</span> &amp;&amp; !s.isBlank())</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h4 id="输出为Array"><a class="header-anchor" href="#输出为Array">¶</a>输出为Array</h4>
<p>调用toArray()即可，传入数组的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>);</span><br><span class="line">String[] array = list.stream().toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<h4 id="输出为Map"><a class="header-anchor" href="#输出为Map">¶</a>输出为Map</h4>
<p>要指定两个映射函数，分别把元素映射为key和value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"APPL:Apple"</span>, <span class="string">"MSFT:Microsoft"</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = stream</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        <span class="comment">// 把元素s映射为key:</span></span><br><span class="line">                        s -&gt; s.substring(<span class="number">0</span>, s.indexOf(<span class="string">':'</span>)),</span><br><span class="line">                        <span class="comment">// 把元素s映射为value:</span></span><br><span class="line">                        s -&gt; s.substring(s.indexOf(<span class="string">':'</span>) + <span class="number">1</span>)));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分组输出"><a class="header-anchor" href="#分组输出">¶</a>分组输出</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Blackberry"</span>, <span class="string">"Coconut"</span>, <span class="string">"Avocado"</span>, <span class="string">"Cherry"</span>, <span class="string">"Apricots"</span>);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>), Collectors.toList()));</span><br><span class="line">        System.out.println(groups);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分组输出使用Collectors.groupingBy()，它需要提供两个函数：一个是分组的key，第二个是分组的value，这里直接使用Collectors.toList()，表示输出为List.</p>
<h2 id="其他操作"><a class="header-anchor" href="#其他操作">¶</a>其他操作</h2>
<h3 id="排序-sorted"><a class="header-anchor" href="#排序-sorted">¶</a>排序 sorted()</h3>
<p>转换操作，此方法要求Stream的每个元素必须实现Comparable接口。如果要自定义排序，传入指定的Comparator即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"Orange"</span>, <span class="string">"apple"</span>, <span class="string">"Banana"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted(String::compareToIgnoreCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="去重-distinct"><a class="header-anchor" href="#去重-distinct">¶</a>去重 distinct()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"D"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [A, B, C, D]</span></span><br></pre></td></tr></table></figure>
<h3 id="截取-skip-n-limit-n"><a class="header-anchor" href="#截取-skip-n-limit-n">¶</a>截取 skip(n) limit(n)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .skip(<span class="number">2</span>) <span class="comment">// 跳过A, B</span></span><br><span class="line">    .limit(<span class="number">3</span>) <span class="comment">// 截取C, D, E</span></span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [C, D, E]</span></span><br></pre></td></tr></table></figure>
<h3 id="合并-concat"><a class="header-anchor" href="#合并-concat">¶</a>合并 concat()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s1 = List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).stream();</span><br><span class="line">Stream&lt;String&gt; s2 = List.of(<span class="string">"D"</span>, <span class="string">"E"</span>).stream();</span><br><span class="line"><span class="comment">// 合并:</span></span><br><span class="line">Stream&lt;String&gt; s = Stream.concat(s1, s2);</span><br><span class="line">System.out.println(s.collect(Collectors.toList())); <span class="comment">// [A, B, C, D, E]</span></span><br></pre></td></tr></table></figure>
<h3 id="flatMap"><a class="header-anchor" href="#flatMap">¶</a>flatMap</h3>
<p>合并成新的Stream:把每个结构内的元素取出来，映射一个新的Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//而我们希望把上述Stream转换为Stream&lt;Integer&gt;，就可以使用flatMap()：</span></span><br><span class="line">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure>
<h3 id="并行"><a class="header-anchor" href="#并行">¶</a>并行</h3>
<p>只需要用parallel()进行转换为可并行的Stream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">String[] result = s.parallel() <span class="comment">// 变成一个可以并行处理的Stream</span></span><br><span class="line">                   .sorted() <span class="comment">// 可以进行并行排序</span></span><br><span class="line">                   .toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<h3 id="其他方法"><a class="header-anchor" href="#其他方法">¶</a>其他方法</h3>
<p>聚合方法：<br>
count()：用于返回元素个数；<br>
max(Comparator&lt;? super T&gt; cp)：找出最大元素；<br>
min(Comparator&lt;? super T&gt; cp)：找出最小元素。</p>
<p>针对IntStream、LongStream和DoubleStream，还额外提供了以下聚合方法：<br>
sum()：对所有元素求和；<br>
average()：对所有元素求平均数。</p>
<p>条件判断：<br>
boolean allMatch(Predicate&lt;? super T&gt;)：测试是否所有元素均满足测试条件；<br>
boolean anyMatch(Predicate&lt;? super T&gt;)：测试是否至少有一个元素满足测试条件。</p>
<p>循环操作：forEach(注意这个E)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">s.forEach(str -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, "</span> + str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java正则表达式</title>
    <url>/2020/03/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<pre><code>Java标准库的java.util.regex包内置了正则表达式引擎。Java使用正则记得前面加多一个转意字符\。
</code></pre>
<a id="more"></a>
<h4 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regex = <span class="string">"20\\d\\d"</span>;</span><br><span class="line">        System.out.println(<span class="string">"2019"</span>.matches(regex)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"2100"</span>.matches(regex)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="匹配符"><a class="header-anchor" href="#匹配符">¶</a>匹配符</h4>
<p>任意字符：.<br>
数字：\d<br>
非数字：\D(大写就是反着来)<br>
空格: \s,<br>
tab:\t</p>
<h4 id="重复匹配"><a class="header-anchor" href="#重复匹配">¶</a>重复匹配</h4>
<ol>
<li>匹配0~n个字符：*<br>
\d*</li>
<li>匹配至少一个字符：+<br>
\d+</li>
<li>0个或者一个字符：？</li>
<li>精确指定n个字符：{n}或者{n,m}:<br>
\d{3},\d{3,5}匹配3-5个<br>
没有上限就{n,}</li>
</ol>
<p>先记这么多把，复杂的以后用到的时候再查查。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔和哈夫曼编码</title>
    <url>/2020/03/15/%E6%B1%89%E8%AF%BA%E5%A1%94%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1>汉诺塔</h1>
<p>an = 2 * an-1 + 1，an = 2n - 1，n 个圆盘需要移动 2n - 1 次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, String from, String buffer, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"from "</span> + from + <span class="string">" to "</span> + to);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move(n - <span class="number">1</span>, from, to, buffer);</span><br><span class="line">        move(<span class="number">1</span>, from, buffer, to);</span><br><span class="line">        move(n - <span class="number">1</span>, buffer, from, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hanoi.move(<span class="number">3</span>, <span class="string">"H1"</span>, <span class="string">"H2"</span>, <span class="string">"H3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>汉夫曼编码</h1>
<p>根据数据出现的频率对数据进行编码，从而压缩原始数据。<br>
例如对于一个文本文件，其中各种字符出现的次数如下：</p>
<ul>
<li>a : 10</li>
<li>b : 20</li>
<li>c : 40</li>
<li>d : 80<br>
可以将每种字符转换成二进制编码，例如将 a 转换为 00，b 转换为 01，c 转换为 10，d 转换为 11。这是最简单的一种编码方式，没有考虑各个字符的权值（出现频率）。而哈夫曼编码采用了贪心策略，使出现频率最高的字符的编码最短，从而保证整体的编码长度最短。</li>
</ul>
<p>首先生成一颗哈夫曼树，每次生成过程中选取频率最少的两个节点，生成一个新节点作为它们的父节点，并且新节点的频率为两个节点的和。选取频率最少的原因是，生成过程使得先选取的节点位于树的更低层，那么需要的编码长度更长，频率更少可以使得总编码长度更少。</p>
<p>生成编码时，从根节点出发，向左遍历则添加二进制位 0，向右则添加二进制位 1，直到遍历到叶子节点，叶子节点代表的字符的编码就是这个路径编码。</p>
<h4 id="哈夫曼树"><a class="header-anchor" href="#哈夫曼树">¶</a>哈夫曼树</h4>
<p>又为最优二叉树，n个带权叶子结点构成的所有二叉树中，带权路径长度最小的二叉树（各个叶子节点的路径长度与对应权值的乘积之和）。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java单元测试</title>
    <url>/2020/03/14/Java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1>JUnit</h1>
<p>TDD: 测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, Factorial.fact(<span class="number">1</span>));</span><br><span class="line">        assertEquals(<span class="number">2</span>, Factorial.fact(<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, Factorial.fact(<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="number">3628800</span>, Factorial.fact(<span class="number">10</span>));</span><br><span class="line">        assertEquals(<span class="number">2432902008176640000L</span>, Factorial.fact(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>assertEquals(expected, actual)是最常用的测试方法，它在Assertion类中定义。Assertion还定义了其他断言方法，例如：</p>
<ul>
<li>assertTrue(): 期待结果为true</li>
<li>assertFalse(): 期待结果为false</li>
<li>assertNotNull(): 期待结果为非null</li>
<li>assertArrayEquals(): 期待结果为数组并与期望数组每个元素的值均相等</li>
</ul>
<h3 id="Fixture"><a class="header-anchor" href="#Fixture">¶</a>Fixture</h3>
<ol>
<li>对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理，它们在各个@Test方法中互不影响，因为是不同的实例；</li>
<li>对于静态变量（如数据库的开关），在@BeforeAll中初始化，在@AfterAll中清理，它们在各个@Test方法中均是唯一实例，会影响各个@Test方法。<br>
最后，注意到每次运行一个@Test方法前，JUnit首先创建一个XxxTest实例，因此，每个@Test方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个@Test方法带到另一个@Test方法。</li>
</ol>
<h1>异常测试</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Executable</span>() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JUnit提供assertThrows()来期望捕获一个指定的异常。第二个参数Executable封装了我们要执行的会产生异常的代码。当我们执行Factorial.fact(-1)时，必定抛出IllegalArgumentException。</p>
<p>Java 8后，函数式编程，所有单方法接口都可以简写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException<span class="class">.<span class="keyword">class</span>, () -&gt; </span>&#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>条件测试</h1>
<h3 id="Disabled"><a class="header-anchor" href="#Disabled">¶</a>@Disabled</h3>
<p>需要注释掉某些方法，可以标记@Disabled。</p>
<h3 id="EnableOnOs（判断操作系统）"><a class="header-anchor" href="#EnableOnOs（判断操作系统）">¶</a>@EnableOnOs（判断操作系统）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs</span>(OS.WINDOWS)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testWindows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">"C:\\test.ini"</span>, config.getConfigFile(<span class="string">"test.ini"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs</span>(&#123; OS.LINUX, OS.MAC &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLinuxAndMac</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">"/usr/local/test.cfg"</span>, config.getConfigFile(<span class="string">"test.cfg"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DisabledOnOs"><a class="header-anchor" href="#DisabledOnOs">¶</a>@DisabledOnOs</h3>
<p>在某些操作系统执行。</p>
<h3 id="EnabledIfEnvironmentVariable"><a class="header-anchor" href="#EnabledIfEnvironmentVariable">¶</a>@EnabledIfEnvironmentVariable</h3>
<p>传入环境变量 DEBUG=true 才能执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfEnvironmentVariable</span>(named = <span class="string">"DEBUG"</span>, matches = <span class="string">"true"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnlyOnDebugMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on DEBUG=true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="万能的-EnableIf"><a class="header-anchor" href="#万能的-EnableIf">¶</a>万能的@EnableIf</h3>
<p>可以执行任意Java语句并根据返回的boolean决定是否执行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIf</span>(<span class="string">"java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnlyOnSunday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on Sunday</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>参数化测试</h1>
<h2 id="ParameterizedTest"><a class="header-anchor" href="#ParameterizedTest">¶</a>@ParameterizedTest</h2>
<p>用这个注解。<br>
@ValueSource(ints = { -1, -5, -100 })可以用来传递值。</p>
<h3 id="1-MethodSource"><a class="header-anchor" href="#1-MethodSource">¶</a>1 @MethodSource</h3>
<p>它允许我们编写一个同名的静态方法来提供测试参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title">testCapitalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">"abc"</span>, <span class="string">"Abc"</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">"APPLE"</span>, <span class="string">"Apple"</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">"gooD"</span>, <span class="string">"Good"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-CsvSource"><a class="header-anchor" href="#2-CsvSource">¶</a>2 @CsvSource</h3>
<p>一个字符串表示一行参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource</span>(&#123; <span class="string">"abc, Abc"</span>, <span class="string">"APPLE, Apple"</span>, <span class="string">"gooD, Good"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以把测试数据提到一个独立的CSV文件中，然后标注上@CsvFileSource：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource</span>(resources = &#123; <span class="string">"/test-capitalize.csv"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java核心技术卷一》读书笔记一</title>
    <url>/2020/03/13/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80%E3%80%8B/</url>
    <content><![CDATA[<pre><code>随意记录一下有趣的。
</code></pre>
<a id="more"></a>
<h2 id="第三章"><a class="header-anchor" href="#第三章">¶</a>第三章</h2>
<ol>
<li>格式化创建字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String formatStr = String.format(<span class="string">"Hello, %s. Next year, you'll be %d"</span>, name, age);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>do…while和while<br>
do…while是先执行再循环，块中的语句会至少执行一次。</li>
<li>循环中，用浮点数作为判断语句<br>
可能永远不会结束，因为一些浮点数无法精确的用二进制表示。</li>
<li>三元操作符<br>
b ? x:y b成立，返回x；不成立返回y。</li>
<li>取余<br>
x % 3 == 0</li>
<li>整数加法溢出<br>
int的最大正整数为2147483647，加1则变成-2147483648，加2则为-2147483647。</li>
<li>自增，自减运算符<br>
x= <ins>x*2；是先自增再乘以2，x= x</ins>*2； 是先算出新的x值，再自增。</li>
</ol>
<h2 id="第四章"><a class="header-anchor" href="#第四章">¶</a>第四章</h2>
<ol>
<li>对象存储在堆中，对象变量其实是对象的对象指针，当一个对象包含另一个对象的变量时，实际上它只是包含另一个对象的指针。要进行对象的深拷贝，必须用clone方法。</li>
<li>var只能用在方法中的局部变量，还有不对数值类型使用var，不然赋值很麻烦：0,0.1f,0L.</li>
<li>访问器方法不要返回可变对象的引用，因为外界创建的引用跟类内部的引用是同一个对象，那么这个对象的更改器方法就可以改变类内对象的private状态，所以，应该先对它进行克隆，再进行返回。<br>
Java的参数传递是按值传递，对象引用到方法中，实际是方法获得了对象引用的副本，通过这个副本去改变所引用的对象的状态是可行的。但是如果改变对象引用的副本，是对对象本身没有任何影响。对象是不可变的，即使改变了状态，也是创建了一个新的对象，再更新到所有引用到这个对象的引用上。</li>
<li>static：静态字段和方法是属于类的，又为类字段。不会使用任何this参数，不会创建任何类对象，所以静态方法是不可以访问对象字段的，但是可以访问静态字段。使用时用类名引用。</li>
<li>final：为常量，构造函数之后即创建，永不改变，公共字段不鼓励，但是公共常量是可取的。</li>
<li>main方法，不对任何对象进行操作，可以在运行时构建并执行程序所需要的对象，可在类中加入用于单元测试。而其他类作为主main时，这个类的main将不再执行。</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>《Java核心技术》</tag>
      </tags>
  </entry>
  <entry>
    <title>Java时间</title>
    <url>/2020/03/13/Java%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<pre><code>如果以GMT或者UTC作为时区，这不两算夏令时，无论日期是多少，时间都是标准的。
如果以国家／城市表示，例如America／NewYork，虽然纽约也在西五区，但是，因为夏令时的存在，在不同的日期，GMT时间和纽约时间可能是不一样的。

在计算机中，通常使用Locale表示一个国家或地区的日期、时间、数字、货币等格式。Locale由语言_国家的字母缩写构成，例如，zh_CN表示中文+中国，en_US表示英文+美国。语言使用小写，国家使用大写。
</code></pre>
<a id="more"></a>
<h1>Date和Calendar</h1>
<p>Epoch Time是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数.<br>
Epoch Time又称为时间戳，在不同的编程语言中，会有几种存储方式：</p>
<ul>
<li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li>
<li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li>
<li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。<br>
在Java程序中，时间戳通常是用long表示的毫秒数:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t = <span class="number">1574208900123L</span>;</span><br></pre></td></tr></table></figure>
<p>要获取当前时间戳，可以使用System.currentTimeMillis()，这是Java程序获取时间戳最常用的方法。</p>
<h3 id="标准库API"><a class="header-anchor" href="#标准库API">¶</a>标准库API</h3>
<p>Java标准库有两套处理日期和时间的API：</p>
<ul>
<li>一套定义在java.util这个包里面，主要包括Date、Calendar和TimeZone这几个类；</li>
<li>一套新的API是在Java 8引入的，定义在java.time这个包里面，主要包括LocalDateTime、ZonedDateTime、ZoneId等。</li>
</ul>
<h3 id="Date"><a class="header-anchor" href="#Date">¶</a>Date</h3>
<p>观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span>, <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">long</span> fastTime;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date.getYear() + <span class="number">1900</span>); <span class="comment">// 必须加上1900</span></span><br><span class="line">        System.out.println(date.getMonth() + <span class="number">1</span>); <span class="comment">// 0~11，必须加上1</span></span><br><span class="line">        System.out.println(date.getDate()); <span class="comment">// 1~31，不能加1</span></span><br><span class="line">        <span class="comment">// 转换为String:</span></span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">        <span class="comment">// 转换为GMT时区:</span></span><br><span class="line">        System.out.println(date.toGMTString());</span><br><span class="line">        <span class="comment">// 转换为本地时区:</span></span><br><span class="line">        System.out.println(date.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getYear()要加上1900，getMonth()要加1.<br>
可以使用SimpleDateFormat对一个Date进行转换。它用预定义的字符串表示格式化：</p>
<ul>
<li>yyyy：年</li>
<li>MM：月</li>
<li>dd: 日</li>
<li>HH: 小时</li>
<li>mm: 分钟</li>
<li>ss: 秒</li>
<li>E: 周<br>
字母越长，输出越长。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Date对象有几个严重的问题：它不能转换时区，除了toGMTString()可以按GMT+0:00输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</p>
<h1>Calendar</h1>
<p>它和Date比，主要多了一个可以做简单的日期和时间运算的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">int</span> y = c.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> + c.get(Calendar.MONTH);</span><br><span class="line">        <span class="keyword">int</span> d = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="keyword">int</span> w = c.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="keyword">int</span> hh = c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">int</span> mm = c.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> ss = c.get(Calendar.SECOND);</span><br><span class="line">        <span class="keyword">int</span> ms = c.get(Calendar.MILLISECOND);</span><br><span class="line">        System.out.println(y + <span class="string">"-"</span> + m + <span class="string">"-"</span> + d + <span class="string">" "</span> + w + <span class="string">" "</span> + hh + <span class="string">":"</span> + mm + <span class="string">":"</span> + ss + <span class="string">"."</span> + ms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到Calendar获取年月日这些信息变成了get(int field)，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，1~7分别表示周日，周一，……，周六。<br>
Calendar只有一种方式获取，即Calendar.getInstance()，而且一获取到就是当前时间。<br>
如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置2019年:</span></span><br><span class="line">        c.set(Calendar.YEAR, <span class="number">2019</span>);</span><br><span class="line">        <span class="comment">// 设置9月:注意8表示9月:</span></span><br><span class="line">        c.set(Calendar.MONTH, <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 设置2日:</span></span><br><span class="line">        c.set(Calendar.DATE, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置时间:</span></span><br><span class="line">        c.set(Calendar.HOUR_OF_DAY, <span class="number">21</span>);</span><br><span class="line">        c.set(Calendar.MINUTE, <span class="number">22</span>);</span><br><span class="line">        c.set(Calendar.SECOND, <span class="number">23</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-09-02 21:22:23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用Calendar.getTime()可以将一个Calendar对象转换成Date对象，然后就可以用SimpleDateFormat进行格式化了。</p>
<h4 id="Timezone"><a class="header-anchor" href="#Timezone">¶</a>Timezone</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置为北京时区:</span></span><br><span class="line">        c.setTimeZone(TimeZone.getTimeZone(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        sdf.setTimeZone(TimeZone.getTimeZone(<span class="string">"America/New_York"</span>));</span><br><span class="line">        System.out.println(sdf.format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-11-19 19:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日期运算"><a class="header-anchor" href="#日期运算">¶</a>日期运算</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 加5天并减去2小时:</span></span><br><span class="line">        c.add(Calendar.DAY_OF_MONTH, <span class="number">5</span>);</span><br><span class="line">        c.add(Calendar.HOUR_OF_DAY, -<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        Date d = c.getTime();</span><br><span class="line">        System.out.println(sdf.format(d));</span><br><span class="line">        <span class="comment">// 2019-11-25 6:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>符号表</title>
    <url>/2020/03/13/%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    <content><![CDATA[<pre><code>符号表（Symbol Table）是一种存储键值对的数据结构，可以支持快速查找操作。

符号表分为有序和无序两种，有序符号表主要指支持 min()、max() 等根据键的大小关系来实现的操作。

有序符号表的键需要实现 Comparable 接口。
</code></pre>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnorderedST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Value <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderedST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Value <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Key <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Key <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Key&gt; <span class="title">keys</span><span class="params">(Key l, Key h)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-链表实现无序符号表"><a class="header-anchor" href="#1-链表实现无序符号表">¶</a>1 链表实现无序符号表</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUnorderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">UnorderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(Key key, Value value, Node next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="comment">// 如果在链表中找到节点的键等于 key 就更新这个节点的值为 value</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key)) &#123;</span><br><span class="line">                cur.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则使用头插法插入一个新节点</span></span><br><span class="line">        first = <span class="keyword">new</span> Node(key, value, first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (first.key.equals(key))</span><br><span class="line">            first = first.next;</span><br><span class="line">        Node pre = first, cur = first.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key)) &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key))</span><br><span class="line">                <span class="keyword">return</span> cur.value;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找实现有序符号表"><a class="header-anchor" href="#二分查找实现有序符号表">¶</a>二分查找实现有序符号表</h2>
<p>使用一对平行数组，一个存储键一个存储值。</p>
<p>二分查找的 rank() 方法至关重要，当键在表中时，它能够知道该键的位置；当键不在表中时，它也能知道在何处插入新键。</p>
<p>二分查找最多需要 logN+1 次比较，使用二分查找实现的符号表的查找操作所需要的时间最多是对数级别的。但是插入操作需要移动数组元素，是线性级别的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchOrderedST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">OrderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchOrderedST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(keys[m]);</span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                h = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Key&gt; <span class="title">keys</span><span class="params">(Key l, Key h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rank(l);</span><br><span class="line">        List&lt;Key&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (keys[index].compareTo(h) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(keys[index]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rank(key);</span><br><span class="line">        <span class="comment">// 如果找到已经存在的节点键为 key，就更新这个节点的值为 value</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; N &amp;&amp; keys[index].compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            values[index] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则在数组中插入新的节点，需要先将插入位置之后的元素都向后移动一个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; index; j--) &#123;</span><br><span class="line">            keys[j] = keys[j - <span class="number">1</span>];</span><br><span class="line">            values[j] = values[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[index] = key;</span><br><span class="line">        values[index] = value;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; N &amp;&amp; keys[index].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> values[index];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉查找树"><a class="header-anchor" href="#二叉查找树">¶</a>二叉查找树</h2>
<p>二叉查找树 （BST）是一颗二叉树，并且每个节点的值都大于等于其左子树中的所有节点的值而小于等于右子树的所有节点的值。<br>
BST 有一个重要性质，就是它的中序遍历结果递增排序。</p>
<h3 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">OrderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value val;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="comment">// 以该节点为根的子树节点总数</span></span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="comment">// 红黑树中使用</span></span><br><span class="line">        <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        Node(Key key, Value val, <span class="keyword">int</span> N) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.N = N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> x.N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recalculateSize</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-get"><a class="header-anchor" href="#1-get">¶</a>1 get()</h3>
<ul>
<li>如果树是空的，则查找未命中；</li>
<li>如果被查找的键和根节点的键相等，查找命中；</li>
<li>否则递归地在子树中查找：如果被查找的键较小就在左子树中查找，较大就在右子树中查找。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-put"><a class="header-anchor" href="#2-put">¶</a>2 put()</h3>
<p>当插入的键不存在于树中，需要创建一个新节点，并且更新上层节点的链接指向该节点，使得该节点正确地链接到树中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    root = put(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">        x.val = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        x.left = put(x.left, key, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x.right = put(x.right, key, value);</span><br><span class="line">    recalculateSize(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-分析"><a class="header-anchor" href="#3-分析">¶</a>3 分析</h3>
<p>二叉查找树的算法运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。<br>
最好的情况下树是完全平衡的，每条空链接和根节点的距离都为 logN。<br>
在最坏的情况下，树的高度为 N。</p>
<h3 id="4-floor"><a class="header-anchor" href="#4-floor">¶</a>4 floor()</h3>
<p>floor(key)：小于等于键的最大键</p>
<ul>
<li>如果键小于根节点的键，那么 floor(key) 一定在左子树中；</li>
<li>如果键大于根节点的键，需要先判断右子树中是否存在 floor(key)，如果存在就返回，否则根节点就是 floor(key)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = floor(root, key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> floor(x.left, key);</span><br><span class="line">    Node t = floor(x.right, key);</span><br><span class="line">    <span class="keyword">return</span> t != <span class="keyword">null</span> ? t : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-rank"><a class="header-anchor" href="#5-rank">¶</a>5 rank()</h3>
<p>rank(key) 返回 key 的排名。<br>
如果键和根节点的键相等，返回左子树的节点数；<br>
如果小于，递归计算在左子树中的排名；<br>
如果大于，递归计算在右子树中的排名，加上左子树的节点数，再加上 1（根节点）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rank(key, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> size(x.left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> rank(key, x.left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + size(x.left) + rank(key, x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-min"><a class="header-anchor" href="#6-min">¶</a>6 min()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> min(x.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-deleteMin"><a class="header-anchor" href="#7-deleteMin">¶</a>7 deleteMin()</h3>
<p>令指向最小节点的链接指向最小节点的右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x.right;</span><br><span class="line">    x.left = deleteMin(x.left);</span><br><span class="line">    recalculateSize(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-delete"><a class="header-anchor" href="#8-delete">¶</a>8 delete()</h3>
<p>如果待删除的节点只有一个子树， 那么只需要让指向待删除节点的链接指向唯一的子树即可；<br>
否则，让右子树的最小节点替换该节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    root = delete(root, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        x.left = delete(x.left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        x.right = delete(x.right, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x.left;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x.right;</span><br><span class="line">        Node t = x;</span><br><span class="line">        x = min(t.right);</span><br><span class="line">        x.right = deleteMin(t.right);</span><br><span class="line">        x.left = t.left;</span><br><span class="line">    &#125;</span><br><span class="line">    recalculateSize(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-keys"><a class="header-anchor" href="#9-keys">¶</a>9 keys()</h3>
<p>利用二叉查找树中序遍历的结果为递增的特点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Key&gt; <span class="title">keys</span><span class="params">(Key l, Key h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys(root, l, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Key&gt; <span class="title">keys</span><span class="params">(Node x, Key l, Key h)</span> </span>&#123;</span><br><span class="line">    List&lt;Key&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    <span class="keyword">int</span> cmpL = l.compareTo(x.key);</span><br><span class="line">    <span class="keyword">int</span> cmpH = h.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmpL &lt; <span class="number">0</span>)</span><br><span class="line">        list.addAll(keys(x.left, l, h));</span><br><span class="line">    <span class="keyword">if</span> (cmpL &lt;= <span class="number">0</span> &amp;&amp; cmpH &gt;= <span class="number">0</span>)</span><br><span class="line">        list.add(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmpH &gt; <span class="number">0</span>)</span><br><span class="line">        list.addAll(keys(x.right, l, h));</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-分析"><a class="header-anchor" href="#10-分析">¶</a>10 分析</h3>
<p>二叉查找树所有操作在最坏的情况下所需要的时间都和树的高度成正比。</p>
<h2 id="2-3查找树"><a class="header-anchor" href="#2-3查找树">¶</a>2-3查找树</h2>
<p>一棵2-3查找树或为一颗空树，或由以下节点组成：<br>
2-节点：含有一个键和两条链接，左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的键都大于该节点。<br>
3-节点：含有两个键和三条链接，左链接指向的2-3树中的键都小于该节点，中链接指向的2-3树中的键都位于该节点的两个键之间，右链接指向的2-3树中的键都大于该节点。</p>
<h3 id="1-插入操作"><a class="header-anchor" href="#1-插入操作">¶</a>1 插入操作</h3>
<p>插入操作和 BST 的插入操作有很大区别，BST 的插入操作是先进行一次未命中的查找，然后再将节点插入到对应的空链接上。但是 2-3 查找树如果也这么做的话，那么就会破坏了平衡性。它是将新节点插入到叶子节点上。</p>
<p>根据叶子节点的类型不同，有不同的处理方式：</p>
<ul>
<li>如果插入到 2- 节点上，那么直接将新节点和原来的节点组成 3- 节点即可。</li>
<li>如果是插入到 3- 节点上，就会产生一个临时 4- 节点时，需要将 4- 节点分裂成 3 个 2- 节点，并将中间的 2- 节点移到上层节点中。如果上移操作继续产生临时 4- 节点则一直进行分裂上移，直到不存在临时 4- 节点。</li>
</ul>
<h3 id="2-性质"><a class="header-anchor" href="#2-性质">¶</a>2 性质</h3>
<p>2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性。</p>
<p>2-3 查找树的查找和插入操作复杂度和插入顺序无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个，含有 10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作。</p>
<h1>红黑树</h1>
<p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。<br>
所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以很多结构包括map底层实现都是使用的红黑树。</p>
<h3 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h3>
<ol>
<li>根结点必为黑色</li>
<li>相连的不能同为红色</li>
<li>每个红色节点的子节点必为黑色，叶子节点必为黑色（Null）。</li>
<li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等</li>
</ol>
<h3 id="变换操作"><a class="header-anchor" href="#变换操作">¶</a>变换操作</h3>
<ol>
<li>变换颜色</li>
<li>左旋：右子变父，右子节点的左子树变父的右子树。</li>
<li>右旋：左子变父，左子节点的右子树变父的左子树。</li>
</ol>
<h3 id="变换规则"><a class="header-anchor" href="#变换规则">¶</a>变换规则</h3>
<p>所有插入的点默认红色。</p>
<ol>
<li>插入节点的父节点和叔叔节点为红色：<br>
将父叔变为黑色，将爷爷节点设为红色。</li>
<li>插入节点的父节点为红色，叔叔节点为黑色：
<ol>
<li>当前节点为右子树：<br>
则左旋：以父节点</li>
<li>当前节点为左子树：<br>
则右旋：父变黑，爷爷变红，以爷爷节点右旋。</li>
</ol>
</li>
</ol>
<h1>散列表，哈希表（hash table）</h1>
<p>访问和插入可以在常数时间内实现。<br>
由于无法通过散列值知道键的大小关系，因此散列表无法实现有序性操作。</p>
<h3 id="1-哈希函数"><a class="header-anchor" href="#1-哈希函数">¶</a>1 哈希函数</h3>
<p>对于一个大小为 M 的散列表，散列函数能够把任意键转换为 [0, M-1] 内的正整数，该正整数即为 hash 值。</p>
<p>散列表存在冲突，也就是两个不同的键可能有相同的 hash 值。</p>
<p>散列函数应该满足以下三个条件：</p>
<p>一致性：相等的键应当有相等的 hash 值，两个键相等表示调用 equals() 返回的值相等。<br>
高效性：计算应当简便，有必要的话可以把 hash 值缓存起来，在调用 hash 函数时直接返回。<br>
均匀性：所有键的 hash 值应当均匀地分布到 [0, M-1] 之间，如果不能满足这个条件，有可能产生很多冲突，从而导致散列表的性能下降。<br>
除留余数法可以将整数散列到 [0, M-1] 之间，例如一个正整数 k，计算 k%M 既可得到一个 [0, M-1] 之间的 hash 值。注意 M 最好是一个素数，否则无法利用键包含的所有信息。例如 M 为 10k，那么只能利用键的后 k 位。</p>
<p>对于其它数，可以将其转换成整数的形式，然后利用除留余数法。例如对于浮点数，可以将其的二进制形式转换成整数。</p>
<p>对于多部分组合的类型，每个部分都需要计算 hash 值，这些 hash 值都具有同等重要的地位。为了达到这个目的，可以将该类型看成 R 进制的整数，每个部分都具有不同的权值。</p>
<p>例如，字符串的散列函数实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    hash = (R * hash + s.charAt(i)) % M;</span><br></pre></td></tr></table></figure>
<p>再比如，拥有多个成员的自定义类的哈希函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (((day * R + month) % M) * R + year) % M;</span><br></pre></td></tr></table></figure>
<p>R 通常取 31。</p>
<h5 id="Java内"><a class="header-anchor" href="#Java内">¶</a>Java内</h5>
<p>Java 中的 hashCode() 实现了哈希函数，但是默认使用对象的内存地址值。在使用 hashCode() 时，应当结合除留余数法来使用。因为内存地址是 32 位整数，我们只需要 31 位的非负整数，因此应当屏蔽符号位之后再使用除留余数法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (x.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br></pre></td></tr></table></figure>
<p>使用 Java 的 HashMap 等自带的哈希表实现时，只需要去实现 Key 类型的 hashCode() 函数即可。Java 规定 hashCode() 能够将键均匀分布于所有的 32 位整数，Java 中的 String、Integer 等对象的 hashCode() 都能实现这一点。以下展示了自定义类型如何实现 hashCode()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String who;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date when;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(String who, Date when, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.who = who;</span><br><span class="line">        <span class="keyword">this</span>.when = when;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">17</span>;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">31</span>;</span><br><span class="line">        hash = R * hash + who.hashCode();</span><br><span class="line">        hash = R * hash + when.hashCode();</span><br><span class="line">        hash = R * hash + ((Double) amount).hashCode();</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-拉链法"><a class="header-anchor" href="#2-拉链法">¶</a>2 拉链法</h3>
<p>拉链法使用链表来存储 hash 值相同的键，从而解决冲突。</p>
<p>查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找。</p>
<p>对于 N 个键，M 条链表 (N&gt;M)，如果哈希函数能够满足均匀性的条件，每条链表的大小趋向于 N/M，因此未命中的查找和插入操作所需要的比较次数为 ~N/M。</p>
<h3 id="3-线性探测法"><a class="header-anchor" href="#3-线性探测法">¶</a>3 线性探测法</h3>
<p>线性探测法使用空位来解决冲突，当冲突发生时，向前探测一个空位来存储冲突的键。</p>
<p>使用线性探测法，数组的大小 M 应当大于键的个数 N（M&gt;N)。</p>
<h1>小结</h1>
<ol>
<li>Symbol table算法比较：<br>
算法|插入|查找|是否有序<br>
|-:|:-:|:-:|:-|<br>
链表实现的无序符号表|N|N|yes<br>
二分查找实现的有序符号表|N|logN	yes<br>
二叉查找树|logN|logN|yes<br>
2-3 查找树|logN|logN|yes<br>
拉链法实现的散列表|N/M|N/M|no<br>
线性探测法实现的散列表|1|1|no</li>
</ol>
<p>应当优先考虑散列表，当需要有序性操作时使用红黑树。<br>
2. Java的实现<br>
java.util.TreeMap：红黑树<br>
java.util.HashMap：拉链法的散列表<br>
3. 稀疏向量的乘法<br>
当向量为稀疏向量时，可以使用符号表来存储向量中的非 0 索引和值，使得乘法运算只需要对那些非 0 元素进行即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Double&gt; hashMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SparseVector</span><span class="params">(<span class="keyword">double</span>[] vector)</span> </span>&#123;</span><br><span class="line">        hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (vector[i] != <span class="number">0</span>)</span><br><span class="line">                hashMap.put(i, vector[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashMap.getOrDefault(i, <span class="number">0.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(SparseVector other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : hashMap.keySet())</span><br><span class="line">            sum += <span class="keyword">this</span>.get(i) * other.get(i);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2020/03/12/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<pre><code>栈和队列的算法实现。
</code></pre>
<a id="more"></a>
<h1>栈</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyStack&lt;Item&gt; <span class="title">push</span><span class="params">(Item item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Item <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-数组实现"><a class="header-anchor" href="#1-数组实现">¶</a>1 数组实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈元素数组，只能通过转型来创建泛型数组</span></span><br><span class="line">    <span class="keyword">private</span> Item[] a = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyStack&lt;Item&gt; <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        a[N++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Item item = a[--N];</span><br><span class="line"></span><br><span class="line">        check();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免对象游离</span></span><br><span class="line">        a[N] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N &gt;= a.length) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * a.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N &lt;= a.length / <span class="number">4</span>) &#123;</span><br><span class="line">            resize(a.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整数组大小，使得栈具有伸缩性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Item[] tmp = (Item[]) <span class="keyword">new</span> Object[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            tmp[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回逆序遍历的迭代器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Item&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = N;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[--i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-链表实现"><a class="header-anchor" href="#2-链表实现">¶</a>2 链表实现</h2>
<p>需要使用链表的头插法来实现，因为头插法中最后压入栈的元素在链表的开头，它的 next 指针指向前一个压入栈的元素，在弹出元素时就可以通过 next 指针遍历到前一个压入栈的元素从而让这个元素成为新的栈顶元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node top = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyStack&lt;Item&gt; <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node newTop = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">        newTop.item = item;</span><br><span class="line">        newTop.next = top;</span><br><span class="line"></span><br><span class="line">        top = newTop;</span><br><span class="line"></span><br><span class="line">        N++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Item item = top.item;</span><br><span class="line"></span><br><span class="line">        top = top.next;</span><br><span class="line">        N--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Item&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Node cur = top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Item item = cur.item;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a class="header-anchor" href="#队列">¶</a>队列</h2>
<p>下面是队列的链表实现，需要维护 first 和 last 节点指针，分别指向队首和队尾。</p>
<p>这里需要考虑 first 和 last 指针哪个作为链表的开头。因为出队列操作需要让队首元素的下一个元素成为队首，所以需要容易获取下一个元素，而链表的头部节点的 next 指针指向下一个元素，因此可以让 first 指针链表的开头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyQueue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyQueue&lt;Item&gt; <span class="title">add</span><span class="params">(Item item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Item <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyQueue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyQueue&lt;Item&gt; <span class="title">add</span><span class="params">(Item item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Item <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListQueue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyQueue</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyQueue&lt;Item&gt; <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node();</span><br><span class="line">        newNode.item = item;</span><br><span class="line">        newNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            last = newNode;</span><br><span class="line">            first = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = newNode;</span><br><span class="line">            last = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        N++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = first;</span><br><span class="line">        first = first.next;</span><br><span class="line">        N--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Item&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            Node cur = first;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Item item = cur.item;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/03/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<pre><code>用来解决动态连通性的问题，能动态连接两个点，能判断两个点是否连通。
</code></pre>
<a id="more"></a>
<h3 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h3>
<p>UF(int N)     构建一个大小为N的并查集<br>
void union(int p, int q)     连接 p 和 q 节点<br>
int find(int p)     查找p节点的连通分量（根节点）<br>
boolean connected(int p, int q)     判断p，q两点是否连通</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h2>
<h3 id="Quick-find"><a class="header-anchor" href="#Quick-find">¶</a>Quick find</h3>
<p>快速查找，需要保证同一连通分量的所有节点的 id 值相等，就可以通过判断两个节点的 id 值是否相等从而判断其连通性。<br>
但是 union 操作代价却很高，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值。</p>
<h3 id="Quick-union"><a class="header-anchor" href="#Quick-union">¶</a>Quick union</h3>
<p>可以快速进行 union 操作，只需要修改一个节点的 id 值即可。<br>
但是 find 操作开销很大，因为同一个连通分量的节点 id 值不同，id 值只是用来指向另一个节点。因此需要一直向上查找操作，直到找到最上层的节点。</p>
<h3 id="加权-Quick-Union"><a class="header-anchor" href="#加权-Quick-Union">¶</a>加权 Quick Union</h3>
<p>为了解决 quick-union 的树通常会很高的问题，加权 quick-union 在 union 操作时会让较小的树连接较大的树上面。<br>
理论研究证明，加权 quick-union 算法构造的树深度最多不超过 logN。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedQuickUnionUF</span> <span class="keyword">extends</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存节点的数量信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightedQuickUnionUF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(N);</span><br><span class="line">        <span class="keyword">this</span>.sz = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = find(p);</span><br><span class="line">        <span class="keyword">int</span> j = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sz[i] &lt; sz[j]) &#123;</span><br><span class="line">            id[i] = j;</span><br><span class="line">            sz[j] += sz[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            sz[i] += sz[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路径压缩的加权Quick-Union"><a class="header-anchor" href="#路径压缩的加权Quick-Union">¶</a>路径压缩的加权Quick Union</h3>
<p>在检查节点的同时将它们直接链接到根节点，只需要在 find 中添加一个循环即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(temp != id[p])&#123;</span><br><span class="line"><span class="keyword">int</span> tempId = id[temp];</span><br><span class="line">id[temp] = id[p];</span><br><span class="line">temp = tempId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>性能比较</h1>
<table>
<thead>
<tr>
<th style="text-align:right">算法</th>
<th style="text-align:center">union</th>
<th style="text-align:center">find</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Quick Find</td>
<td style="text-align:center">N</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">Quick Union</td>
<td style="text-align:center">树高｜树高</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">加权Quick Union</td>
<td style="text-align:center">logN</td>
<td style="text-align:center">logN</td>
</tr>
<tr>
<td style="text-align:right">路径压缩的加权Quick Union</td>
<td style="text-align:center">常数</td>
<td style="text-align:center">常数</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2020/03/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<pre><code>总结一波基础算法再刷题把
</code></pre>
<a id="more"></a>
<h1>约定</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Comparable接口，有compareTo()方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(T v, T w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>菜菜排序组合</h1>
<h1>选择排序</h1>
<p>选择最小的数与第一个元素交换，再从剩下的选最小的数与第二个元素交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(nums[j], nums[min])) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>冒泡排序</h1>
<p>左右不断交换逆序的元素，每一轮排序都让一个元素排到最右侧。<br>
在一轮排序中，如果没有发生交换说明数组已有序，可以跳出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; !isSorted; i--) &#123;</span><br><span class="line">            isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(nums[j + <span class="number">1</span>], nums[j])) &#123;</span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                    swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isSorted)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>插入排序</h1>
<p>每次都将当前元素插入左侧已排好序的数组中，每次都与相邻的元素交换，每趟逆序数量减1。其交换的次数取决与逆序的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(nums[j], nums[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">                swap(nums, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>希尔排序</h1>
<p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">            h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(nums[j], nums[j - h]); j -= h) &#123;</span><br><span class="line">                    swap(nums, j, j - h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>归并排序</h1>
<p>分成多个子数组，然后合并起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> T[] aux;</span><br><span class="line"><span class="comment">//merge方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(T[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> middle, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> low2 = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low; k&lt;= high; ++k)&#123;</span><br><span class="line">            aux[k] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low; k&lt;= high; ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;middle)&#123;</span><br><span class="line">                nums[k] == aux[low2++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(low2 &gt; high)&#123;</span><br><span class="line">                nums[k] == aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i].compareTo(aux[j]) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                nums[k] == aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[k] == aux[low2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自顶而下，递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Up2DownMergeSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span></span>&#123;</span><br><span class="line">        aux = (T[]) <span class="keyword">new</span> Comparable[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = l +(h-l)&gt;&gt;<span class="number">1</span>;    </span><br><span class="line">        sort(nums, l, m);</span><br><span class="line">        sort(nums,m+<span class="number">1</span>,h);</span><br><span class="line">        merge(nums, l,m,h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自下而上，动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Down2UpMergeSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        aux = (T[]) <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz+=sz)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo&lt;N-sz; lo=lo+sz+sz)&#123;</span><br><span class="line">                merge(nums, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>快速排序</h1>
<p>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= l)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">        sort(nums, l, j - <span class="number">1</span>);</span><br><span class="line">        sort(nums, j + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如此乱序数组，便可以更加优秀的将快排性能接近NlogN，而且几乎可以避免出现n2的效率情况。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Comparable&gt; list = Arrays.asList(nums);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        list.toArray(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Partition</span></span><br><span class="line"><span class="comment">取 a[l] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">    T v = nums[l];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(nums[++i], v) &amp;&amp; i != h) ;</span><br><span class="line">        <span class="keyword">while</span> (less(v, nums[--j]) &amp;&amp; j != l) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析"><a class="header-anchor" href="#性能分析">¶</a>性能分析</h3>
<p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。<br>
快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。<br>
最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p>
<h3 id="算法改进"><a class="header-anchor" href="#算法改进">¶</a>算法改进</h3>
<ol>
<li>切换到插入排序中：<br>
因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。</li>
<li>三数取中：<br>
最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。</li>
<li>三向切分：<br>
对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。<br>
三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeWayQuickSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">QuickSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= l) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lt = l, i = l + <span class="number">1</span>, gt = h;</span><br><span class="line">        T v = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = nums[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, lt++, i++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, i, gt--);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, l, lt - <span class="number">1</span>);</span><br><span class="line">        sort(nums, gt + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>基于切分的快速选择算法<br>
快速排序的 partition() 方法，会返回一个整数 j 使得 a[l…j-1] 小于等于 a[j]，且 a[j+1…h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。</li>
</ol>
<h3 id="可以利用这个特性找出数组的第-k-个元素"><a class="header-anchor" href="#可以利用这个特性找出数组的第-k-个元素">¶</a>可以利用这个特性找出数组的第 k 个元素</h3>
<p>该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+…)，直到找到第 k 个元素，这个和显然小于 2N。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">(T[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt; l) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) &#123;</span><br><span class="line">            h = j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>堆排序</h1>
<h3 id="1-堆"><a class="header-anchor" href="#1-堆">¶</a>1 堆</h3>
<p>堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗完全二叉树。</p>
<p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p>
<h3 id="2-堆的上浮下沉"><a class="header-anchor" href="#2-堆的上浮下沉">¶</a>2 堆的上浮下沉</h3>
<p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。<br>
类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">        swap(k / <span class="number">2</span>, k);</span><br><span class="line">        k = k / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>))</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-插入元素"><a class="header-anchor" href="#3-插入元素">¶</a>3 插入元素</h3>
<p>插入到数组队尾，然后上浮到合适的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable v)</span> </span>&#123;</span><br><span class="line">    heap[++N] = v;</span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除最大的元素"><a class="header-anchor" href="#4-删除最大的元素">¶</a>4 删除最大的元素</h3>
<p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T max = heap[<span class="number">1</span>];</span><br><span class="line">    swap(<span class="number">1</span>, N--);</span><br><span class="line">    heap[N + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-堆排序"><a class="header-anchor" href="#5-堆排序">¶</a>5 堆排序</h3>
<p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p>
<h4 id="5-1-构建堆"><a class="header-anchor" href="#5-1-构建堆">¶</a>5.1 构建堆</h4>
<p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。</p>
<h4 id="5-2-交换堆顶元素与最后一个元素"><a class="header-anchor" href="#5-2-交换堆顶元素与最后一个元素">¶</a>5.2 交换堆顶元素与最后一个元素</h4>
<p>交换之后需要进行下沉操作维持堆的有序状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组第 0 个位置不能有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(nums, k, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">1</span>, N--);</span><br><span class="line">            sink(nums, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(T[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(nums, j, j + <span class="number">1</span>))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(nums, k, j))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(T[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i].compareTo(nums[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-分析"><a class="header-anchor" href="#6-分析">¶</a>6 分析</h3>
<p>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p>
<p>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p>
<p>堆排序是一种原地排序，没有利用额外的空间。</p>
<p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</p>
<h1>小结</h1>
<ol>
<li>排序算法的比较<br>
算法|稳定性|时间复杂度|空间复杂度|备注<br>
-:|:-:|:-:|:-:|:-<br>
选择排序|❌|N^2|1|<br>
冒泡排序|👌|N^2|1|<br>
插入排序|👌|N～N^2|1|时间复杂度和初始顺序有关<br>
希尔排序|❌|N的若干倍乘以递增序列的长度|1|改进版的插入排序<br>
快速排序|❌|NlogN|logN|<br>
三向切分快速排序|❌|N～NlogN|logN|适用于有大量重复主键<br>
归并排序|👌|NlogN|N|<br>
堆排序|❌|NlogN|1|无法利用局部性原理<br>
快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</li>
</ol>
<p>使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p>
<ol start="2">
<li>Java的排序算法实现<br>
Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaIO</title>
    <url>/2020/03/10/JavaIO/</url>
    <content><![CDATA[<pre><code>I：input把数据从外部读入内存
O：output把数据从内存输出到外部
</code></pre>
<a id="more"></a>
<h1>File对象</h1>
<p>构建File对象，需要传入文件路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">"/usr/bin/javac"</span>);</span><br><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">"./sub/javac"</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">"../sub/javac"</span>); <span class="comment">// 绝对路径是C:\sub\javac</span></span><br></pre></td></tr></table></figure>
<p>.当前路径，…上级目录。<br>
File对象有3种形式表示的路径，一种是getPath()，返回构造方法传入的路径，一种是getAbsolutePath()，返回绝对路径，一种是getCanonicalPath，它和绝对路径类似，但是返回的是规范路径。</p>
<h3 id="文件和目录"><a class="header-anchor" href="#文件和目录">¶</a>文件和目录</h3>
<p>File对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。</p>
<p>例如，调用.isFile()，判断该File对象是否是一个已存在的文件，调用.isDirectory()，判断该File对象是否是一个已存在的目录。</p>
<p>用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p>
<ul>
<li>boolean canRead()：是否可读；</li>
<li>boolean canWrite()：是否可写；</li>
<li>boolean canExecute()：是否可执行；</li>
<li>long length()：文件字节大小。<br>
对目录而言，是否可执行表示能否列出它包含的文件和子目录。</li>
</ul>
<h3 id="创建和删除文件"><a class="header-anchor" href="#创建和删除文件">¶</a>创建和删除文件</h3>
<p>当File对象表示一个文件时，可以通过createNewFile()创建一个新文件，用delete()删除该文件。</p>
<p>有些时候，程序需要读写一些临时文件，File对象提供了createTempFile()来创建一个临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = File.createTempFile(<span class="string">"tmp-"</span>, <span class="string">".txt"</span>); <span class="comment">// 提供临时文件的前缀和后缀</span></span><br><span class="line">        f.deleteOnExit(); <span class="comment">// JVM退出时自动删除</span></span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历文件和目录"><a class="header-anchor" href="#遍历文件和目录">¶</a>遍历文件和目录</h3>
<p>当File对象表示一个目录时，可以使用list()和listFiles()列出目录下的文件和子目录名。listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"C:\\Windows"</span>);</span><br><span class="line">        File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">        printFiles(fs1);</span><br><span class="line">        File[] fs2 = f.listFiles(<span class="keyword">new</span> FilenameFilter() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">".exe"</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printFiles(fs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(File[] files)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========="</span>);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=========="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p>
<ul>
<li>boolean mkdir()：创建当前File对象表示的目录；</li>
<li>boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li>
<li>boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li>
</ul>
<h1>Path</h1>
<p>Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path p1 = Paths.get(<span class="string">"."</span>, <span class="string">"project"</span>, <span class="string">"study"</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        Path p2 = p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        Path p3 = p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        File f = p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">".."</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">"  "</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要对目录进行复杂的拼接、遍历等操作，使用Path对象更方便。</p>
<h1>InputStream</h1>
<p>InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。<br>
FileInputStream是InputStream的一个子类。顾名思义，FileInputStream就是从文件流中读取数据。<br>
一个潜在的问题：如果读取过程中发生了IO错误，InputStream就没法正确地关闭，资源也就没法及时释放。<br>
因此，我们需要用try … finally来保证InputStream在无论是否发生IO错误的时候都能够正确地关闭。<br>
用try … finally来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的try(resource)的语法，只需要编写try语句，让编译器自动为我们关闭资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，编译器并不会特别地为InputStream加上自动关闭。编译器只看try(resource = …)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上finally语句并调用close()方法。InputStream和OutputStream都实现了这个接口，因此，都可以用在try(resource)中。</p>
<h3 id="缓冲"><a class="header-anchor" href="#缓冲">¶</a>缓冲</h3>
<p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。InputStream提供了两个重载方法来支持读取多个字节：</p>
<ul>
<li>int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数</li>
<li>int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数<br>
利用上述方法一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。<br>
利用缓冲区一次读取多个字节的代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" bytes."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞"><a class="header-anchor" href="#阻塞">¶</a>阻塞</h3>
<p>在调用InputStream的read()方法读取数据时，我们说read()方法是阻塞（Blocking）的。必须等待read()方法返回才能执行下一行代码。</p>
<h3 id="InputStream实现类"><a class="header-anchor" href="#InputStream实现类">¶</a>InputStream实现类</h3>
<p>ByteArrayInputStream可以在内存中模拟一个InputStream。实际上是把一个byte[]数组在内存中变成一个InputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个InputStream。<br>
我们想从文件中读取所有字节，并转换成char然后拼成一个字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = readAsString(input);</span><br></pre></td></tr></table></figure>
<h1>OutputStream</h1>
<p>OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b)，签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b &amp; 0xff）。</p>
<p>和InputStream类似，OutputStream也提供了close()方法关闭输出流，以便释放系统资源。要特别注意：OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。</p>
<p>为什么要有flush()？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。</p>
<p>通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。</p>
<p>但是，在某些情况下，我们必须手动调用flush()方法。举个栗子：</p>
<p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过OutputStream的write()方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？</p>
<p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p>
<p>解决办法就是每输入一句话后，立刻调用flush()，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p>
<p>实际上，InputStream也有缓冲区。例如，从FileInputStream读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用read()，则会触发操作系统的下一次读取并再次填满缓冲区。</p>
<h3 id="FileOutputStream"><a class="header-anchor" href="#FileOutputStream">¶</a>FileOutputStream</h3>
<p>和InputStream一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用try(resource)来保证OutputStream在无论是否发生IO错误的时候都能够正确地关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"out/readme.txt"</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞-v2"><a class="header-anchor" href="#阻塞-v2">¶</a>阻塞</h3>
<p>和InputStream一样，OutputStream的write()方法也是阻塞的。</p>
<h3 id="OutputStream实现类"><a class="header-anchor" href="#OutputStream实现类">¶</a>OutputStream实现类</h3>
<p>ByteArrayOutputStream可以在内存中模拟一个OutputStream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br></pre></td></tr></table></figure>
<h1>Filter模式</h1>
<p>Java的IO标准库使用Filter模式为InputStream和OutputStream增加功能：</p>
<ul>
<li>可以把一个InputStream和任意个FilterInputStream组合；</li>
<li>可以把一个OutputStream和任意个FilterOutputStream组合。<br>
Filter模式可以在运行期动态增加功能（又称Decorator模式）。<br>
可以叠加多个FilterInputStream来提供功能。</li>
</ul>
<h1>操作zip</h1>
<p>JarInputStream是从ZipInputStream派生，它增加的主要功能是直接读取jar文件里面的MANIFEST.MF文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p>
<h2 id="读取zip包"><a class="header-anchor" href="#读取zip包">¶</a>读取zip包</h2>
<p>创建一个ZipInputStream，通常是传入一个FileInputStream作为数据源，然后，循环调用getNextEntry()，直到返回null，表示zip流结束。</p>
<p>一个ZipEntry表示一个压缩文件或目录，如果是压缩文件，我们就用read()方法不断读取，直到返回-1。</p>
<h2 id="写入zip包"><a class="header-anchor" href="#写入zip包">¶</a>写入zip包</h2>
<p>ZipOutputStream是一种FilterOutputStream，它可以直接写入内容到zip包。我们要先创建一个ZipOutputStream，通常是包装一个FileOutputStream，然后，每写入一个文件前，先调用putNextEntry()，然后用write()写入byte[]数据，写入完毕后调用closeEntry()结束这个文件的打包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipOutputStream zip = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(...))) &#123;</span><br><span class="line">    File[] files = ...</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        zip.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()));</span><br><span class="line">        zip.write(getFileDataAsBytes(file));</span><br><span class="line">        zip.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，new ZipEntry(name)传入的name要用相对路径。</p>
<h1>classpath</h1>
<p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把default.properties文件放到classpath中，就不用关心它的实际存放路径。<br>
在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件.<br>
调用getResourceAsStream()需要特别注意的一点是，如果资源文件不存在，它将返回null。因此，我们需要检查返回的InputStream是否为null，如果为null，表示资源文件在classpath中没有找到。</p>
<h1>序列化</h1>
<p>序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p>
<p>反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。</p>
<p>要能序列化，实现java.io.Serializable接口。Serializable接口没有定义任何方法，它是一个空接口，称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p>
<h3 id="序列化"><a class="header-anchor" href="#序列化">¶</a>序列化</h3>
<p>使用ObjectOutputStream。它负责把一个Java对象写入一个字节流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class="line">        <span class="comment">// 写入int:</span></span><br><span class="line">        output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">        output.writeUTF(<span class="string">"Hello"</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">        output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以写入实现了Serializable接口的Object。</p>
<h3 id="反序列化"><a class="header-anchor" href="#反序列化">¶</a>反序列化</h3>
<p>ObjectInputStream负责从一个字节流读取Java对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(...)) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = input.readInt();</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">    Double d = (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用readObject()可以直接返回一个Object对象。<br>
Java的序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。<br>
反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p>
<h3 id="安全型"><a class="header-anchor" href="#安全型">¶</a>安全型</h3>
<p>因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p>
<p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p>
<h1>Reader</h1>
<p>Reader是以字符流，即char为单位读取。<br>
这个方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。</p>
<h2 id="FileReader"><a class="header-anchor" href="#FileReader">¶</a>FileReader</h2>
<p>FileReader是Reader的一个子类，它可以打开文件并获取Reader。<br>
要避免乱码问题，我们需要在创建FileReader时指定编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>,StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<p>可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" chars."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CharArrayReader"><a class="header-anchor" href="#CharArrayReader">¶</a>CharArrayReader</h3>
<p>CharArrayReader可以在内存中模拟一个Reader，它的作用实际上是把一个char[]数组变成一个Reader，这和ByteArrayInputStream非常类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> CharArrayReader(<span class="string">"Hello"</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StringReader"><a class="header-anchor" href="#StringReader">¶</a>StringReader</h3>
<p>StringReader可以直接把String作为数据源。</p>
<h3 id="InputStreamReader"><a class="header-anchor" href="#InputStreamReader">¶</a>InputStreamReader</h3>
<p>FileReader的源码，它在内部实际上持有一个FileInputStream。Reader需要从InputStream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。<br>
InputStreamReader就是这样一个转换器，它可以把任何InputStream转换为Reader。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>), <span class="string">"UTF-8"</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Writer</h1>
<p>Writer带编码转换器的OutputStream，char转换为byte并输出。</p>
<h3 id="FileWriter"><a class="header-anchor" href="#FileWriter">¶</a>FileWriter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">'H'</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CharArrayWriter"><a class="header-anchor" href="#CharArrayWriter">¶</a>CharArrayWriter</h3>
<p>CharArrayWriter可以在内存中创建一个Writer，它的作用实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组，这和ByteArrayOutputStream非常类似。</p>
<h3 id="StringWriter"><a class="header-anchor" href="#StringWriter">¶</a>StringWriter</h3>
<p>实际上，StringWriter在内部维护了一个StringBuffer，并对外提供了Writer接口。</p>
<h3 id="OutputStreamWriter"><a class="header-anchor" href="#OutputStreamWriter">¶</a>OutputStreamWriter</h3>
<p>普通的Writer实际上是基于OutputStream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream。因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"readme.txt"</span>), <span class="string">"UTF-8"</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>PrintStream和PrintWriter</h1>
<p>PrintStream是一种FilterOutputStream，它在OutputStream的接口上，额外提供了一些写入各种数据类型的方法：<br>
println()方法，它会自动加上换行符。<br>
System.out是系统默认提供的PrintStream，表示标准输出。<br>
System.err是系统默认提供的标准错误输出。<br>
它还有一个额外的优点，就是不会抛出IOException。</p>
<h3 id="PrintWriter"><a class="header-anchor" href="#PrintWriter">¶</a>PrintWriter</h3>
<p>PrintStream最终输出的总是byte数据，而PrintWriter则是扩展了Writer接口，它的print()/println()方法最终输出的是char数据。两者的使用方法几乎是一模一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</span><br><span class="line">        StringWriter buffer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter pw = <span class="keyword">new</span> PrintWriter(buffer)) &#123;</span><br><span class="line">            pw.println(<span class="string">"Hello"</span>);</span><br><span class="line">            pw.println(<span class="number">12345</span>);</span><br><span class="line">            pw.println(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>两个栈实现队列｜《剑指offer》</title>
    <url>/2020/03/10/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题解：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
</code></pre>
<a id="more"></a>
<h1>题解：</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的下一个结点｜《剑指offer》</title>
    <url>/2020/03/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
</code></pre>
<a id="more"></a>
<h1>题解：</h1>
<ol>
<li>若该节点存在右子树：则下一个节点为右子树最左子节点（如图节点 B ）</li>
<li>若该节点不存在右子树：这时分两种情况：</li>
</ol>
<ul>
<li>该节点为父节点的左子节点，则下一个节点为其父节点（如图节点 D ）</li>
<li>该节点为父节点的右子节点，则沿着父节点向上遍历，知道找到一个节点的父节点的左子节点为该节点，则该节点的父节点下一个节点（如图节点 I ，沿着父节点一直向上查找找到 B （ B 为其父节点的左子节点），则 B 的父节点 A 为下一个节点）。</li>
</ul>
<h1>Code</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left==pNode) <span class="keyword">return</span> pNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>重建二叉树｜《剑指offer》</title>
    <url>/2020/03/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
</code></pre>
<h1>题解一</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>||pre.length!=in.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">//找到root在中序中的位置</span></span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=in.length -<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == rootVal)&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中序中root的左边即为左子树，右边为右子树</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,rootIndex+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,rootIndex));</span><br><span class="line">        root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,rootIndex+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,rootIndex+<span class="number">1</span>,in.length));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1>题解二</h1>
<p>省内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reConBTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConBTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> preleft,<span class="keyword">int</span> preright,<span class="keyword">int</span> [] in,<span class="keyword">int</span> inleft,<span class="keyword">int</span> inright)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preleft &gt; preright || inleft&gt; inright)<span class="comment">//当到达边界条件时候返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//新建一个TreeNode</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[preleft]);</span><br><span class="line">        <span class="comment">//对中序数组进行输入边界的遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inleft; i&lt;= inright; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[preleft] == in[i])&#123;</span><br><span class="line">                <span class="comment">//重构左子树，注意边界条件</span></span><br><span class="line">                root.left = reConBTree(pre,preleft+<span class="number">1</span>,preleft+i-inleft,in,inleft,i-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//重构右子树，注意边界条件</span></span><br><span class="line">                root.right = reConBTree(pre,preleft+i+<span class="number">1</span>-inleft,preright,in,i+<span class="number">1</span>,inright);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>从尾到头打印链表｜《剑指offer》</title>
    <url>/2020/03/08/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
</code></pre>
<a id="more"></a>
<h1>题解一：递归</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.printListFromTailToHead(listNode.next);</span><br><span class="line">            arrayList.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>题解二：栈</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode=listNode.next;     </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            list.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>表示数值的字符串｜《剑指offer》</title>
    <url>/2020/03/08/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。
</code></pre>
<a id="more"></a>
<h1>解法一：常规解法 顺序扫描</h1>
<ol>
<li>12e说明e的后面必须有数字，不能有两个e</li>
<li>±5说明符号位要么出现一次在首位，要么出现一次在e的后一位，其他地方都不能有</li>
<li>12e4.3说明e的后面不能有小数，1.2.3说明不能有两个小数点</li>
<li>1a3.14说明不能有其他的非法字符，比如这里的a</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//signal表示符号，decimal表示小树点，hasE表示含有符号e</span></span><br><span class="line">        <span class="keyword">boolean</span> signal = <span class="keyword">false</span>,decimal = <span class="keyword">false</span>,hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'E'</span> || str[i] == <span class="string">'e'</span>)&#123;</span><br><span class="line">                <span class="comment">//e后面必须有数字，所以是最后一位肯定不通过</span></span><br><span class="line">                <span class="keyword">if</span>(i==str.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不能有两个e</span></span><br><span class="line">                <span class="keyword">if</span>(hasE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="comment">//不是第一次出现，那么后面能出现符合的地方只有紧贴着e的后面一位，不是则不通过</span></span><br><span class="line">                <span class="keyword">if</span>(signal &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次出现，如果不是出现在第一位，那么还是判断一下是不是出现在e的后面一位</span></span><br><span class="line">                <span class="keyword">if</span>(!signal &amp;&amp; i&gt;<span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                signal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="comment">//如果存在e并且e后面为小数则不通过</span></span><br><span class="line">                <span class="keyword">if</span>(hasE)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不能有两个小数点</span></span><br><span class="line">                <span class="keyword">if</span>(decimal)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="comment">//不是e也不是+-符号也不是小数点，那么只能是数字，不是数字就是非法的字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>解法二：正则表达式：</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        String string = String.valueOf(str);</span><br><span class="line">        <span class="keyword">return</span> string.matches(<span class="string">"[\\+\\-]?\\d*(\\.\\d+)?([eE][\\+\\-]?\\d+)?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以下对正则进行解释:</span></span><br><span class="line"><span class="comment">[\\+\\-]?            -&gt; 正或负符号出现与否</span></span><br><span class="line"><span class="comment">\\d*                 -&gt; 整数部分是否出现，如-.34 或 +3.34均符合</span></span><br><span class="line"><span class="comment">(\\.\\d+)?           -&gt; 如果出现小数点，那么小数点后面必须有数字；</span></span><br><span class="line"><span class="comment">                        否则一起不出现</span></span><br><span class="line"><span class="comment">([eE][\\+\\-]?\\d+)? -&gt; 如果存在指数部分，那么e或E肯定出现，+或-可以不出现，</span></span><br><span class="line"><span class="comment">                        紧接着必须跟着整数；或者整个部分都不出现</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1>解法三: 分情况构造函数</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//先扫描大于0的位置</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = scanInteger(str);</span><br><span class="line">        <span class="comment">//判断是否有小数点，有小数点则扫描是否有整数</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; str.length &amp;&amp; str[index] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            flag = scanUnsignedInteger(str) || flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否有E｜｜e，如有则扫描</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; str.length &amp;&amp; (str[index] == <span class="string">'E'</span> || str[index] == <span class="string">'e'</span>)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            flag = flag &amp;&amp; scanInteger(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后检测是否走到尾，走到尾说明检测均通过 </span></span><br><span class="line">        <span class="keyword">return</span> flag &amp;&amp; index == str.length;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描第一位是否有 +，-，有就跳过，没有也没关系</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; str.length &amp;&amp; (str[index] == <span class="string">'+'</span> || str[index] == <span class="string">'-'</span>) )</span><br><span class="line">            index++;</span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描各位是否为整数 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = index;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length &amp;&amp; str[index] &gt;= <span class="string">'0'</span> &amp;&amp; str[index] &lt;= <span class="string">'9'</span>)</span><br><span class="line">            index++;</span><br><span class="line">        <span class="keyword">return</span> start &lt; index; <span class="comment">//是否存在整数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配｜《剑指offer》</title>
    <url>/2020/03/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<pre><code>题目：请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配
</code></pre>
<h1>题解：</h1>
<p>当模式中的第二个字符不是“*”时：<br>
1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。<br>
2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</p>
<p>而当模式中的第二个字符是“<em>”时：<br>
如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：<br>
1、模式后移2字符，相当于x</em>被忽略；<br>
2、字符串后移1字符，模式后移2字符；<br>
3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</p>
<h5 id="这里需要注意的是：Java里，要时刻检验数组是否越界。"><a class="header-anchor" href="#这里需要注意的是：Java里，要时刻检验数组是否越界。">¶</a>这里需要注意的是：Java里，要时刻检验数组是否越界。</h5>
<h1>Code：</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> strIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> patternIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pattern先到尾，匹配失败</span></span><br><span class="line">    <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位</span></span><br><span class="line">    <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//模式后移2，视为x*匹配0个字符</span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//视为模式匹配1个字符</span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配1个，再匹配str中的下一个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2020/03/07/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<pre><code>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。
</code></pre>
<a id="more"></a>
<h3 id="collection"><a class="header-anchor" href="#collection">¶</a>collection</h3>
<p>Java标准库自带的java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java.util包主要提供了以下三种类型的集合：</p>
<ul>
<li>List：一种有序列表的集合，例如，按索引排列的Student的List；</li>
<li>Set：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set；</li>
<li>Map：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student的Map。<br>
Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是List，具体的实现类有ArrayList，LinkedList等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 只能放入String类型</span></span><br></pre></td></tr></table></figure>
<p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li>Hashtable：一种线程安全的Map实现；</li>
<li>Vector：一种线程安全的List实现；</li>
<li>Stack：基于Vector实现的LIFO的栈。<br>
还有一小部分接口是遗留接口，也不应该继续使用：</li>
</ul>
<p>Enumeration<E>：已被Iterator<E>取代。</E></E></p>
<h1>List</h1>
<p>List<E>接口，可以看到几个主要的接口方法：</E></p>
<ul>
<li>在末尾添加一个元素：void add(E e)</li>
<li>在指定索引添加一个元素：void add(int index, E e)</li>
<li>删除指定索引的元素：int remove(int index)</li>
<li>删除某个元素：int remove(Object e)</li>
<li>获取指定索引的元素：E get(int index)</li>
<li>获取链表大小（包含元素的个数）：int size()<br>
但是，实现List接口并非只能通过数组（即ArrayList的实现方式）来实现，另一种LinkedList通过“链表”也实现了List接口。在LinkedList中，它的内部每个元素都指向下一个元素，但是ArrayList省内存。</li>
</ul>
<h3 id="List的特点"><a class="header-anchor" href="#List的特点">¶</a>List的特点</h3>
<ol>
<li>允许重复</li>
<li>允许添加null</li>
</ol>
<h3 id="遍历List"><a class="header-anchor" href="#遍历List">¶</a>遍历List</h3>
<p>使用迭代器Iterator来访问List。Iterator本身也是一个对象，但它是由List的实例调用iterator()方法的时候创建的。<br>
Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。<br>
Iterator对象有两个方法：boolean hasNext()判断是否有下一个元素，E next()返回下一个元素。因此，使用Iterator遍历List代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            <span class="comment">//.next()返回下一个元素</span></span><br><span class="line">            String s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>但是，Java的for each循环本身就可以帮我们使用Iterator遍历。</b></p>
<h3 id="List与Array相互转换"><a class="header-anchor" href="#List与Array相互转换">¶</a>List与Array相互转换</h3>
<p>给toArray(T[])传入一个类型相同的Array，List内部自动把元素复制到传入的Array中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        Integer[] array = list.toArray(<span class="keyword">new</span> Integer[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Integer n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种更简洁的写法是通过List接口定义的T[] toArray(IntFunction&lt;T[]&gt; generator)方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = list.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p>反过来，把Array变为List就简单多了，通过List.of(T…)方法最简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure>
<p>返回的List不一定就是ArrayList或者LinkedList，因为List只是一个接口，如果我们调用List.of()，它返回的是一个只读List。</p>
<h3 id="判断List中是否有某元素1"><a class="header-anchor" href="#判断List中是否有某元素1">¶</a>判断List中是否有某元素1</h3>
<p>List还提供了boolean contains(Object o)方法来判断List是否包含某个指定元素。此外，int indexOf(Object o)方法可以返回某个元素的索引，如果元素不存在，就返回-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">        System.out.println(list.contains(<span class="string">"C"</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">"X"</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">"C"</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">"X"</span>)); <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入new String(“C”)到list.contains()中来查看，依旧可以得到true。虽然是两个不同的实例，但是List内部判断两个元素相等不是用“==”，而是用equals()。</p>
<h3 id="编写equals"><a class="header-anchor" href="#编写equals">¶</a>编写equals()</h3>
<p>因此，如果传入的实例是自定义对象，则需要override这些方法。要正确使用List的contains()、indexOf()这些方法，放入的实例必须正确覆写equals()方法，否则，放进去的实例，查找不到。我们之所以能正常放入String、Integer这些对象，是因为Java标准库定义的这些类已经正确实现了equals()方法。</p>
<p>如何正确编写equals()方法？equals()方法要求我们必须满足以下条件：</p>
<ul>
<li>自反性（Reflexive）：对于非null的x来说，x.equals(x)必须返回true；</li>
<li>对称性（Symmetric）：对于非null的x和y来说，如果x.equals(y)为true，则y.equals(x)也必须为true；</li>
<li>传递性（Transitive）：对于非null的x、y和z来说，如果x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)也必须为true；</li>
<li>一致性（Consistent）：对于非null的x和y来说，只要x和y状态不变，则x.equals(y)总是一致地返回true或者false；</li>
<li>对null的比较：即x.equals(null)永远返回false。</li>
</ul>
<p>以person类为例：对于Person类，如果name相等，并且age相等，我们就认为两个Person实例相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">boolean</span> nameEquals = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name == <span class="keyword">null</span> &amp;&amp; p.name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="keyword">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nameEquals &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>对于引用字段name就用equals（），对于基本类型就用“==”。
如果this.name为null，那么equals()方法会报错，所以进行了判断。
</code></pre>
<p>实际上可以通过Objects.equals()静态方法简化代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Map</h1>
<p>Map这种键值（key-value）映射表的数据结构，作用就是能高效通过key快速查找value（元素）。HashMap之所以能根据key直接拿到value，原因是它内部通过空间换时间的方法，用一个大数组存储所有value，并根据key直接计算出value应该存储在哪个索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Student&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"Xiao Ming"</span>, s); <span class="comment">// 将"Xiao Ming"和Student实例映射并关联</span></span><br><span class="line">Student target = map.get(<span class="string">"Xiao Ming"</span>); <span class="comment">// 通过key查找并返回映射的Student实例</span></span><br></pre></td></tr></table></figure>
<h6 id="Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。"><a class="header-anchor" href="#Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。">¶</a>Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。</h6>
<h3 id="遍历Map"><a class="header-anchor" href="#遍历Map">¶</a>遍历Map</h3>
<p>用key遍历使用for each语句。</p>
<p>同时遍历key和value可以使用for each循环遍历Map对象的entrySet()集合，它包含每一个key-value映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"apple"</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">"pear"</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">"banana"</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">" = "</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Map和List不同的是，Map存储的是key-value的映射关系，并且，它不保证顺序。即遍历时，key的输出是随机的。</li>
</ul>
<h3 id="编写equals和hashCode"><a class="header-anchor" href="#编写equals和hashCode">¶</a>编写equals和hashCode</h3>
<ul>
<li>通过key计算索引的方式就是调用key对象的hashCode()方法，它返回一个int整数。HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value。</li>
<li>相同的key对象（使用equals()判断时返回true）必须要计算出相同的索引，否则，相同的key每次取出的value就不一定对。</li>
<li>在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。</li>
</ul>
<p>因此，正确使用Map必须保证：</p>
<ol>
<li>作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true；</li>
<li>作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范：</li>
</ol>
<ul>
<li>如果两个对象相等，则两个对象的hashCode()必须相等；</li>
<li>如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</li>
</ul>
<p>上述第一条规范是正确性，必须保证实现，否则HashMap不能正常工作。<br>
而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的hashCode()，会造成Map内部存储冲突，使存取的效率下降。</p>
<h3 id="覆写equals"><a class="header-anchor" href="#覆写equals">¶</a>覆写equals</h3>
<p>与List类似，找出字段值，引用字段用Obgects.equals()比较。</p>
<h3 id="override-hashCode"><a class="header-anchor" href="#override-hashCode">¶</a>override hashCode()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        h = <span class="number">31</span> * h + firstName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + lastName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + age;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，如果引用字段为null，将会报错NullPointerException。改用Objects.hash(…)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(firstName, lastName, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，编写equals()和hashCode()遵循的原则是：<br>
equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算；equals()中没有使用到的字段，绝不可放在hashCode()中计算。<br>
另外注意，对于放入HashMap的value对象，没有任何要求。</p>
<h3 id="延伸阅读"><a class="header-anchor" href="#延伸阅读">¶</a>延伸阅读</h3>
<ol>
<li>HashMap内部使用的数组得有多大？<br>
实际上HashMap初始化时默认的数组大小只有16，任何key，无论它的hashCode()有多大，都可以简单地通过：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = key.hashCode() &amp; <span class="number">0xf</span>; <span class="comment">// 0xf = 15</span></span><br></pre></td></tr></table></figure>
<p>把索引确定在0～15，即永远不会超出数组范围。<br>
2. 数组不够用了怎么办？<br>
添加超过一定数量的key-value时，HashMap会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。<br>
由于扩容会导致重新分布已有的key-value，所以，频繁扩容对HashMap的性能影响很大。如果我们确定要使用一个容量为10000个key-value的HashMap，更好的方式是创建HashMap时就指定容量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<p>虽然指定容量是10000，但HashMap内部的数组长度总是2n，因此，实际数组长度被初始化为比10000大的16384（214）。<br>
3. 发生哈希冲突时，怎么办？<br>
在冲突的时候，一种最简单的解决办法是用List存储hashCode()相同的key-value。显然，如果冲突的概率越大，这个List就越长，Map的get()方法效率就越低。HashMap内部通过&quot;a&quot;找到的实际上是List&lt;Entry&lt;String, Person&gt;&gt;，它还需要遍历这个List，并找到一个Entry，它的key字段是&quot;a&quot;，才能返回对应的Person实例。</p>
<h1>EnumMap</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(DayOfWeek<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        map.put(DayOfWeek.MONDAY, <span class="string">"星期一"</span>);</span><br><span class="line">        map.put(DayOfWeek.TUESDAY, <span class="string">"星期二"</span>);</span><br><span class="line">        map.put(DayOfWeek.WEDNESDAY, <span class="string">"星期三"</span>);</span><br><span class="line">        map.put(DayOfWeek.THURSDAY, <span class="string">"星期四"</span>);</span><br><span class="line">        map.put(DayOfWeek.FRIDAY, <span class="string">"星期五"</span>);</span><br><span class="line">        map.put(DayOfWeek.SATURDAY, <span class="string">"星期六"</span>);</span><br><span class="line">        map.put(DayOfWeek.SUNDAY, <span class="string">"星期日"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(DayOfWeek.MONDAY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>TreeMap</h1>
<p>还有一种Map，它在内部会对Key进行排序，这种Map就是SortedMap。注意到SortedMap是接口，它的实现类是TreeMap。<br>
使用TreeMap时，放入的Key必须实现Comparable接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。</p>
<p>如果作为Key的class没有实现Comparable接口，那么，必须在创建TreeMap时同时指定一个自定义排序算法：<br>
注意到Comparator接口要求实现一个比较方法，它负责比较传入的两个元素a和b，如果a&lt;b，则返回负数，通常是-1，如果a==b，则返回0，如果a&gt;b，则返回正数，通常是1。TreeMap内部根据比较结果对Key进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.score == p2.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另外，注意到Person类并未覆写equals()和hashCode()，因为TreeMap不使用equals()和hashCode()。</p>
<h1>Set</h1>
<p>只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。<br>
Set用于存储不重复的元素集合，它主要提供以下几个方法：</p>
<p>将元素添加进Set<E>：boolean add(E e)<br>
将元素从Set<E>删除：boolean remove(Object e)<br>
判断是否包含元素：boolean contains(Object e)<br>
因为放入Set的元素和Map的key类似，都要正确实现equals()和hashCode()方法，否则该元素无法正确地放入Set。</E></E></p>
<p>最常用的Set实现类是HashSet，实际上，HashSet仅仅是对HashMap的一个简单封装，它的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 持有一个HashMap:</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入HashMap的value:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Set接口并不保证有序，而SortedSet接口则保证元素是有序的：</p>
<p>HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口；<br>
TreeSet是有序的，因为它实现了SortedSet接口。<br>
使用TreeSet和使用TreeMap的要求一样，添加的元素必须正确实现Comparable接口，如果没有实现Comparable接口，那么创建TreeSet时必须传入一个Comparator对象。</p>
<h1>Queue</h1>
<p>FIFO(first in first out)<br>
在Java的标准库中，队列接口Queue定义了以下几个方法：</p>
<p>int size()：获取队列长度；<br>
boolean add(E)/boolean offer(E)：添加元素到队尾；<br>
E remove()/E poll()：获取队首元素并从队列中删除；<br>
E element()/E peek()：获取队首元素但并不从队列中删除。<br>
区别是函数失败时，左边会throw exception，右边会返回null或者false。</p>
<p>从上面的代码中，我们还可以发现，LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个List:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 这是一个Queue:</span></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h1>PriorityQueue</h1>
<p>它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。<br>
我们放入的顺序是&quot;apple&quot;、“pear”、“banana”，但是取出的顺序却是&quot;apple&quot;、“banana”、“pear”，这是因为从字符串的排序看，&quot;apple&quot;排在最前面，&quot;pear&quot;排在最后面。<br>
因此，放入PriorityQueue的元素，必须实现Comparable接口，PriorityQueue会根据元素的排序顺序决定出队的优先级。<br>
如果我们要放入的元素并没有实现Comparable接口怎么办？PriorityQueue允许我们提供一个Comparator对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个PriorityQueue：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> UserComparator());</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">"Bob"</span>, <span class="string">"A1"</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">"Alice"</span>, <span class="string">"A2"</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">"Boss"</span>, <span class="string">"V1"</span>));</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Boss/V1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Bob/A1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Alice/A2</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == u2.number.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class="line">            <span class="keyword">return</span> u1.number.compareTo(u2.number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == <span class="string">'V'</span>) &#123;</span><br><span class="line">            <span class="comment">// u1的号码是V开头,优先级高:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"/"</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Deque(Double Ended queue)</h1>
<table>
<thead>
<tr>
<th style="text-align:right">&lt;&gt;</th>
<th style="text-align:center">Queue</th>
<th style="text-align:left">Deque</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">添加元素到队尾</td>
<td style="text-align:center">add(E e) / offer(E e)</td>
<td style="text-align:left">addLast(E e) / offerLast(E e)</td>
</tr>
<tr>
<td style="text-align:right">取队首元素并删除</td>
<td style="text-align:center">E remove() / E poll()</td>
<td style="text-align:left">E removeFirst() / E pollFirst()</td>
</tr>
<tr>
<td style="text-align:right">取队首元素但不删除</td>
<td style="text-align:center">E element() / E peek()</td>
<td style="text-align:left">E getFirst() / E peekFirst()</td>
</tr>
<tr>
<td style="text-align:right">添加元素到队首</td>
<td style="text-align:center">无</td>
<td style="text-align:left">addFirst(E e) / offerFirst(E e)</td>
</tr>
<tr>
<td style="text-align:right">取队尾元素并删除</td>
<td style="text-align:center">无</td>
<td style="text-align:left">E removeLast() / E pollLast()</td>
</tr>
<tr>
<td style="text-align:right">取队尾元素但不删除</td>
<td style="text-align:center">无</td>
<td style="text-align:left">E getLast() / E peekLast()</td>
</tr>
</tbody>
</table>
<p>Deque是一个接口，它的实现类有ArrayDeque和LinkedList。<br>
我们发现LinkedList真是一个全能选手，它即是List，又是Queue，还是Deque。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p>
<p>面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p>
<h1>栈Stack</h1>
<p>LIFO(last in first out)<br>
在Java中，我们用Deque可以实现Stack的功能：</p>
<ul>
<li>把元素压栈：push(E)/addFirst(E)；</li>
<li>把栈顶的元素“弹出”：pop(E)/removeFirst()；</li>
<li>取栈顶元素但不弹出：peek(E)/peekFirst()。</li>
</ul>
<h3 id="栈的作用"><a class="header-anchor" href="#栈的作用">¶</a>栈的作用</h3>
<ol>
<li>JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。<br>
因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发StackOverflowError。</li>
<li>计算进制转换，将余数一次压栈再pop出即为结果。</li>
<li>计算中缀表达式：先转换为后缀表达式，将数字依次压栈，遇到运算符则pop出两个数字计算，将结果压栈，继续计算。</li>
</ol>
<h1>iterator</h1>
<p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p>
<h1>Collections</h1>
<p>一个工具类，可以操作集合的元素。</p>
<h4 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list);</span><br></pre></td></tr></table></figure>
<h4 id="洗牌"><a class="header-anchor" href="#洗牌">¶</a>洗牌</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.shuffle(list);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/2020/03/07/Java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<pre><code>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。
</code></pre>
<a id="more"></a>
<h1>Annotation的种类</h1>
<p>第一类是由编译器使用的注解，例如：</p>
<ul>
<li>@Override：让编译器检查该方法是否正确地实现了覆写；</li>
<li>@SuppressWarnings：告诉编译器忽略此处代码产生的警告。<br>
这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。</li>
</ul>
<p>第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>
<p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
<h5 id="注解的参数"><a class="header-anchor" href="#注解的参数">¶</a>注解的参数</h5>
<p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p>
<h1>定义注解</h1>
<p>使用@interface语法来定义annotation。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。</p>
<h3 id="元注解"><a class="header-anchor" href="#元注解">¶</a>元注解</h3>
<p>可以修饰注解，添加规则。</p>
<h5 id="Target"><a class="header-anchor" href="#Target">¶</a>@Target</h5>
<p>使用@Target可以定义Annotation能够被应用于源码的哪些位置：<br>
类或接口：ElementType.TYPE；<br>
字段：ElementType.FIELD；<br>
方法：ElementType.METHOD；<br>
构造方法：ElementType.CONSTRUCTOR；<br>
方法参数：ElementType.PARAMETER。</p>
<h5 id="Retention"><a class="header-anchor" href="#Retention">¶</a>@Retention</h5>
<p>另一个重要的元注解@Retention定义了Annotation的生命周期：<br>
仅编译期：RetentionPolicy.SOURCE；<br>
仅class文件：RetentionPolicy.CLASS；<br>
运行期：RetentionPolicy.RUNTIME。<br>
如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解</p>
<h1>处理注解</h1>
<p>讨论一下runtime的注解，注解定义后其实是一个class，所有的注解都继承自java.lang.annotation.Annotation，因此读取注解要用到反射API。</p>
<h3 id="反射读取annotation"><a class="header-anchor" href="#反射读取annotation">¶</a>反射读取annotation</h3>
<ol>
<li>
<p>判断某个注解是否存在于Class、Field、Method或Constructor：</p>
<p>Class.isAnnotationPresent(Class)<br>
Field.isAnnotationPresent(Class)<br>
Method.isAnnotationPresent(Class)<br>
Constructor.isAnnotationPresent(Class)</p>
</li>
<li>
<p>使用反射API读取Annotation：<br>
Class.getAnnotation(Class)<br>
Field.getAnnotation(Class)<br>
Method.getAnnotation(Class)<br>
Constructor.getAnnotation(Class)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">    Report report = cls.getAnnotation(Report<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用注解"><a class="header-anchor" href="#使用注解">¶</a>使用注解</h3>
<h5 id="1-定义注解"><a class="header-anchor" href="#1-定义注解">¶</a>1 定义注解</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-使用注解"><a class="header-anchor" href="#2-使用注解">¶</a>2 使用注解</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Range</span>(min=<span class="number">1</span>, max=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range</span>(max=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-检查方法"><a class="header-anchor" href="#3-检查方法">¶</a>3 检查方法</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid field: "</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>字符流中第一个不重复的字符</title>
    <url>/2020/03/07/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<pre><code>题目：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。
</code></pre>
<a id="more"></a>
<h2 id="解法"><a class="header-anchor" href="#解法">¶</a>解法:</h2>
<pre><code>使用一个int[]做标记，第一次出现计为index值，第二次出现则计为-2。字节流输入完后，然后检查这个[]里的元素，第一个大于零的即为第一个只出现的字符，其所在位置的下标即为该字符的ASCII码值，类型转换后返回。
</code></pre>
<h2 id="Code"><a class="header-anchor" href="#Code">¶</a>Code:</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] occurence = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;<span class="number">256</span>;i++)&#123;</span><br><span class="line">            occurence[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(occurence[ch] == -<span class="number">1</span>)&#123;</span><br><span class="line">            occurence[ch] = index;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(occurence[ch]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            occurence[ch] = -<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(occurence[i] &gt;=<span class="number">0</span> &amp;&amp; occurence[i]&lt;minIndex)&#123;</span><br><span class="line">                ch = (<span class="keyword">char</span>)i;</span><br><span class="line">                minIndex = occurence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2020/03/06/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>泛型是一种“代码模板”，可以用一套代码套用各种类型。编写一次，万能匹配。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList，它可以看作“可变长度”的数组，内部就是一个Object[]数组，配合存储一个当前分配的长度。</p>
<h4 id="向上转型"><a class="header-anchor" href="#向上转型">¶</a>向上转型</h4>
<p>在Java标准库中的ArrayList<T>实现了List<T>接口，它可以向上转型为List<T>。<br>
要特别注意：不能把ArrayList<Integer>向上转型为ArrayList<Number>或List<Number>。<br>
我们把一个ArrayList<Integer>转型为ArrayList<Number>类型后，这个ArrayList<Number>就可以接受Float类型，因为Float是Number的子类。但是，ArrayList<Number>实际上和ArrayList<Integer>是同一个对象，也就是ArrayList<Integer>类型，它不可能接受Float类型， 所以在获取Integer的时候将产生ClassCastException。</Integer></Integer></Number></Number></Number></Integer></Number></Number></Integer></T></T></T></p>
<h1>使用泛型</h1>
<p>编译器看到泛型类型List<Number>就可以自动推断出后面的ArrayList<T>的泛型类型必须是ArrayList<Number>，因此，可以把代码简写为：</Number></T></Number></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="泛型接口"><a class="header-anchor" href="#泛型接口">¶</a>泛型接口</h3>
<p>除了ArrayList<T>使用了泛型，还可以在接口中使用泛型。例如，Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable<T>这个泛型接口：<br>
可以直接对String数组进行排序,这是因为String本身已经实现了Comparable<String>接口。如果换成我们自定义的Person类型试试：</String></T></T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] ps = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"Bob"</span>, <span class="number">61</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="number">88</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">75</span>),</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(ps);</span><br><span class="line">System.out.println(Arrays.toString(ps));</span><br></pre></td></tr></table></figure>
<p>运行程序，我们会得到ClassCastException，即无法将Person转型为Comparable。我们修改代码，让Person实现Comparable<T>接口：</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">","</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以正确实现按name进行排序。也可以修改比较逻辑，例如，按score从高到低排序。</p>
<h1>编写泛型</h1>
<p>通常来说，泛型类一般用在集合类中。<br>
首先，按照某种类型，例如：String，来编写类。<br>
然后，标记所有的特定类型，这里是String。<br>
最后，把特定类型String替换为T，并申明<T>。</T></p>
<h3 id="静态方法"><a class="header-anchor" href="#静态方法">¶</a>静态方法</h3>
<p>编写泛型类时，要特别注意，泛型类型<T>不能用于静态方法。<br>
可以在static修饰符后面加一个<T>，编译就能通过：</T></T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以编译通过:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上，这个<T>和Pair<T>类型的<T>已经没有任何关系了<br>
对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的create()静态方法，我们应该把它改为另一种泛型类型，例如，<K>：这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</K></T></T></T></p>
<h3 id="多个泛型类型"><a class="header-anchor" href="#多个泛型类型">¶</a>多个泛型类型</h3>
<p>泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型&lt;T, K&gt;：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时特别指出两种类型：</span></span><br><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">"test"</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>Java标准库的Map&lt;K, V&gt;就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p>
<h1>擦拭法Type Erasure</h1>
<h3 id="实现泛型的底层"><a class="header-anchor" href="#实现泛型的底层">¶</a>实现泛型的底层</h3>
<p>Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<T>视为Object；</T></li>
<li>编译器根据<T>实现安全的强制转型。<br>
所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</T></li>
</ul>
<h3 id="Java泛型的局限"><a class="header-anchor" href="#Java泛型的局限">¶</a>Java泛型的局限</h3>
<p>局限一：<T>不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型。<br>
局限二：无法取得带泛型的Class。<br>
因为T是Object，我们对Pair<String>和Pair<Integer>类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。<br>
换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair<Object>。<br>
局限三：无法判断带泛型的Class<br>
局限四：不能实例化T类型<br>
创建new Pair<String>()和创建new Pair<Integer>()就全部成了Object，显然编译器要阻止这种类型不对的代码。<br>
要实例化T类型，我们必须借助额外的Class<T>参数：</T></Integer></String></Object></Integer></String></T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法要防止重复定义方法。定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。<br>
换个方法名，避开与Object.equals(Object)的冲突就可以成功编译，如same(T t)。</p>
<h3 id="泛型继承"><a class="header-anchor" href="#泛型继承">¶</a>泛型继承</h3>
<p>一个类可以继承自一个泛型类</p>
<h1>extend通配符</h1>
<p>有没有办法使得方法参数接受Pair<Integer>？办法是有的，这就是使用Pair&lt;? extends Number&gt;使得方法接收所有泛型类型为Number或Number子类的Pair类型。加入extend之后泛型擦拭将为Number而不是Object。</Integer></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，给方法传入Pair<Integer>类型时，它符合参数Pair&lt;? extends Number&gt;类型。这种使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。<br>
除了可以传入Pair<Integer>类型，我们还可以传入Pair<Double>类型，Pair<BigDecimal>类型等等，因为Double和BigDecimal都是Number的子类。</BigDecimal></Double></Integer></Integer></p>
<h3 id="不可传入泛型类型的引用给泛型类型的set方法"><a class="header-anchor" href="#不可传入泛型类型的引用给泛型类型的set方法">¶</a>不可传入泛型类型的引用给泛型类型的set方法</h3>
<p>编译错误发生在p.setFirst()传入的参数是Integer类型。有些童鞋会问了，既然p的定义是Pair&lt;? extends Number&gt;，那么setFirst(? extends Number)为什么不能传入Integer？<br>
原因还在于擦拭法。如果我们传入的p是Pair<Double>，显然它满足参数定义Pair&lt;? extends Number&gt;，然而，Pair<Double>的setFirst()显然无法接受Integer类型。<br>
这就是&lt;? extends Number&gt;通配符的一个重要限制：方法参数签名setFirst(? extends Number)无法传递任何Number类型给setFirst(? extends Number)。<br>
这里唯一的例外是可以给方法参数传入null。</Double></Double></p>
<h3 id="extend的作用"><a class="header-anchor" href="#extend的作用">¶</a>extend的作用</h3>
<p>为什么我们定义的方法参数类型是List&lt;? extends Integer&gt;而不是List<Integer>？从方法内部代码看，传入List&lt;? extends Integer&gt;或者List<Integer>是完全一样的，但是，注意到List&lt;? extends Integer&gt;的限制：</Integer></Integer></p>
<p>允许调用get()方法获取Integer的引用；<br>
不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。<br>
因此，方法参数类型List&lt;? extends Integer&gt;表明了该方法内部只会读取List的元素，不会修改List的元素（因为无法调用add(? extends Integer)、remove(? extends Integer)这些方法。换句话说，这是一个对参数List&lt;? extends Integer&gt;进行只读的方法（恶意调用set(null)除外）。</p>
<h3 id="使用extend限定-T-类型"><a class="header-anchor" href="#使用extend限定-T-类型">¶</a>使用extend限定<T>类型</T></h3>
<p>在定义泛型类型Pair<T>的时候，也可以使用extends通配符来限定T的类型。非Number类型将无法通过编译。</T></p>
<h1>super通配符</h1>
<p>使用的类型只能是泛型的父类。<br>
因此，使用&lt;? super Integer&gt;通配符表示：<br>
允许调用set(? super Integer)方法传入Integer的引用；<br>
不允许调用get()方法获得Integer的引用。因为传入的类型，也有可能是number。<br>
唯一例外是可以获取Object的引用：Object o = p.getFirst()。<br>
换句话说，使用&lt;? super Integer&gt;通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p>
<h3 id="PECS"><a class="header-anchor" href="#PECS">¶</a>PECS</h3>
<p>何时使用extends，何时使用super？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。<br>
即：如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            T t = src.get(i); <span class="comment">// src是producer</span></span><br><span class="line">            dest.add(t); <span class="comment">// dest是consumer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要返回T的src是生产者，因此声明为List&lt;? extends T&gt;，需要写入T的dest是消费者，因此声明为List&lt;? super T&gt;。</p>
<h1>无限定通配符</h1>
<p>因为&lt;?&gt;通配符既没有extends，也没有super，因此：<br>
不允许调用set(T)方法并传入引用（null除外）；<br>
不允许调用T get()方法并获取T引用（只能获取Object引用）。<br>
换句话说，既不能读，也不能写，那只能做一些null判断</p>
<ul>
<li>Pair&lt;?&gt;是所有Pair<T>的超类，可以安全的向上转型。</T></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">    Pair&lt;?&gt; p2 = p; <span class="comment">// 安全地向上转型</span></span><br><span class="line">    System.out.println(p2.getFirst() + <span class="string">", "</span> + p2.getLast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>泛型和反射</h1>
<p>部分反射也是泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile warning:</span></span><br><span class="line">Class clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">String str = (String) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// no warning:</span></span><br><span class="line">Class&lt;String&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">String str = clazz.newInstance();</span><br></pre></td></tr></table></figure>
<p>调用Class的getSuperclass()方法返回的Class类型是Class&lt;? super T&gt;。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格｜《剑指offer》</title>
    <url>/2020/03/06/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
</code></pre>
<a id="more"></a>
<h2 id="解法1"><a class="header-anchor" href="#解法1">¶</a>解法1:</h2>
<p>正则表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.toString().replaceAll(<span class="string">"\\s"</span>,<span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法2"><a class="header-anchor" href="#解法2">¶</a>解法2:</h2>
<p>从后向前的替换字符串。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> str.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oriLength = str.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= oriLength-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> str.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newLength = oriLength + count*<span class="number">2</span>;</span><br><span class="line">        str.setLength(newLength);</span><br><span class="line">        newLength--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = oriLength - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">                str.setCharAt(newLength--,<span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(newLength--,<span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(newLength--,<span class="string">'%'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str.setCharAt(newLength--,str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试用例"><a class="header-anchor" href="#测试用例">¶</a>测试用例</h5>
<ol>
<li>输入的字符串包含空格。（空格位于最前面，最后面，中间，有连续多个空格）</li>
<li>输入的字符串没有空格</li>
<li>特殊输入测试（字符串是一个null，字符串为空，字符串只有一个空格字符）</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>构建乘积数组｜《剑指offer》</title>
    <url>/2020/03/06/%E2%80%9C%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E2%80%9D/</url>
    <content><![CDATA[<pre><code>题目：给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）
</code></pre>
<a id="more"></a>
<h2 id="解法："><a class="header-anchor" href="#解法：">¶</a>解法：</h2>
<p>做两次循环处理，先从下到上计算0 ～ i-1个的乘积，再从上到下计算n ～ i+1的乘积。</p>
<h2 id="Code"><a class="header-anchor" href="#Code">¶</a>Code:</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">            B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; ++i)&#123;</span><br><span class="line">                B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length - <span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                temp *= A[i + <span class="number">1</span>];</span><br><span class="line">                B[i] *= temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> B;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试用例"><a class="header-anchor" href="#测试用例">¶</a>测试用例</h5>
<ol>
<li>功能测试（输入数组包括正数，负数，一个0，多个0）</li>
<li>边界测试（输入数组长度为0）</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找｜《剑指offer》</title>
    <url>/2020/03/06/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
</code></pre>
<a id="more"></a>
<h2 id="解法："><a class="header-anchor" href="#解法：">¶</a>解法：</h2>
<p>右上角开始查找，一次可以消除一列或者一行不符合的数。</p>
<h4 id="code"><a class="header-anchor" href="#code">¶</a>code</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((row &lt;= array[<span class="number">0</span>].length-<span class="number">1</span>)&amp;&amp;(column &gt;= <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[row][column] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[row][column] &gt; target)</span><br><span class="line">                column -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[row][column] &lt; target)</span><br><span class="line">                row += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：</p>
<ol>
<li>数组中没有查找的数字</li>
<li>空数组</li>
<li>数组中有查找的数字</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce：Simplified Data Processing on Large Clusters</title>
    <url>/2020/03/06/MapReduce%EF%BC%9ASimplified%20Data%20Processing%20on%20Large%20Clusters/</url>
    <content><![CDATA[<h3 id="摘要"><a class="header-anchor" href="#摘要">¶</a>摘要</h3>
<pre><code>MapReduce既是一种编程模型，也是一种与之关联的、用于处理和产生大数据集的实现。用户要特化一个map程序去处理key/value对，并产生中间key/value对的集合，以及一个reduce程序去合并有着相同key的所有中间key/value对。本文指出，许多实际的任务都可以用这种模型来表示。

用这种函数式风格写出的程序自动就拥有了在一个大的PC机集群上并行执行的能力。运行时系统会负责细节：切分输入数据，在一组机器上调度执行程序，处理机器错误，以及管理所需的机器间通信。这允许不具备任何并行和分布式系统经验的程序员也能轻松地利用一个大型分布式系统的资源。

我们的MapReduce实现运行在一个大型PC机集群上，且具有很好的扩展性：一个典型的MapReduce计算要在数千台机器上处理若干TB的数据。程序员可以很轻松的使用这一系统：目前已经实现的MapReduce程序数以百计，每天有上千个MapReduce作业运行在Google的集群上。
</code></pre>
<a id="more"></a>
<h3 id="1-介绍"><a class="header-anchor" href="#1-介绍">¶</a>1 介绍</h3>
<p>在过去的5年中，作者以及许多其他Google员工实现了数百个特定用途的计算过程，其中包括了处理大量的原始数据（抓取文档、网络请求日志等等），计算许多种类的衍生数据（倒排索引、网络文档图结构的多种表示、单台主机抓取页面数量的概要、指定日期频次最高的请求集合等等）。大多数这样的计算过程在概念上都很直接。但输入数据量通常都很大，因此计算过程需要分布到数百或数千台机器上进行，才能保证过程在一个合理时间内结束。而为了处理计算并行化、数据分发和错误处理等问题而引入大量复杂的代码则令原本简单的计算过程变的晦涩难懂。</p>
<p>作为对这种复杂性的回应，我们设计了一种新的抽象，允许我们表达出原本简单的计算过程，且将涉及并行、容错性、数据分发和负载均衡的凌乱细节隐藏在一个函数库中。我们的抽象受到了Lisp等函数式语言中的map和reduce原语的启发。我们意识到我们大多数的计算都包含了在每个输入的逻辑“记录”上应用map操作，从而计算出一组中间key/value对的集合，然后再向共享同一个key的所有中间value应用reduce操作，从而适当地合并衍生数据。我们对用户定义的map和reduce操作的使用允许我们轻松地将大型计算并行化，以及将再执行作为容错性的主要机制。</p>
<p>本项工作的主要贡献是一个简单但功能强大的接口，允许自动实现并行化和大范围的分布计算，和一个与此接口结合的实现，能在普通PC机集群上达到很高的性能。</p>
<p>第2部分描述了基本的编程模型并给出了几个例子。第3部分描述了针对我们基于集群的计算环境而裁剪的MapReduce接口的一个实现。第4部分描述了我们觉得非常有用的一些编程模型的技巧。第5部分针对多种不同的任务，对我们的实现进行了性能测量。第6部分探索了在Google中MapReduce的应用，包括了我们在将其作为生产索引系统的重写基础的经验。第7部分讨论了相关的和未来要做的工作。</p>
<h3 id="2-编程模型"><a class="header-anchor" href="#2-编程模型">¶</a>2 编程模型</h3>
<p>计算过程就是输入一组key/value对，再生成输出一组key/value对。MapReduce库的使用者用两个函数来表示这个过程：map和reduce。</p>
<p>map由使用者编写，使用一个输入key/value对，生成一组中间key/value对。MapReduce库将有着相同中间key I的中间value都组合在一起，再传给reduce函数。</p>
<p>reduce也由使用者编写，它接受一个中间key I和一组与I对应的value。它将这些value合并为一个可能更小的value集合。通常每个reduce调用只产生0或1个输出value。中间value是通过一个迭代器提供给reduce函数的。这允许我们操作那些因为大到找不到连续存放的内存而使用链表的value集合。</p>
<h4 id="2-1-示例"><a class="header-anchor" href="#2-1-示例">¶</a>2.1 示例</h4>
<p>考虑一个问题：统计一个很大的文档集合中每个单词出现的次数。使用者能写出与下面的伪代码相似的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(String key,String value):</span><br><span class="line">    // key: 文档名</span><br><span class="line">    // value: 文档内容</span><br><span class="line">    <span class="keyword">for</span> each word w <span class="keyword">in</span> value:</span><br><span class="line">        EmitIntermediate(w,<span class="string">"1"</span>);</span><br><span class="line">   </span><br><span class="line">reduce(Stringkey, Iterator values):</span><br><span class="line">    // key: 一个单词</span><br><span class="line">    // value: 计数值列表</span><br><span class="line">    int result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> each v <span class="keyword">in</span> values:</span><br><span class="line">        result += ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure>
<p>map函数将每个单词与出现次数一同输出（本例中简单的输出“1”）。reduce函数将针对某个特定词输出的次数都合并相加。</p>
<p>另外，使用者要写代码填充一个符合MapReduce规格的对象，内容包括输入和输出文件的名字，以及可选的调节参数。之后使用者调用MapReduce函数，将指定的对象传进去。用户代码会与MapReduce库（C++实现）链接到一起。附录A包括了这个例子的全部程序文本。</p>
<h4 id="2-2-类型"><a class="header-anchor" href="#2-2-类型">¶</a>2.2 类型</h4>
<p>尽管前面的伪代码写成了用字符串进行输入输出，但从概念上讲用户提供的map和reduce函数是关联着类型的：</p>
<table>
<thead>
<tr>
<th style="text-align:right">map</th>
<th style="text-align:center">(k1,v1)</th>
<th style="text-align:left">👉list(k2,v2)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">reduce</td>
<td style="text-align:center">(k2,list(v2))</td>
<td style="text-align:left">👉list(v2)</td>
</tr>
</tbody>
</table>
<p>也就是说，输入的key和value与输出的key和value的域不同。进一步说，中间的key和value与输出的key和value的域相同。</p>
<p>我们的C++实现使用字符串与用户定义的函数交互，而将字符串与相应类型的转换留给用户代码完成。</p>
<h4 id="2-3-更多例子"><a class="header-anchor" href="#2-3-更多例子">¶</a>2.3 更多例子</h4>
<p>这里例举了一些有趣的程序，它们都可以很轻松的用MapReduce模型表达。</p>
<p><b>分布式Grep：</b>map函数在匹配到给定的pattern时输出一行。reduce函数只是将给定的中间数据复制到输出上。</p>
<p><b>URL访问频次统计：</b>map函数处理网页请求的日志，对每个URL输出〈URL, 1〉。reduce函数将相同URL的所有值相加并输出〈URL, 总次数〉对。</p>
<p><b>倒转Web链接图：</b>map函数在source页面中针对每个指向target的链接都输出一个〈target, source〉对。reduce函数将与某个给定的target相关联的所有source链接合并为一个列表，并输出〈target, list(source)〉对。</p>
<p><b>每个主机的关键词向量：</b>关键词向量是对出现在一个文档或一组文档中的最重要的单词的概要，其形式为〈单词, 频率〉对。map函数针对每个输入文档（其主机名可从文档URL中提取到）输出一个〈主机名, 关键词向量〉对。给定主机的所有文档的关键词向量都被传递给reduce函数。reduce函数将这些关键词向量相加，去掉其中频率最低的关键词，然后输出最终的〈主机名, 关键词向量〉对。</p>
<p><b>倒排索引：</b>map函数解析每个文档，并输出一系列〈单词, 文档ID〉对。reduce函数接受给定单词的所有中间对，将它们按文档ID排序，再输出〈单词, list(文档ID)〉对。所有输出对的集合组成了一个简单的倒排索引。用户可以很轻松的扩展这个过程来跟踪单词的位置。</p>
<p><b>分布式排序：</b>map函数从每条记录中提取出key，并输出〈key, 记录〉对。reduce函数不改变这些中间对，直接输出。这个过程依赖于4.1节介绍的划分机制和4.2节介绍的排序性质。</p>
<h3 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h3>
<p>许多不同的MapReduce的实现都是可行的。选择哪一个要取决于环境。例如，一种实现可能适合于小型的共享内存机器，一种实现可能适合于大型的NUMA多处理器机器，而另一种则适合于更大型的联网机器集。</p>
<p>本部分描述的实现主要面向Google内部广泛使用的计算环境：大型的商用PC机集群，互相之间用交换式以太网连接。我们的环境是：</p>
<ol>
<li>
<p>主要使用的机器为双核X86处理器，运行Linux系统，每台机器的内存从2GB到4GB不等。</p>
</li>
<li>
<p>使用的都是商用网络硬件设备——在机器层面上通常从100Mbps到1Gbps不等，但平均起来要比总带宽的一半少很多。</p>
</li>
<li>
<p>集群中拥有数百或数千台机器，因此机器错误经常出现。</p>
</li>
<li>
<p>每台机器都使用廉价的IDE硬盘来提供存储功能。我们使用一种内部开发的分布式文件系统来管理这些磁盘上的数据。这个文件系统通过复制的方法在不可靠的硬件之上提供了实用性与可靠性。</p>
</li>
<li>
<p>用户向一个调度系统提交作业。每个作业包括了一个任务集，会由调度器调度到集群内可用的一组机器上。</p>
</li>
</ol>
<h4 id="执行过程概述"><a class="header-anchor" href="#执行过程概述">¶</a>执行过程概述</h4>
<p>通过自动将输入数据切分为M块，map调用分布在多台机器上进行。输入划分可以在不同的机器上并行执行。reduce调用是通过一个划分函数（例如hash(key) mod R)将中间key空间划分为R块来分布运行。划分的块数R和划分函数都由用户指定。</p>
<p><img src="/.io//Execution_overview.png" alt="Execution_overview"></p>
<p>图1展示了我们的实现中MapReduce操作的整体流程。当用户程序调用MapReduce函数时，会发生下面一系列动作（图1中的标号与下面列表顺序相同）：</p>
<ol>
<li>
<p>用户程序中的MapReduce库首先将输入文件切分为M块，每块的大小从16MB到64MB（用户可通过一个可选参数控制此大小）。然后MapReduce库会在一个集群的若干台机器上启动程序的多个副本。</p>
</li>
<li>
<p>程序的各个副本中有一个是特殊的——主节点，其它的则是工作节点。主节点将M个map任务和R个reduce任务分配给空闲的工作节点，每个节点一项任务。</p>
</li>
<li>
<p>被分配map任务的工作节点读取对应的输入区块内容。它从输入数据中解析出key/value对，然后将每个对传递给用户定义的map函数。由map函数产生的中间key/value对都缓存在内存中。</p>
</li>
<li>
<p>缓存的数据对会被周期性的由划分函数分成R块，并写入本地磁盘中。这些缓存对在本地磁盘中的位置会被传回给主节点，主节点负责将这些位置再传给reduce工作节点。</p>
</li>
<li>
<p>当一个reduce工作节点得到了主节点的这些位置通知后，它使用RPC调用去读map工作节点的本地磁盘中的缓存数据。当reduce工作节点读取完了所有的中间数据，它会将这些数据按中间key排序，这样相同key的数据就被排列在一起了。同一个reduce任务经常会分到有着不同key的数据，因此这个排序很有必要。如果中间数据数量过多，不能全部载入内存，则会使用外部排序。</p>
</li>
<li>
<p>reduce工作节点遍历排序好的中间数据，并将遇到的每个中间key和与它关联的一组中间value传递给用户的reduce函数。reduce函数的输出会写到由reduce划分过程划分出来的最终输出文件的末尾。</p>
</li>
<li>
<p>当所有的map和reduce任务都完成后，主节点唤醒用户程序。此时，用户程序中的MapReduce调用返回到用户代码中。</p>
</li>
</ol>
<p>成功完成后，MapReduce执行的输出都在R个输出文件中（每个reduce任务产生一个，文件名由用户指定）。通常用户不需要合并这R个输出文件——他们经常会把这些文件当作另一个MapReduce调用的输入，或是用于另一个可以处理分成多个文件输入的分布式应用。</p>
<h4 id="3-2-主节点数据结构"><a class="header-anchor" href="#3-2-主节点数据结构">¶</a>3.2 主节点数据结构</h4>
<p>主节点维持多种数据结构。它会存储每个map和reduce任务的状态（空闲、处理中、完成），和每台工作机器的ID（对应非空闲的任务）。</p>
<p>主节点是将map任务产生的中间文件的位置传递给reduce任务的通道。因此，主节点要存储每个已完成的map任务产生的R个中间文件的位置和大小。位置和大小信息的更新情况会在map任务完成时接收到。这些信息会被逐步发送到正在处理中的reduce任务节点处。</p>
<h4 id="3-3-容错性"><a class="header-anchor" href="#3-3-容错性">¶</a>3.3 容错性</h4>
<p>既然MapReduce库是为了帮助使用成百上千台机器处理数量非常大的数据的，它就必须能够优雅地承受机器错误。</p>
<h5 id="工作节点错误"><a class="header-anchor" href="#工作节点错误">¶</a>工作节点错误</h5>
<p>主节点周期性的ping每个工作节点。如果工作节点在一定时间内没有回应，主节点就将它标记为已失败。这个工作节点完成的任何map任务都被重置为空闲状态，并可被调度到其它工作节点上。同样地，失败的工作节点上正在处理的任何map或reduce任务也被重置为空闲状态，允许被调度。</p>
<p>失败节点上已完成的map任务需要重执行的原因是它们的输出存储在失败机器的本地磁盘上，因此无法访问到了。已完成的reduce任务不需要重执行，因为它们的输出存储在了一个全球文件系统上。</p>
<p>当一个map任务先被A节点执行过，随后又被B节点重执行（A节点已失败），所有执行reduce任务的工作节点都能收到重执行的通知。任何没有读取完A节点数据的reduce任务都会从B节点读取数据。</p>
<p>MapReduce可以弹性应对大范围的工作节点失败。例如，在一次MapReduce操作期间，运行系统上的网络维护导致了一组约80台机器在同一时间无法访问，持续了数分钟。MapReduce主节点只是简单的重执行了已由无法访问的机器完成的任务，并继续向前执行，最终完成了这次MapReduce操作。</p>
<h5 id="主节点错误"><a class="header-anchor" href="#主节点错误">¶</a>主节点错误</h5>
<p>一种简单的方法是令主节点定期将上面描述的数据结构保存为恢复点。如果主节点任务失败，就可以从上一个恢复点状态启动一个新的程序副本。但是给定的条件是只有一个主节点，它也不太可能失败；因此我们当前的实现会在主节点失败时中止MapReduce计算 。客户可以检查到这一情况，并在他们需要时重启MapReduce操作。</p>
<h5 id="出现故障时的语义"><a class="header-anchor" href="#出现故障时的语义">¶</a>出现故障时的语义</h5>
<p>当用户提供的map和reduce操作对于它们输入的值都是确定性的，我们的分布式实现产生的输出值就如同将整个程序分成一个不间断的串行执行过程一样。</p>
<p>为了实现这个性质，我们依赖于map和reduce任务输出结果的提交是原子的。每个处理中的任务都会将它的输出写入私有的临时文件中。一个reduce任务产生一个这样的文件，而一个map任务则产生R个这样的文件（每个reduce任务一个）。当map任务完成时，工作节点发送给主节点的消息中带有R个临时文件的名字。如果主节点收到了一个来自已完成节点的完成消息，它就会忽略这个消息。否则，主节点会将R个文件的名字记录在相应的数据结构中。</p>
<p>当reduce任务完成时，工作节点会执行原子性的更名操作，将临时输出文件更名为最终输出文件。如果相同的reduce任务在多个机器上执行，就会有多个更名调用应用在相同的最终输出文件上。我们依赖于由底层文件系统提供的原子更名操作，才能保证最终的文件系统中只包含由其中一个reduce执行产生的数据。</p>
<p>我们的绝大多数map和reduce操作都是确定性的，这种情况下我们的语义和一个串行执行过程是等同的，这也使程序员很容易推出他们程序的行为。当map和reduce操作有不确定性时，我们提供较弱但仍然合理的语义。当存在不确定的操作时，某个reduce任务R1的输出等价于一个不确定程序的串行执行输出。但某个reduce任务R2的输出可能符合这个不确定程序的另一个串行执行输出。</p>
<p>考虑map任务M和reduce任务R1、R2。令e(Ri)为Ri的已提交的执行结果（只执行一次）。此时弱语义生效，因为e(R1)可能读取了M的一次输出，而e(R2)则可能读取了M的另一次输出。</p>
<h4 id="3-4-局部性"><a class="header-anchor" href="#3-4-局部性">¶</a>3.4  局部性</h4>
<p>在我们的计算环境中，网络带宽是一种比较稀缺的资源。我们利用下面的事实来节省带宽：输入数据（由GFS管理）就存储在组成集群的机器的本地磁盘上。GFS将每个文件分成64MB大小的区块，每块复制若干份（通常为3份）存储到不同的机器上。MapReduce主节点会把输入文件的位置信息考虑进去，并尝试将map任务分配到保存有相应输入数据的机器上。如果失败的话，它会试图将map任务调度到临近这些数据的机器上（例如与保存输入数据的机器处于同一网关的工作节点）。当在一个集群的相当一部分节点上运行MapReduce操作时，大多数输入数据都是本地读取，并不消耗网络带宽。</p>
<h4 id="3-5-任务粒度"><a class="header-anchor" href="#3-5-任务粒度">¶</a>3.5  任务粒度</h4>
<p>如上所述，我们将map阶段分成M份，将reduce阶段分成R份。理想情况下，M和R应该比工作节点机器的数量大很多。每个工作节点处理很多不同的任务，可以增强动态负责均衡能力，也能加速有工作节点失败时的恢复情况：失败节点已经完成的map任务有很多的时候也能传递给其它所有工作节点来完成。</p>
<p>在我们的实现中M和R的数量有一个实际的上限：如上所述，主节点必须做O(M+R)的调度决定以及在内存中保持O(M<em>R)个状态。（但是内存使用的常数项很小：O(M</em>R)个状态中每个map/reduce任务对只需要差不多1字节数据。）</p>
<p>进一步分析，R通常由用户指定，因为每个reduce任务都会产生一个独立的输出文件。在实践中我们倾向于这样选择M，即可以将每个单独的任务分成16-64MB大的输入数据（此时上面所说的局部性优化效果最好），同时我们令R为待使用的工作节点数量较小的整数倍。我们经常使用M=200000，R=5000，使用2000台机器来运行MapReduce计算。</p>
<h4 id="3-6-备用任务"><a class="header-anchor" href="#3-6-备用任务">¶</a>3.6  备用任务</h4>
<p>导致MapReduce操作用时延长的一个常见原因是出现了“落后者”：某台机器在完成最后的一个map或reduce任务时花费了反常的漫长时间。很多原因都会导致落后者的产生。例如，一台磁盘损坏的机器可能会遭遇频繁的可校正错误，导致它的读取性能从30MB/s降至1MB/s。集群调度系统可能已经调度了其它任务到这台机器，导致它在执行MapReduce代码时因为CPU、内存、本地磁盘或网络带宽的竞争而更加缓慢。最近我们遇到的一个问题是机器的初始化代码有一个bug，导致处理器缓存被禁用：受影响的机器上的计算速度下降了超过100倍。</p>
<p>我们有一个通用的机制来减轻落后者问题。当MapReduce操作接近完成时，主节点会将仍在处理中的剩余任务调度给其它机器作备用执行。原本的执行和备用执行中的任一个完成时都会将对应任务标记为已完成。我们已经调整过这个机制，使它因这个机制而增加的计算资源消耗通常只有一点点。我们已经观察到这一机制有效地减少了大型MapReduce操作花费的时间。例如，5.3节中的排序程序在禁用这一机制时要多花费44%的时间。</p>
<h3 id="4-技巧"><a class="header-anchor" href="#4-技巧">¶</a>4 技巧</h3>
<p>尽管仅仅用map和reduce函数提供的基本功能就足够解决大多数需求了，我们还是发现了一些很有用的扩展。这些扩展将在本节进行描述。</p>
<h4 id="4-1-划分函数"><a class="header-anchor" href="#4-1-划分函数">¶</a>4.1  划分函数</h4>
<p>MapReduce的用户指定他们想要的reduce任务/输出文件的数量。通过划分函数可以将数据按中间key划分给各个reduce任务。我们默认提供了散列函数当作默认的划分函数（例如，hash(key) mod R)。通常这就能得出很平衡的划分结果了。但在有些情况下，用key的其它信息来划分数据也很有帮助。例如有时输出的key都是URL，而我们想让所有来自同一主机的项最后都在同一个输出文件中。为了支持类似这样的情况，MapReduce的用户可以提供一个特殊的划分函数。例如，使用“hash(主机名(urlkey)) mod R”来解决上面的问题。</p>
<h4 id="4-2-顺序保证"><a class="header-anchor" href="#4-2-顺序保证">¶</a>4.2  顺序保证</h4>
<p>我们保证在给定的划分中，中间key/value对是按增序排列的。这个顺序保证使每个划分产生一个有序的输出文件变得很容易，当输出文件的格式需要支持高效的按key随机访问，或用户需要输出数据有序时，这一性质会非常有用。</p>
<h4 id="4-3-合并函数"><a class="header-anchor" href="#4-3-合并函数">¶</a>4.3  合并函数</h4>
<p>某些情况中，不同的map任务产生的中间key重复率非常高，而且用户指定的reduce函数可进行交换组合。一个典型的例子就是2.1节中的单词统计。单词频率符合齐夫分布（百度百科），因此每个map任务都会产生非常多的&lt;the, 1&gt;这样的记录。所有这些记录都会通过网络被发送给一个reduce任务，然后再通过reduce函数将它们相加，产生结果。我们允许用户指定一个可选的合并函数，在数据被发送之前进行局部合并。</p>
<p>合并函数由每个执行map任务的机器调用。通常合并函数与reduce函数的实现代码是相同的。它们唯一的区别就是MapReduce库处理函数输出的方式。reduce函数的输出会写到最终的输出文件中，而合并函数的输出会写到中间文件中，并在随后发送给一个reduce任务。</p>
<h4 id="4-4-输入和输出类型"><a class="header-anchor" href="#4-4-输入和输出类型">¶</a>4.4  输入和输出类型</h4>
<p>MapReduce库支持多种不同格式输入数据的读取。例如，“text”模式将每行输入当作一个key/value对：key是文件中的偏移，而value则是该行的内容。另一种支持的常见格式将key/value对按key排序后连续存储在一起。每种输入类型的实现都知道如何将它本身分成有意义的区间从而能分成独立的map任务进行处理（例如text模式的区间划分保证了划分点只出现在行边界处）。用户也可以通过实现一个简单的reader接口来提供对新的输入类型的支持，尽管大多数用户只是使用为数不多的几种预定义输入类型中的一种。</p>
<p>reader的实现不一定要提供从文件中读数据的功能。例如，可以很容易的定义一个从数据库读记录的reader，或是从映射在内存中的某种数据结构中。</p>
<p>类似的，我们也支持一组输出类型来产生不同格式的数据，而用户提供代码去支持新的输出类型也不难。</p>
<h4 id="4-5-边界效应"><a class="header-anchor" href="#4-5-边界效应">¶</a>4.5  边界效应</h4>
<p>有些情况下，MapReduce的用户发现从他们的map或reduce操作中产生一些额外的辅助文件很有帮助。我们依赖于应用作者来确保这样的边界效应是原子且幂等的。通常应用会写一个临时文件，并在文件生成完毕时将其原子的更名。</p>
<p>我们不提供在单一任务产生的多个输出文件中原子的两段提交。因此，如果一个任务产生多个输出文件，且要求有跨文件的一致性，它必须是确定性的。这个限制在实践中还没有引起过问题。</p>
<h4 id="4-6-略过坏记录"><a class="header-anchor" href="#4-6-略过坏记录">¶</a>4.6  略过坏记录</h4>
<p>有时用户代码中的bug会导致map或reduce函数一遇到特定的记录就崩溃。这些bug会导致MapReduce操作无法完成。通常的应用措施是修复这些bug，但有时难以实现：也许bug存在于得不到源代码的第三方库中。同样地，有时忽略一些记录是可以接受的，例如在一个大数据集上做统计分析时。我们提供了一个可选的执行模式，在MapReduce库检测到确定会导致崩溃的记录时路过它们从而继续进度。</p>
<p>每个工作进程都要安装一个信号处理程序来捕捉违规操作和总线错误。在调用用户的map或reduce操作前，MapReduce库将用于验证的序列号保存在全局变量中。如果用户代码产生了信号，信号处理程序就将一个包含这个序列号的“最后一步”UDP包发送给MapReduce主节点。当主节点在某个记录上发现了超过一个错误时，就表明下一次重执行相应的map或reduce任务时要跳过这个记录。</p>
<h4 id="4-7-本地执行"><a class="header-anchor" href="#4-7-本地执行">¶</a>4.7  本地执行</h4>
<p>map或reduce函数的调试问题常常令人难以捉摸，因为实际的计算过程都发生在分布式系统上，经常包含数千台机器，而工作分配决策都由主节点动态产生。为了帮助调试、性能分析、小范围测试，我们开发了MapReduce库的一个替代实现，可以将MapReduce操作的全部工作在一台本地机器上顺序执行。用户拥有控制权，因此计算可以被限制在特定的map任务中。用户调用他们的程序时加上一个特殊标志，就可以方便的使用任何有用的调试或测试工具。</p>
<h4 id="4-8-状态信息"><a class="header-anchor" href="#4-8-状态信息">¶</a>4.8  状态信息</h4>
<p>主节点内置了一个HTTP服务器，可以将当前状态输出为一组网页供用户使用。状态网页能显示计算的进度，例如有多少任务被完成，多少正在处理，输入数据大小，中间数据大小，输出数据大小，处理速度，等等。这些网页还包含指向每个任务的stdout和stderr输出文件的链接。用户可以用这些数据来预测计算要花费多长时间，以及是否应该增加计算使用的资源。这些网页也能用于在计算速率比预期慢很多时发现这一情况。</p>
<p>另外，顶层的状态网页还能显示哪些工作节点失败了，它们失败时正在处理哪些map和reduce任务。当要在用户代码中确定bug时这些时间非常有用。</p>
<h4 id="4-9-计数器"><a class="header-anchor" href="#4-9-计数器">¶</a>4.9  计数器</h4>
<p>MapReduce库提供了计数器机制，可以统计多种事件的发生次数。例如，用户代码可能想统计已处理的单词总数，或被索引的德语文献的数量等。</p>
<p>为了使用这一机制，用户代码需要创建一个有名的计数器对象，并在map和reduce函数的适当位置增加它的值。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Counter *uppercase = GetCounter(<span class="string">"uppercase"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">String</span> name, <span class="keyword">String</span> contents):</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">word</span> w in contents:</span><br><span class="line">        <span class="keyword">if</span> (IsCapitalized(w)):</span><br><span class="line">            uppercase-&gt;Increment();</span><br><span class="line">        EmitIntermediate(w, <span class="string">"1"</span>);</span><br></pre></td></tr></table></figure>
<p>工作节点上的计数器值会定期发送给主节点（附在ping的回应里）。当MapReduce操作完成时，主节点会将运行成功的map和reduce任务发来的计数器值合并后返回给用户代码。当前的计数器值也会显示在主节点的状态网页上，其它人可以看到实时的计算进度。在合并计数器值时，主节点会忽略同一个map或reduce任务的重复的结果，从而避免多次叠加。（重复执行可能发生在我们的备用任务和失败节点重执行中。）</p>
<p>有些计数值是由MapReduce库自动维护的，例如输入key/value对已处理的数量和输出key/value对产生的数量等。</p>
<p>用户们观察到这一机制在对MapReduce操作的智能检查上很有帮助。例如，在一些MapReduce操作中，用户代码可能想要确认产生的输出对的数量恰好与输入对的数量相等，或是已处理的德语文献占处理文献总数的比例是在接受范围内的。</p>
<h3 id="5-性能"><a class="header-anchor" href="#5-性能">¶</a>5 性能</h3>
<p>本节中我们会在一个大型集群上测量MapReduce在两个计算上的性能。一个计算是在差不多1TB的数据中查找指定的模式。另一个计算则是排序1TB的数据。</p>
<p>这两个程序能代表大量真实的MapReduce程序——一类程序是将数据从一种表示形式转换为另一种，另一类程序则是从很大数量的数据集中提取出一小部分感兴趣的数据。</p>
<h4 id="5-1-集群配置"><a class="header-anchor" href="#5-1-集群配置">¶</a>5.1  集群配置</h4>
<p>所有的程序都运行在由1800台机器组成的集群上。每台机器配有：2GHz的Intel Xeon处理器且支持超线程，4GB内存，2块160GB的IDE硬盘，和1GB以太网连接。所有机器都安排在2层树结构的网关内，根节点的可用带宽加起来有100-200Gbps。所有的机器都处于相同的托管设施下，因此任意两台机器间的往返通信时间都少于1ms。</p>
<p>除了4GB的内存，还有1-1.5GB的内存保留给了集群上运行的其它任务。程序运行的时间是一个周末的下午，此时大多数CPU、磁盘和网络资源都空闲中。</p>
<h4 id="5-2-Grep"><a class="header-anchor" href="#5-2-Grep">¶</a>5.2  Grep</h4>
<p>grep程序要扫描1010个长度为100字节的记录来寻找一个相当罕见的三字符模式（这个模式出现于92337个记录中）。输入被切分成64MB大小的部分（M = 15000），整个输出为一个文件（R = 1）。</p>
<p><img src="/.io//transfer.png" alt="transfer"></p>
<p>图2显示了随时间变化的计算进度。Y轴是输入数据扫描的速率。这个速率逐渐提升代表更多的机器被分配给MapReduce计算，并在分配的机器数达到1764台时超过了30GB/s。随着map任务的结束，这个速率开始下降，并在计算开始后80s时降至0。整个计算过程共花费约150s。这包括了大约1分钟的启动开销。启动开销是由于要把程序传播到所有工作机器上，还包括GFS要打开1000个输入文件和获取局部优化所需信息而导致的延迟。</p>
<h4 id="5-3-排序"><a class="header-anchor" href="#5-3-排序">¶</a>5.3  排序</h4>
<p>排序程序要对10100个100字节的记录进行排序（差不多1TB数据）。这个程序模仿了TeraSort测试程序。</p>
<p>排序程序只包括不到50行的用户代码。map函数一共3行，它从一个文本行中提取出10字节的排序key，再将key和原始文本行输出为中间key/value对。我们使用了一个内置的Identity函数作为reduce函数。这个函数会将未更改的中间key/value输出为结果。最终的排序后输出被出到一组2路复制的GFS文件（例如，这个程序的输出要写2TB的数据）。</p>
<p>如前所述，输入数据被分成若干个64MB大小的部分（M = 15000）。我们将已排序的输出分成4000个文件（R = 4000）。划分函数使用key的首字节来将它分到R个文件中的一个。</p>
<p>此次测试中我们的划分函数使用了key分布的内建知识。在一个一般的排序程序中，我们会预先加一轮MapReduce操作，收集key的样本，并使用key抽样的分布来计算最终输出文件的划分点。</p>
<p><img src="/.io//rates.png" alt="rates"></p>
<p>图3(a)是排序程序的正常执行过程。上边的图显示了输入读取的速度。输入速度的峰值为13GB/s，并在200秒后所有的map任务都完成时迅速下降至0。可以注意到这个速度要比grep的速度小。这是因为排序的map任务要在向本地磁盘写中间文件上花费大约一半的时间和I/O带宽。而grep中相应的中间输出则可以忽略不计。</p>
<p>中间的图显示了数据从map节点通过网络向reduce节点发送的速度。这个移动开始于第一个map任务完成。图中的第一个驼峰出现在reduce任务第一次达到1700个时（整个MapReduce共分配到1700台机器，每台机器同时最多只运行一个reduce任务）。计算开始差不多300秒时，第一批reduce任务已经有部分完成，我们开始向剩余的reduce任务传送数据。所有传送过程在计算开始600秒后结束。</p>
<p>下面的图是reduce任务向最终的输出文件写入已排序数据的速度。在第一个传输周期的结束与写入周期的开始之间有一个延迟，因为此时机器正在排序中间数据。写入速度在2-4GB/s下持续了一段时间。所有的写操作在计算开始后850秒左右结束。包括启动开销的话，整个计算花费了891秒。这与TeraSort上目前公布的最佳记录1057秒很接近。</p>
<p>一些要注意的事：因为我们的局部性优化，输入速度要比传播速度和输出速度都快——大多数数据都读自本地磁盘，绕开了我们带宽相当有限的网络。传播速度要比输出速度高，因为输出阶段要写两份已排序的数据（因为可靠性和实用性的考虑）。我们写两份输出是因为这是我们的底层文件系统针对可靠性和实用性提供的机制。如果底层文件系统使用擦除代码而不是复制，那么写数据需要的网络带宽就会减少。</p>
<h4 id="5-4-备用任务的影响"><a class="header-anchor" href="#5-4-备用任务的影响">¶</a>5.4  备用任务的影响</h4>
<p>在图3(b)中显示的是禁用了备用任务情况下排序程序的执行过程。这种情况下的执行过程与图3(a)中的很相似，但在末尾处有很长一段时间几乎没有任何的写操作发生。在960秒后，只有5个reduce任务还没有完成。但这最后的几个任务直到300秒后才结束。整个计算花费了1283秒，比正常情况多花费44%的时间。</p>
<h4 id="5-5-机器失败"><a class="header-anchor" href="#5-5-机器失败">¶</a>5.5  机器失败</h4>
<p>在图3©中显示了有机器失败情况下的排序程序执行过程。在计算开始几分钟后，我们有意的杀掉了1746个工作节点中的200个。底层集群调度器立即在这些机器上重启了新的工作进程（只有进程被杀掉了，机器还在正常运行中）。</p>
<p>工作节点的死亡显示为一个负的输入速度，因为一些已经完成的map任务消失了（因为对应的map节点被杀掉了）需要重新完成。这些map任务的重执行很快就会发生。整个计算过程在933秒后结果，包括了启动开销（相比正常执行时间只增加了5%）。</p>
<h3 id="6-经验"><a class="header-anchor" href="#6-经验">¶</a>6 经验</h3>
<p>我们在2003年2月写出了MapReduce库的第一个版本，并在2003年8月进行了非常大的改进，包括了局部性优化、各工作机器上任务执行的动态负载平衡等。从那时开始，我们愉快地惊讶于MapReduce被如此广泛地应用在我们工作中遇到问题上。它已被用于Google的很多领域中，包括：</p>
<ul>
<li>
<p>大规模机器学习问题；</p>
</li>
<li>
<p>针对Google News和Froogle产品的集群问题；</p>
</li>
<li>
<p>用于产生流行需求报告的数据提取（例如Google Zeitgeist）；</p>
</li>
<li>
<p>针对新的尝试和产品的网页属性提取（例如，从大量的定位搜索中提取出地理位置信息）；</p>
</li>
<li>
<p>大规模的图计算。</p>
</li>
</ul>
<p><img src="/.io//instances.png" alt="instances"></p>
<p>图4显示了在我们的源代码管理系统中进行了登记的MapReduce程序的数量随时间的显著增长，从2003年初的0到2004年9月底的接近900个不同版本。MapReduce取得如此成功的原因是它令花半小时时间写出一个简单的程序并运行在一千台机器上成为了可能，这极大地加速了开发和原型实现循环。进一步说，它允许没有分布式与并行系统经验的程序员也能轻松地利用大量的资源。</p>
<p><img src="/.io//jobs.png" alt="jobs"></p>
<p>在每项作业的结尾，MapReduce库会将作业花费的计算资源统计写入日志。在表1中，我们能看到Google在2004年8月运行的MapReduce作业的一部分统计情况。</p>
<h4 id="6-1-大规模索引"><a class="header-anchor" href="#6-1-大规模索引">¶</a>6.1  大规模索引</h4>
<p>迄今为止我们的一个最重要的MapReduce应用是完全重写了生产索引系统，它负责产生用于Google网络搜索服务的数据结构。索引系统把由我们的爬取系统检索的一个大的文档集合作为输入，并存储为一组GFS文件。这些文档的原始文本数据超过了20TB。索引进程分成了5-10个MapReduce操作运行。使用MapReduce（而不是之前版本使用的ad-hoc分布系统）提供了许多好处：</p>
<ul>
<li>
<p>索引代码更简单，更小，也更易懂，因为处理容错性和分布与并行的代码都被隐藏在MapReduce库中了。例如，其中一个阶段的计算在使用了MapReduce后从差不多3800行C++代码降到了700行代码。</p>
</li>
<li>
<p>MapReduce库的性能足够好，因此我们可以令概念上无关的计算过程相互分离，而不需要为了避免额外的数据处理而将它们混合在一起。这减小了修改索引进程的难度。例如，在我们的旧索引系统中进行一个修改要花费几个月时间，而在新系统中只需要几天时间。</p>
</li>
<li>
<p>索引进程更容易去操作，因为大多数由机器失败、部分机器缓慢和网络暂时中断引起的问题都由MapReduce库自动处理了，不需要操作者干预。此外，通过向集群中增加机器，可以很容易地增强索引进程的性能。</p>
</li>
</ul>
<h3 id="7-相关工作"><a class="header-anchor" href="#7-相关工作">¶</a>7 相关工作</h3>
<p>许多系统都提供了约束好的程序模型，并利用这些约束自动的进行并行计算。例如，一个组合函数可以在N个处理器上使用并行前缀计算用log N的时间计算出包含N个元素的数组的所有前缀。MapReduce可以被认为是基于来自我们在真实世界中的大型计算的经验，对这些模型的简单化和提炼。更重要的是，我们提供了可以扩展到上千个处理器上使用的容错机制。作为对比，大多数并行处理系统只能在小规模下实现，并将处理机器错误的细节留给程序员去完成。</p>
<p>Bulk Synchronous Programming和一些MPI原语提供了更高层次的抽象，更容易写出并行程序。这些系统和MapReduce的一个关键区别是MapReduce利用了一个受约束的程序模型去自动并行化用户程序，并提供透明的容错机制。</p>
<p>我们的局部性优化受到了诸如活动磁盘等技术的启发，即将计算推给靠近本地磁盘的处理单元，来减少要跨过I/O子系统或网络发送的数据总量。我们用运行在直接连接了少量磁盘的商用处理器上替代了直接运行在磁盘控制处理器上，但通用的方法是相似的。</p>
<p>我们的备用任务机制与Charlotte系统上的eager调度机制类似。简单的eager调度系统有一个缺点，就是如果某个任务导致了多次失败，整个计算都会失败。我们通过自己的略过坏记录的机制解决了一些这类问题。</p>
<p>MapReduce的实现依赖于一个内部的集群管理系统，它负责在一组数量很多的共享机器上分布运行用户任务。尽管不是本文的重点，这个集群管理系统与Condor等其它系统在原理上是类似的。</p>
<p>排序机制作为MapReduce库的一部分，与NOW-Sort操作是类似的。源机器（map节点）切分待排序的数据并将其发送给R个reduce节点。每个reduce节点在本地排序它的数据（尽量存放在内存中）。当然NOW-Sort没有用户定义的map和reduce函数，这些使我们的库被广泛应用。</p>
<p>River提供了一个编程模型，通过在分布式队列上发送数据来处理通信。类似于MapReduce，River系统试图提供提供好的平均情况性能，即使存在因不统一的硬件或系统扰动而导致的不一致性。River通过小心的调度磁盘和网络传输来实现平衡的完成时间，从而达到这一目标。MapReduce使用了不同的方法。通过约束编程模型，MapReduce框架能够将问题划分成大量细粒度的任务。这些任务被动态调度给可用的工作节点，因此更快的节点会处理更多的任务。这个约束的编程模型同样允许我们在临近作业结束时将剩余的任务重复调度执行，这显著的减少了存在不一致时（例如有缓冲或停顿的机器）的完成时间。</p>
<p>BAD-FS有着与MapReduce非常不同的编程模型，而且不像MapReduce，它面向跨越广域网的作业执行。但是，它与MapReduce有着两个本质上的相同点：</p>
<p>两个系统都使用了备用执行来恢复因错误而导致的数据丢失。</p>
<p>两个系统都使用了局部感知调度来减少在拥堵的网络连接上发送的数据量。</p>
<p>TACC被设计为一个高度可用的网络服务的简化结构系统。类似于MapReduce，它依赖于重执行机制来实现容错性。</p>
<h3 id="8-结论"><a class="header-anchor" href="#8-结论">¶</a>8 结论</h3>
<p>MapReduce编程模型已经成功的用于Google的许多不同的用途中。我们将它的成功归功于几个原因。首先，该模型即使是对于没有并行和分布式系统经验的程序员也是很易于使用的，因为它隐藏了并行化、容错机制、局部性优化、以及负载平衡的细节。其次，很多种类的问题都很容易表示成MapReduce计算。例如，MapReduce被用于为Google的网络搜索服务的数据产生、排序、数据挖掘、机器学习、以及许多其它系统。第三，我们已经开发了一个MapReduce的实现，可以扩展到包含上千台机器的大型集群。该实现可以高效使用这些机器的资源，因此适合于Google遇到的很多大型计算问题。</p>
<p>我们从这项工作中学到了很多东西。首先，约束这个编程模型令并行和分布式计算，以及令这些计算可容错，变得简单了。其次，网络带宽是一种稀缺资源。我们系统中的很多优化都因此针对减少通过网络发送的数据总量：局部性优化允许我们从本地磁盘读，同时将中间文件写入本地磁盘也节省了网络带宽。第三，备用执行可以用于减小缓慢的机器的影响，及应对机器失败和数据丢失。</p>
<h3 id="附录A-词频统计源代码"><a class="header-anchor" href="#附录A-词频统计源代码">¶</a>附录A 词频统计源代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mapreduce/mapreduce.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// User's map fuction</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span>:</span> <span class="keyword">public</span> Mapper &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Map</span><span class="params">(<span class="keyword">const</span> MapInput &amp;input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="built_in">text</span> = input.value();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="built_in">text</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="comment">// Skip past leading whitespace</span></span><br><span class="line">            <span class="keyword">while</span> ((i &lt; n) &amp;&amp; <span class="built_in">isspace</span>(<span class="built_in">text</span>[i]))</span><br><span class="line">                ++i;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// Find word end</span></span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; n) &amp;&amp; !<span class="built_in">isspace</span>(<span class="built_in">text</span>[i]))</span><br><span class="line">                ++i;</span><br><span class="line">                 </span><br><span class="line">            <span class="keyword">if</span> (start &lt; i)</span><br><span class="line">                Emit(<span class="built_in">text</span>.substr(start, i-start), <span class="string">"1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">REGISTER_MAPPER(WordCounter);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// User's reduce function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span>:</span> <span class="keyword">public</span> Reducer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reduce</span><span class="params">(ReduceInput *input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Iterate over all entries with the</span></span><br><span class="line">        <span class="comment">// same key and add the values</span></span><br><span class="line">        <span class="keyword">int64_t</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!input-&gt;done()) &#123;</span><br><span class="line">            value += StringToInt(input-&gt;value());</span><br><span class="line">            input-&gt;NextValue();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// Emit sum for input-&gt;key()</span></span><br><span class="line">        Emit(IntToString(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">REGISTER_REDUCER(Adder);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    ParseCommandLineFlags(argc, argv);</span><br><span class="line">     </span><br><span class="line">    MapReduceSpecification spec;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Store list of input files into "spec"</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        MapReduceInput *input = spec.add_input();</span><br><span class="line">        input-&gt;set_format(<span class="string">"text"</span>);</span><br><span class="line">        input-&gt;set_filepattern(argv[i]);</span><br><span class="line">        input-&gt;set_mapper_class(<span class="string">"WordCounter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Specify the output files:</span></span><br><span class="line">    <span class="comment">//    /gfs/test/freq-00000-of-00100</span></span><br><span class="line">    <span class="comment">//    /gfs/test/freq-00001-of-00100</span></span><br><span class="line">    <span class="comment">//    ...</span></span><br><span class="line">    MapReduceOutput *out = spec.output();</span><br><span class="line">    out-&gt;set_filebase(<span class="string">"/gfs/test/freq"</span>);</span><br><span class="line">    out-&gt;set_num_tasks(<span class="number">100</span>);</span><br><span class="line">    out-&gt;set_format(<span class="string">"text"</span>);</span><br><span class="line">    out-&gt;set_reducer_class(<span class="string">"Adder"</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Optional: do partial sums within map</span></span><br><span class="line">    <span class="comment">// tasks to save network bandwidth</span></span><br><span class="line">    out-&gt;set_combine_class(<span class="string">"Adder"</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Tuning parameters: use at most 2000</span></span><br><span class="line">    <span class="comment">// machines and 100MB of memory per task</span></span><br><span class="line">    spec.set_machines(<span class="number">2000</span>);</span><br><span class="line">    spec.set_map_megabytes(<span class="number">100</span>);</span><br><span class="line">    spec.set_reduce_megabytes(<span class="number">100</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Now run it</span></span><br><span class="line">    MapReduceResult result;</span><br><span class="line">    <span class="keyword">if</span> (!MapReduce(spec, &amp;result))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">         </span><br><span class="line">    <span class="comment">// Done: 'result' structure contains info</span></span><br><span class="line">    <span class="comment">// about counters, time taken, number of</span></span><br><span class="line">    <span class="comment">// machines used, etc.</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/2020/03/04/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>反射reflection是指程序在运行期可以拿到一个对象的所有信息。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Person p = (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">" "</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>强制转型仍然需要引用person类，否则无法通过编译。</p>
<h1>Class类</h1>
<p>class(包括interface)的本质是type，是由JVM在执行过程中动态加载的。第一次读取到class类，则加载进内存。每加载一种class，JVM则为其创建一个Class类型的实例并关联起来。eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//构造方法是private，只有JVM能创建</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载String类时关联</span></span><br><span class="line">Class cls = <span class="keyword">new</span> Class(String)</span><br></pre></td></tr></table></figure>
<p>一个Class实例包含了该class的所有完整信息：name, package…<br>
所以获取了某个Class实例，就可以通过这个实例获取到该实例对应的class的所有信息。这种方法称为反射(Reflection)。<br>
方法由三个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：通过class的静态变量获取</span></span><br><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//方法二：通过实例变量的getClass()</span></span><br><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls = s.getClass();</span><br><span class="line"><span class="comment">//方法三：知道class的完整类名，通过静态方法Class.forName()</span></span><br><span class="line">Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
<h5 id="判断类型"><a class="header-anchor" href="#判断类型">¶</a>判断类型</h5>
<p>instanceof可以匹配指定类型的子类，==是精确判断是不是某一个类。<br>
JVM为基本数据类型也创建了Class，int.class来访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure>
<h5 id="打印信息"><a class="header-anchor" href="#打印信息">¶</a>打印信息</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"Class name: "</span> + cls.getName());</span><br><span class="line">System.out.println(<span class="string">"Simple name: "</span> + cls.getSimpleName());</span><br><span class="line"><span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Package name: "</span> + cls.getPackage().getName());</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println(<span class="string">"is interface: "</span> + cls.isInterface());</span><br><span class="line">System.out.println(<span class="string">"is enum: "</span> + cls.isEnum());</span><br><span class="line">System.out.println(<span class="string">"is array: "</span> + cls.isArray());</span><br><span class="line">System.out.println(<span class="string">"is primitive: "</span> + cls.isPrimitive());</span><br></pre></td></tr></table></figure>
<h2 id="动态加载"><a class="header-anchor" href="#动态加载">¶</a>动态加载</h2>
<p>new创建对象的方式称作为静态加载，而使用Class.forName(“XXX”)称作为动态加载，它们俩本质的区别在于静态加载的类的源程序在编译时期加载（必须存在），而动态加载的类在编译时期可以缺席（源程序不必存在）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">"org.apache.logging.log4j.Logger"</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。<br>
利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。</p>
<h1>访问字段</h1>
<pre><code>获取字段的field
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一定要throws Exception</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获取public字段"score": getfields()则是获取所有字段的field</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">"score"</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段"name":</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">"name"</span>));</span><br><span class="line">        <span class="comment">// 获取private字段"grade":</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">"grade"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Field对象包含了一个字段的所有信息：</p>
<p>getName()：返回字段名称，例如，“name”；<br>
getType()：返回字段类型，也是一个Class实例，例如，String.class；<br>
getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取字段信息</span></span><br><span class="line">Field f = String.class.getDeclaredField("value");</span><br><span class="line">f.getName(); <span class="comment">// "value"</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="获得字段的值"><a class="header-anchor" href="#获得字段的值">¶</a>获得字段的值</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>); <span class="comment">//将private改成public</span></span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// "Xiao Ming"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值。name被定义为一个private字段，正常情况下，Main类无法访问Person类的private字段。要修复错误，可以将private改为public，或者，在调用Object value = f.get§;前：调用Field.setAccessible(true)。</p>
<h3 id="设置字段的值"><a class="header-anchor" href="#设置字段的值">¶</a>设置字段的值</h3>
<p>通过Field.set(Object, Object)实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Xiao Ming"</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置字段值</span></span><br><span class="line">        f.set(p, <span class="string">"Xiao Hong"</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Xiao Hong"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>调用方法</h1>
<h3 id="获取方法（创建Method对象）"><a class="header-anchor" href="#获取方法（创建Method对象）">¶</a>获取方法（创建Method对象）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">"getScore"</span>, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">"getName"</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">"getGrade"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Method对象包含一个方法的所有信息：</p>
<pre><code>getName()：返回方法名称，例如：&quot;getScore&quot;；
getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；
getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；
getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义
</code></pre>
<h3 id="调用方法"><a class="header-anchor" href="#调用方法">¶</a>调用方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">"Hello world"</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod("substring", int.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p>
<h3 id="调用静态方法"><a class="header-anchor" href="#调用静态方法">¶</a>调用静态方法</h3>
<p>如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。我们以Integer.parseInt(String)为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod("parseInt", String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">"12345"</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用非public方法"><a class="header-anchor" href="#调用非public方法">¶</a>调用非public方法</h3>
<p>为了调用非public方法，我们通过Method.setAccessible(true)允许其调用。</p>
<h3 id="多态"><a class="header-anchor" href="#多态">¶</a>多态</h3>
<p>使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod("hello");</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person:hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student:hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>调用构造方法</h1>
<p>使用relect.Constructor:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">"456"</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。<br>
通过Class实例获取Constructor的方法如下：</p>
<pre><code>getConstructor(Class...)：获取某个public的Constructor；
getDeclaredConstructor(Class...)：获取某个Constructor；
getConstructors()：获取所有public的Constructor；
getDeclaredConstructors()：获取所有Constructor。
注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。
</code></pre>
<p>调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。</p>
<h1>获取继承关系</h1>
<h3 id="获取父类的class"><a class="header-anchor" href="#获取父类的class">¶</a>获取父类的class</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以看到，Integer的父类类型是Number，Number的父类是Object，Object的父类是null。除Object外，其他任何非interface的Class都必定存在一个父类类型。</p>
<h3 id="获取interface"><a class="header-anchor" href="#获取interface">¶</a>获取interface</h3>
<p>要特别注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()。如果一个类没有实现任何interface，那么getInterfaces()返回空数组。</p>
<h3 id="继承关系"><a class="header-anchor" href="#继承关系">¶</a>继承关系</h3>
<p>如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Number</span>.<span class="title">class</span>)</span>; <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>
<h1>动态代理Dynamic Proxy</h1>
<p>Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。<br>
先定义了接口Hello，但是我们并不去编写实现类，而是直接通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代理。JDK提供的动态创建接口对象的方式，就叫动态代理。<br>
动态代理实际上是JDK在运行期动态创建class字节码并加载的过程.</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中找到重复的数｜《剑指offer》</title>
    <url>/2020/03/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/</url>
    <content><![CDATA[<pre><code>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
</code></pre>
<a id="more"></a>
<ul>
<li>题目说明了数字的大小范围和数组的长度，即每个数字值的大小一定在数组的下标范围内。</li>
</ul>
<h2 id="解法："><a class="header-anchor" href="#解法：">¶</a>解法：</h2>
<h3 id="不改变原数组："><a class="header-anchor" href="#不改变原数组：">¶</a>不改变原数组：</h3>
<ol>
<li>
<p>排序后扫描数组: 时间复杂度O(nlogn)。</p>
</li>
<li>
<p>hash表：时间复杂度O(n),空间复杂度O(n)。<br>
类似哈希表：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] k = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k[numbers[i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k[numbers[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1) boolean不是占1位，计算机处理处理数据的最小单元是1字节，一般1位的话，其余7位会被0补齐。<br>
(2) 在java虚拟机规范中，JVM没有用于操作boolean的字节码指令，在编译后用int的数据类型代替boolean，此时boolean占4字节。<br>
(3) boolean[]数组编译后会被byte[]数组代替，此时的boolean占1字节。<br>
总结:boolean单独存在占4字节，在boolean[]中占1字节!</p>
<ol start="3">
<li>额外数组：时间复杂度O(n),空间复杂度O(n)<br>
创建一个n+1长度的数组，扫描原数组，数字为m的元素放入下标m处即可发现是否为重复数字。</li>
</ol>
<h3 id="改变原数组："><a class="header-anchor" href="#改变原数组：">¶</a>改变原数组：</h3>
<p><b>方法一：</b>可以利用现有数组设置标志，当一个数字Numbers[i]访问过，则让对应位置的Numbers[Numbers[i]]加length，再遇到相同的数时，大于length，则为重复的数。</p>
<h4 id="code"><a class="header-anchor" href="#code">¶</a>code</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查输入</span></span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:numbers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= length| i&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//正式检测</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">//取余处理访问边界</span></span><br><span class="line">            <span class="keyword">int</span> index=numbers[i]%length;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numbers[index]&gt;=length)&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = index;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            numbers[index] = numbers[index] + length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>方法二：</b>对数组重排，访问数组每个元素，如果i=numbers[i]，则访问下一个；如果不是，拿它和numbers[numbers[i]]比较。相等,则找到重复数字，不等，则交换。</p>
<h5 id="测试用例："><a class="header-anchor" href="#测试用例：">¶</a>测试用例：</h5>
<ol>
<li>不包含重复的数组</li>
<li>空数组</li>
<li>长度为n的数组里包含1个或多个重复数字。</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaLog</title>
    <url>/2020/03/03/JavaLog/</url>
    <content><![CDATA[<h5 id="Java内置logging包"><a class="header-anchor" href="#Java内置logging包">¶</a>Java内置logging包</h5>
<p>日志会自动打印了时间、调用类、调用方法等很多有用的信息。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logging</span></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">"start process..."</span>);</span><br><span class="line">        logger.warning(<span class="string">"memory is running out..."</span>);</span><br><span class="line">        logger.fine(<span class="string">"ignored."</span>);</span><br><span class="line">        logger.severe(<span class="string">"process will be terminated..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK的Logging定义了7个日志级别，从严重到普通：<br>
SEVERE，WARNING，INFO，CONFIG，FINE，FINER，FINEST<br>
因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。<br>
其局限在于Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置；<br>
配置不太方便，需要在JVM启动时传递参数 -Djava.util.logging.config.file=<config-file-name>。</config-file-name></p>
<ul>
<li>总结：不好用！</li>
</ul>
<h1>Commons logging</h1>
<p>一个Apache开发的日志接口，自动搜素Log4j，没找到则使用JDKLogging。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        log.info(<span class="string">"start..."</span>);</span><br><span class="line">        log.warn(<span class="string">"end."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三方库来的，需要编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#放入work path</span></span><br><span class="line"><span class="comment">#javac编译</span></span><br><span class="line">javac -cp commons-logging-1.2.jar Main.java</span><br><span class="line"><span class="comment">#执行这个Main.class，使用java命令，也必须指定classpath</span></span><br><span class="line">java -cp .:commons-logging-1.2.jar Main</span><br></pre></td></tr></table></figure>
<p>Commons Logging定义了6个日志级别：FATAL,ERROR,WARNING,INFO,DEBUG,TRACE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在子类中使用父类实例化的log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还重载了Info(“string”,Throwable)提供打印异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">"got exception!"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Log4j</h1>
<p>通过配置文件来配置它。<br>
以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"log.pattern"</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"file.err.filename"</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"file.err.pattern"</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;log.pattern&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"err"</span> <span class="attr">bufferedIO</span>=<span class="string">"true"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;file.err.filename&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;file.err.pattern&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;log.pattern&#125;"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"1 MB"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"console"</span> <span class="attr">level</span>=<span class="string">"info"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"err"</span> <span class="attr">level</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要把以下3个jar包放到classpath中：<br>
log4j-api-2.x.jar<br>
log4j-core-2.x.jar<br>
log4j-jcl-2.x.jar<br>
Commons Logging会自动发现并使用Log4j，所以，把上一节下载的commons-logging-1.2.jar也放到classpath中。<br>
要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出。</p>
<ul>
<li>总结： Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入classpath，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常处理</title>
    <url>/2020/03/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<pre><code>便于调试，运行检测。
</code></pre>
<a id="more"></a>
<h1>异常</h1>
<h2 id="Java异常种类"><a class="header-anchor" href="#Java异常种类">¶</a>Java异常种类</h2>
<ul>
<li>Error:<br>
OutOfMemoryError：内存耗尽<br>
NoClassDefFoundError：无法加载某个Class<br>
StackOverflowError：栈溢出</li>
<li>Exception:<br>
NumberFormatException：数值类型的格式错误<br>
FileNotFoundException：未找到文件<br>
SocketException：读取网络失败<br>
NullPointerException：对某个null的对象调用方法或字段<br>
IndexOutOfBoundsException：数组索引越界</li>
<li>必须捕获的异常，除RuntimeException以外的Exception，又称为Checked Exception。</li>
</ul>
<h2 id="捕获异常，try…catch"><a class="header-anchor" href="#捕获异常，try…catch">¶</a>捕获异常，try…catch</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bs = toGBK(<span class="string">"中文"</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>在main()方法中，调用toGBK()，没有捕获它声明的可能抛出的UnsupportedEncodingException,则会报错。
</code></pre>
<p>如果不想写try,则定义为throws Exception：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bs = toGBK(<span class="string">"中文"</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法抛出了可能出现的异常，可以不写catch。</p>
<h3 id="多捕获异常"><a class="header-anchor" href="#多捕获异常">¶</a>多捕获异常</h3>
<p><img src="/.io//Exception.png" alt></p>
<p>子类一定要写在前面，否则子类永远捕获不到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)(</span><br><span class="line">        System.out.println(<span class="string">"IO error"</span>);</span><br><span class="line">    ) <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">"Bad encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并异常处理，可以用｜：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">"Bad input"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Unknown error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="finally语句"><a class="header-anchor" href="#finally语句">¶</a>finally语句</h3>
<p>finally可以保证有无错误都执行。<br>
在try或者catch语句块中抛出异常，finally仍会执行，先执行finally再抛出。</p>
<h2 id="抛出异常"><a class="header-anchor" href="#抛出异常">¶</a>抛出异常</h2>
<h3 id="异常的传播"><a class="header-anchor" href="#异常的传播">¶</a>异常的传播</h3>
<p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try … catch被捕获为止</p>
<h3 id="e-printStackTrace-方法打印异常栈。"><a class="header-anchor" href="#e-printStackTrace-方法打印异常栈。">¶</a>e,printStackTrace()方法打印异常栈。</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer.parseInt(<span class="keyword">null</span>); <span class="comment">// 会抛出NumberFormatException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java.lang.NumberFormatException: null<br>
at java.base/java.lang.Integer.parseInt(Integer.java:614)<br>
at java.base/java.lang.Integer.parseInt(Integer.java:770)<br>
at Main.process2(Main.java:16)<br>
at Main.process1(Main.java:12)<br>
at Main.main(Main.java:5)<br>
返回类似如此，每层调用都给出了源代码的行号。</p>
<h3 id="异常屏蔽-Suppressed-Exception"><a class="header-anchor" href="#异常屏蔽-Suppressed-Exception">¶</a>异常屏蔽 Suppressed Exception</h3>
<p>如果finally抛出异常，catch中准备抛出的异常就会消失，因为只能抛出一个异常。</p>
<h2 id="自定义异常"><a class="header-anchor" href="#自定义异常">¶</a>自定义异常</h2>
<p>建立一个“根异常”BaseException，建议从RuntimeException中派生，其他业务类型的异常则从BaseException中派生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要支持多个构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有RuntimeException，编译时不能检测出该类异常。<br>
而未检测异常存在两种清形：<br>
① 如果该异常被捕获或抛出，则程序继续运行。<br>
② 如果异常没有被捕获该线程将会停止执行。<br>
Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p>
<h2 id="断言Assertion"><a class="header-anchor" href="#断言Assertion">¶</a>断言Assertion</h2>
<p>调试工具，一般在开发测试时使用。断言失败会抛出AssertionError，并可带上可选的断言消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">"x must &gt;= 0"</span>;</span><br></pre></td></tr></table></figure>
<p>断言失败会直接导致程序退出，对于可恢复程序，不应该使用断言，应该抛出异常并在上层捕获。</p>
<ul>
<li>JVM默认关闭断言指令，遇到时会自动忽略。要执行assert语句，必须传递 -enableassertions参数。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -ea Main.java</span><br></pre></td></tr></table></figure>
<p>最好还是使用单元测试。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬取偷廖老师的Java教程</title>
    <url>/2020/03/01/%E5%81%B7%E5%BB%96%E8%80%81%E5%B8%88%E7%9A%84Java%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<pre><code>今天想学点Java，访问了一下廖老师的网站，结果网很卡，可能廖老师在更新网站，然后突然想到可以写个爬虫一劳永逸。做这个爬虫的目的也是方便学习廖雪峰老师的Java教程，毕竟把网页存在本地方便浏览，并无他意。
</code></pre>
<a id="more"></a>
<h1>Code</h1>
<p>用的是requerst和xpath，推荐用Chrome上的xpath helper，真香。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##导入库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> lxml</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br></pre></td></tr></table></figure>
<h2 id="发送请求"><a class="header-anchor" href="#发送请求">¶</a>发送请求</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#send request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_request</span><span class="params">(url, headers)</span>:</span></span><br><span class="line">    r = requests.get(url,headers=headers)</span><br><span class="line">    print(<span class="string">'状态码:'</span>,r.status_code)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h2 id="提取数据"><a class="header-anchor" href="#提取数据">¶</a>提取数据</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#fetch data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(domain,resp, headers)</span>:</span></span><br><span class="line">    selector = lxml.etree.HTML(resp.text)    <span class="comment">#generate object</span></span><br><span class="line">    titles = selector.xpath(<span class="string">'//a[@class="x-wiki-index-item"]/text()'</span>)<span class="comment">#拿到各个页面的小标题，比如《面向对象》这种      </span></span><br><span class="line">    uri = selector.xpath(<span class="string">'//a[@class="x-wiki-index-item"]/@href'</span>) <span class="comment">#拿到各个页面的url的参数</span></span><br><span class="line">    <span class="comment">#打包到一起返回      </span></span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> uri:</span><br><span class="line">        urls.append(domain + i)    </span><br><span class="line">    <span class="keyword">return</span> titles, urls</span><br></pre></td></tr></table></figure>
<h1>下载页面</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(titles,urls)</span>:</span></span><br><span class="line">    <span class="comment">#设置下载路径</span></span><br><span class="line">    cwd=os.getcwd()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(cwd + <span class="string">'/廖雪峰Java教程HTML'</span>):</span><br><span class="line">        os.mkdir(cwd + <span class="string">'/廖雪峰Java教程HTML'</span>)</span><br><span class="line">    filepath = cwd + <span class="string">'/廖雪峰Java教程HTML/'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> zip(titles, urls):</span><br><span class="line">        resp = requests.get(value,headers=headers)</span><br><span class="line">        selector = lxml.etree.HTML(resp.text)    </span><br><span class="line">        <span class="comment">#拿到各个页面的正文</span></span><br><span class="line">        html = selector.xpath(<span class="string">'//div[@class="uk-flex-item-1"]'</span>) </span><br><span class="line">        <span class="comment">#转换类型</span></span><br><span class="line">        html = etree.tostring(html[<span class="number">0</span>], pretty_print = <span class="literal">True</span>, method = <span class="string">"html"</span>)</span><br><span class="line">        <span class="comment">#设置文件名</span></span><br><span class="line">        filename = filepath + <span class="string">"%d"</span> % titles.index(key) + key +<span class="string">'.html'</span></span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">'wb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">            f.write(html)</span><br><span class="line">        <span class="comment">#加一个延时，别访问太快</span></span><br><span class="line">        time.sleep(<span class="number">0.3</span>)</span><br><span class="line">    print(<span class="string">"下载完成"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a class="header-anchor" href="#主函数">¶</a>主函数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#main</span></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chro'</span></span><br><span class="line">                      <span class="string">'me/53.0.2785.104 Safari/537.36 Core/1.53.2372.400 QQBrowser/9.5.10548.400'</span></span><br><span class="line">&#125;</span><br><span class="line">domain = <span class="string">'http://www.liaoxuefeng.com'</span>           <span class="comment">#廖雪峰网站的域名</span></span><br><span class="line">url =  <span class="string">"https://www.liaoxuefeng.com/wiki/1252599548343744"</span> <span class="comment">#Java教程的url</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取Java教程的页面</span></span><br><span class="line">resp = send_request(url, headers)</span><br><span class="line"><span class="comment">#提取所有的数据回来，包括标题和urls</span></span><br><span class="line">titles, urls = fetch(domain, resp, headers)</span><br><span class="line"><span class="comment">#开始下载</span></span><br><span class="line">download(titles,urls)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心类</title>
    <url>/2020/03/01/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
    <content><![CDATA[<p>Java内部的核心类。</p>
<a id="more"></a>
<h1>String</h1>
<p>String本身是一个class，Java编译器允许它用…来表示一个字符串。其本质是通过char[]数组来表示的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s2 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'!'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>Java字符串是不可变的，其原理是：<br>
通过private final char[]字段，以及没有任何改变char[]的方法来实现的。<br>
而字符串的改变，实际是开辟了新的内存空间，通过内存地址“断开-连接”变化，改变指向。</p>
<h2 id="字符串操作"><a class="header-anchor" href="#字符串操作">¶</a>字符串操作</h2>
<h3 id="比较"><a class="header-anchor" href="#比较">¶</a>比较</h3>
<p>用a.equals(b)，忽略大小写比较，使用equalsIgnoreCase()方法。‘==’比较的是两者的引用。<br>
JVM共享的只有字符串的字面量，+或者substring()等操作符得到的字符串是不共享的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"HELLO"</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索"><a class="header-anchor" href="#搜索">¶</a>搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello"</span>.contains(<span class="string">"ll"</span>); <span class="comment">//true</span></span><br><span class="line"><span class="string">"Hello"</span>.indexof(<span class="string">"l"</span>); <span class="comment">//2</span></span><br><span class="line"><span class="string">"Hello"</span>.lastIndexof(<span class="string">"l"</span>); <span class="comment">//3</span></span><br><span class="line"><span class="string">"Hello"</span>.startsWith(<span class="string">"He"</span>); <span class="comment">//ture</span></span><br><span class="line"><span class="string">"Hello"</span>.endWith(<span class="string">"lo"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="重复"><a class="header-anchor" href="#重复">¶</a>重复</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"Java"</span>.repeat(<span class="number">3</span>);<span class="comment">//JavaJavaJava</span></span><br></pre></td></tr></table></figure>
<h3 id="提取"><a class="header-anchor" href="#提取">¶</a>提取</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>); <span class="comment">//"llo"</span></span><br><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>,<span class="number">4</span>) <span class="comment">//"llo"</span></span><br></pre></td></tr></table></figure>
<h3 id="去除首尾空白字符"><a class="header-anchor" href="#去除首尾空白字符">¶</a>去除首尾空白字符</h3>
<p>使用.trim()，包括\t,\n,\r</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"  \tHello\r\n "</span>.trim(); <span class="comment">// "Hello"</span></span><br></pre></td></tr></table></figure>
<p>strip()同时还会移除\u3000，中文空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"\u3000Hello\u3000"</span>.strip(); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="comment">//移除首或尾</span></span><br><span class="line"><span class="string">" Hello "</span>.stripLeading(); <span class="comment">// "Hello "</span></span><br><span class="line"><span class="string">" Hello "</span>.stripTrailing(); <span class="comment">// " Hello"</span></span><br></pre></td></tr></table></figure>
<h3 id="判空和空白字符"><a class="header-anchor" href="#判空和空白字符">¶</a>判空和空白字符</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">"  "</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">"  \n"</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">" Hello "</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure>
<h3 id="替换字串"><a class="header-anchor" href="#替换字串">¶</a>替换字串</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">s.replace(<span class="string">'l'</span>, <span class="string">'w'</span>); <span class="comment">// "hewwo"，所有字符'l'被替换为'w'</span></span><br><span class="line">s.replace(<span class="string">"ll"</span>, <span class="string">"~~"</span>); <span class="comment">// "he~~o"，所有子串"ll"被替换为"~~"</span></span><br></pre></td></tr></table></figure>
<p>正则表达式替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"A,,B;C ,D"</span>;</span><br><span class="line">s.replaceAll(<span class="string">"[\\,\\;\\s]+"</span>, <span class="string">","</span>); <span class="comment">// "A,B,C,D"</span></span><br></pre></td></tr></table></figure>
<h3 id="分割合并"><a class="header-anchor" href="#分割合并">¶</a>分割合并</h3>
<h2 id="￼10"><a class="header-anchor" href="#￼10">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"A,B,C,D"</span>;</span><br><span class="line"><span class="comment">//分割</span></span><br><span class="line">String[] ss = s.split(<span class="string">"\\,"</span>); <span class="comment">// &#123;"A", "B", "C", "D"&#125;</span></span><br><span class="line"><span class="comment">//合并字符串数组</span></span><br><span class="line">String[] arr = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">String s = String.join(<span class="string">"***"</span>, arr); <span class="comment">// "A***B***C"</span></span><br></pre></td></tr></table></figure></h2>
<h1>类型转换</h1>
<h3 id="转换成String"><a class="header-anchor" href="#转换成String">¶</a>转换成String()</h3>
<p>用静态方法valueof(),这是重载方法，自动检测类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// "123"</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// "45.67"</span></span><br><span class="line">String.valueOf(<span class="keyword">true</span>); <span class="comment">// "true"</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> Object()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>
<h3 id="String转换成其他类型"><a class="header-anchor" href="#String转换成其他类型">¶</a>String转换成其他类型</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换成int</span></span><br><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(<span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">int</span> n2 = Integer.parseInt(<span class="string">"ff"</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br><span class="line"><span class="comment">//String转换成boolean</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = Boolean.parseBoolean(<span class="string">"true"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = Boolean.parseBoolean(<span class="string">"FALSE"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要特别注意，Integer有个getInteger(String)方法，它不是将字符串转换为int，而是把该字符串对应的系统变量转换为Integer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">"java.version"</span>); <span class="comment">// 版本号，11</span></span><br></pre></td></tr></table></figure>
<ul>
<li>非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同。</li>
<li>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。<br>
原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。</li>
</ul>
<h3 id="与char-相互转换"><a class="header-anchor" href="#与char-相互转换">¶</a>与char[]相互转换</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="string">"Hello"</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line">String s = <span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>
<p>如果修改了char[]数组，String并不会改变。这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份。</p>
<p>如果类内部直接引用了外部传入的int[]数组，而外部代码对int[]数组的修改，会影响到Score类的字段。如果外部代码不可信，这就会造成安全隐患。</p>
<h2 id="￼15"><a class="header-anchor" href="#￼15">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] scores = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">88</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">66</span> &#125;;</span><br><span class="line">        Score s = <span class="keyword">new</span> Score(scores);</span><br><span class="line">        s.printScores();</span><br><span class="line">        scores[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        s.printScores();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] scores;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Score</span><span class="params">(<span class="keyword">int</span>[] scores)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用clone()方法拷贝副本，而不是复制引用</span></span><br><span class="line">        <span class="keyword">this</span>.scores = scores.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printScores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(scores));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h1>字符编码</h1>
<ul>
<li>统一全球的编码Unicode编码需要两个或者更多字节表示，ASCII一个字节、GB2312两个字节。</li>
<li>UTF-8把固定长度的Unicode编码变成1～4字节的变长编码。编码依靠高字节位来确定一个字符究竟是几个字节，用来作为传输编码。</li>
<li>转换编码后，就不再是char类型，而是byte类型表示的数组。</li>
</ul>
<h4 id="始终牢记：Java的String和char在内存中总是以Unicode编码表示。"><a class="header-anchor" href="#始终牢记：Java的String和char在内存中总是以Unicode编码表示。">¶</a>始终牢记：Java的String和char在内存中总是以Unicode编码表示。</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b1 = <span class="string">"Hello"</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"GBK"</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b3 = <span class="string">"Hello"</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="comment">//将字节码转回String类型</span></span><br><span class="line"><span class="keyword">byte</span>[] b = ...</span><br><span class="line">String s1 = <span class="keyword">new</span> String(b, <span class="string">"GBK"</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure>
<pre><code>而较新的JDK版本的String则以byte[]存储：如果String仅包含ASCII字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的String通常仅包含ASCII字符：
</code></pre>
<h2 id="￼17"><a class="header-anchor" href="#￼17">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure></h2>
<h1>StringBuilder</h1>
<p>s = s + “,” + i;可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。<br>
StringBuilder，它是一个可变对象，可以预分配缓冲区，新增字符时，不会创建新的临时对象：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//申请缓冲区空间</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//用append增加字符串</span></span><br><span class="line">    sb.append(<span class="string">','</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转成字符串</span></span><br><span class="line">String s = sb.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以链式操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">"Mr "</span>)</span><br><span class="line">          .append(<span class="string">"Bob"</span>)</span><br><span class="line">          .append(<span class="string">"!"</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">"Hello, "</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式操作的关键是，append()方法会返回this，从而不断调用自身。</p>
<p>注意：对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。</p>
<h2 id="StringBuilder和StringBuffer接口完全相同，同步会带来执行速度的下降，现在完全没有必要使用StringBuffer。"><a class="header-anchor" href="#StringBuilder和StringBuffer接口完全相同，同步会带来执行速度的下降，现在完全没有必要使用StringBuffer。">¶</a>StringBuilder和StringBuffer接口完全相同，同步会带来执行速度的下降，现在完全没有必要使用StringBuffer。</h2>
<h1>StringJoiner</h1>
<p>连接字符串数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"Grace"</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">", "</span>, <span class="string">"Hello "</span>, <span class="string">"!"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定连接符， 开头，结尾</span></span><br></pre></td></tr></table></figure>
<p>其源码内部就是用StringBuilder实现的。<br>
String.join()：静态方法，其内部是用StringJoiner实现的，但是不能加开头和结尾。</p>
<h2 id="￼20"><a class="header-anchor" href="#￼20">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"Grace"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> s = String.join(<span class="string">", "</span>, names);</span><br></pre></td></tr></table></figure></h2>
<h1>包装类型 Wrapper class</h1>
<p>Java的数据类型分两种：</p>
<ul>
<li>基本类型：byte，short，int，long，boolean，float，double，char</li>
<li>引用类型：所有class和interface类型<br>
引用类型可以为null，基本类型不行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        Integer n1 = <span class="keyword">new</span> Integer(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        Integer n2 = Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        Integer n3 = Integer.valueOf(<span class="string">"100"</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Auto-Boxing"><a class="header-anchor" href="#Auto-Boxing">¶</a>Auto Boxing</h2>
<p>Java编译器可以帮助我们自动在int和Integer之间转型(自动包装，自动拆箱)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将int变为Integer赋值：auto boxing</span></span><br><span class="line">Integer n = <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="keyword">int</span> x = n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。</li>
<li>自动拆箱执行时可能会报NullPointerException。将null值的Integer赋值给int。</li>
</ul>
<h2 id="所有包装类型都是不变类"><a class="header-anchor" href="#所有包装类型都是不变类">¶</a>所有包装类型都是不变类</h2>
<p>一旦创建了Integer()类型就是用不变的。Integer必须用equals()比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">127</span>;</span><br><span class="line">        Integer y = <span class="number">127</span>;</span><br><span class="line">        Integer m = <span class="number">99999</span>;</span><br><span class="line">        Integer n = <span class="number">99999</span>;</span><br><span class="line">        System.out.println(<span class="string">"x == y: "</span> + (x==y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"m == n: "</span> + (m==n)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"x.equals(y): "</span> + x.equals(y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"m.equals(n): "</span> + m.equals(n)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。<br>
方法1：Integer n = new Integer(100);<br>
方法2：Integer n = Integer.valueOf(100);</p>
<ul>
<li>方法2更好，Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</li>
<li>创建新对象时，尽量使用静态工厂方法，而不是使用new操作符。</li>
</ul>
<h2 id="进制转换"><a class="header-anchor" href="#进制转换">¶</a>进制转换</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Integer将String解析成整数</span></span><br><span class="line"><span class="keyword">int</span> x1 = Integer.parseInt(<span class="string">"100"</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">int</span> x2 = Integer.parseInt(<span class="string">"100"</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将整数格式化成特定字符</span></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// "100",表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// "2s",表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// "64",表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// "144",表示为8进制</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// "1100100",表示为2进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内存中总是以二进制的形式存在，比如int是4字节二进制。<br>
System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示。</p>
<ul>
<li>程序设计的重要原则： 存储和显示相分离</li>
<li>所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型。</li>
</ul>
<h2 id="无符号整型"><a class="header-anchor" href="#无符号整型">¶</a>无符号整型</h2>
<h2 id="￼25-还可以将int转成无符号short，short转成无符号long。"><a class="header-anchor" href="#￼25-还可以将int转成无符号short，short转成无符号long。">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将byte转为无符号int</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> y = <span class="number">127</span>;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>
还可以将int转成无符号short，short转成无符号long。</h2>
<h1>JavaBean</h1>
<ul>
<li>class中，一般private定义字段，public方法访问字段。如果class的属性(property)读(getter)写(setter)方法满足：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getXyz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXyz</span><span class="params">(Type value)</span></span></span><br></pre></td></tr></table></figure>
<p>这种class即为JavaBean。</p>
<ul>
<li>boolean字段比较特殊，它的读方法一般命名为isXyz()：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="keyword">boolean</span> value)</span></span></span><br></pre></td></tr></table></figure>
<p>只有setter称为（write-only），只有getter称为（read-only）。</p>
<ul>
<li>使用Introspector.getBeanInfo()可以获取属性列表。</li>
</ul>
<h2 id="￼28"><a class="header-anchor" href="#￼28">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.*;</span><br></pre></td></tr></table></figure></h2>
<h1>枚举类</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekdays&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类时，编译器能自动检查某个值是否在枚举的集合中。</p>
<ul>
<li>可以检查出类型</li>
<li>不可以引用非枚举类型的值</li>
<li>不同类型的枚举不能互相比较或者赋值</li>
</ul>
<h3 id="enum的比较"><a class="header-anchor" href="#enum的比较">¶</a>enum的比较</h3>
<p>引用类型只能用equals()，但是enum可以用==，因为enum的每一个常量在JVM只有一个实例。</p>
<h3 id="enum类型"><a class="header-anchor" href="#enum类型">¶</a>enum类型</h3>
<ul>
<li>enum继承自Java.lang.Enum，且无法被继承。</li>
<li>无法通过new创建enum的实例</li>
<li>enum可以用switch</li>
</ul>
<h3 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回常量名</span></span><br><span class="line">String s = Weekday.SUN.name(); <span class="comment">// "SUN"</span></span><br><span class="line"><span class="comment">//返回顺序</span></span><br><span class="line"><span class="keyword">int</span> n = Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>可以给枚举类型添加字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Work at home!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Work at office!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以覆写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Today is "</span> + day + <span class="string">". Work at home!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Today is "</span> + day + <span class="string">". Work at office!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">"星期一"</span>), TUE(<span class="number">2</span>, <span class="string">"星期二"</span>), WED(<span class="number">3</span>, <span class="string">"星期三"</span>), THU(<span class="number">4</span>, <span class="string">"星期四"</span>), FRI(<span class="number">5</span>, <span class="string">"星期五"</span>), SAT(<span class="number">6</span>, <span class="string">"星期六"</span>), SUN(<span class="number">0</span>, <span class="string">"星期日"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue, String chinese)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="keyword">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>注意，判断枚举常量的名字一定要用name()，不可以用toString()</b></p>
<h3 id="Switch"><a class="header-anchor" href="#Switch">¶</a>Switch</h3>
<h2 id="￼33-加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。"><a class="header-anchor" href="#￼33-加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">"Today is "</span> + day + <span class="string">". Work at office!"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">"Today is "</span> + day + <span class="string">". Work at home!"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"cannot process "</span> + day);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>
加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</h2>
<h1>BigInteger</h1>
<p>Cpu最大的范围是64位long，可以通过Cpu指令直接计算。<br>
超过long的范围，用java.math.BigInteger类型，其内部用一个int[]模拟非常大的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br><span class="line"><span class="comment">//运算时</span></span><br><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">"12345678901234567890"</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br><span class="line"><span class="comment">//转换类型</span></span><br><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">"123456789000"</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure>
<p>其也是不变类，继承自number。<br>
转换为byte：byteValue()<br>
转换为short：shortValue()<br>
转换为int：intValue()<br>
转换为long：longValue()<br>
转换为float：floatValue()<br>
转换为double：doubleValue()</p>
<h2 id="BigDecimal"><a class="header-anchor" href="#BigDecimal">¶</a>BigDecimal</h2>
<h2 id="用scale-表示小数位数，返回负数则表示是整数，大小为后面有几个0-使用equals也要注意scale的值相等才行。BigDecimal是用一个BigInteger和scale表示的。"><a class="header-anchor" href="#用scale-表示小数位数，返回负数则表示是整数，大小为后面有几个0-使用equals也要注意scale的值相等才行。BigDecimal是用一个BigInteger和scale表示的。">¶</a>用scale()表示小数位数，返回负数则表示是整数，大小为后面有几个0.<br>
使用equals也要注意scale的值相等才行。<br>
BigDecimal是用一个BigInteger和scale表示的。</h2>
<h1>常用工具类</h1>
<h2 id="math"><a class="header-anchor" href="#math">¶</a>math</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求绝对值</span></span><br><span class="line">Math.abs(-<span class="number">100</span>)</span><br><span class="line"><span class="comment">//取最大最小值</span></span><br><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br><span class="line"><span class="comment">//计算n次方</span></span><br><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br><span class="line"><span class="comment">//计算根号</span></span><br><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br><span class="line"><span class="comment">//计算以e为底的对数</span></span><br><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br><span class="line"><span class="comment">//以10为底</span></span><br><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//三角函数</span></span><br><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br><span class="line"><span class="comment">//数学常量</span></span><br><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br><span class="line"><span class="comment">//随机数</span></span><br><span class="line">Math.random();</span><br><span class="line"><span class="comment">//[Max,Min）范围的随机数</span></span><br><span class="line"><span class="comment">// 区间在[MIN, MAX)的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = Math.random(); <span class="comment">// x的范围是[0,1)</span></span><br><span class="line">        <span class="keyword">double</span> min = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> max = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">double</span> y = x * (max - min) + min; <span class="comment">// y的范围是[10,50)</span></span><br><span class="line">        <span class="keyword">long</span> n = (<span class="keyword">long</span>) y; <span class="comment">// n的范围是[10,50)的整数</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Random"><a class="header-anchor" href="#Random">¶</a>Random</h2>
<p>创建伪随机数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定种子</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random(<span class="number">1234</span>);</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure>
<p>Math.random()内部也是调用了Random类</p>
<h2 id="secureRandom"><a class="header-anchor" href="#secureRandom">¶</a>secureRandom</h2>
<p>真随机数，安全随机数。SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象基础</title>
    <url>/2020/02/29/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<pre><code>面向对象编程，没有对象，怎么编程？？🤔
顺手把面向抽象，面向接口给学了。
</code></pre>
<a id="more"></a>
<h2 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h2>
<h3 id="private"><a class="header-anchor" href="#private">¶</a>private</h3>
<ul>
<li>private修饰field可以拒绝外部访问，但是可以通过内部方法来间接修改field</li>
<li>private修饰method则拒绝外部调用，但是可以通过内部方法来调用</li>
</ul>
<h3 id="this"><a class="header-anchor" href="#this">¶</a>this</h3>
<p>隐式的变量，通过this.field来访问当前instance的field。</p>
<h3 id="可变参数"><a class="header-anchor" href="#可变参数">¶</a>可变参数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String[] name;</span><br><span class="line">    <span class="comment">//String ... 相当于数组类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String... name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Hello c = <span class="keyword">new</span> Hello();</span><br><span class="line">        <span class="comment">//数组类型则要先定义好，再传入参数</span></span><br><span class="line">		<span class="comment">//String[] name = &#123;"asdf", "casdf"&#125;;</span></span><br><span class="line">        <span class="comment">//可变参数可以直接传递参数</span></span><br><span class="line">		c.setName(<span class="string">"asdf"</span>, <span class="string">"casdf"</span>); </span><br><span class="line">		System.out.println(Arrays.toString(c.name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用方可以调用null，但是可变参数不可以，因为传入0个参数时，实际传入的是一个空数组。</li>
</ul>
<h3 id="参数绑定"><a class="header-anchor" href="#参数绑定">¶</a>参数绑定</h3>
<h4 id="基本类型参数的传递"><a class="header-anchor" href="#基本类型参数的传递">¶</a>基本类型参数的传递</h4>
<p>传递的是数据的拷贝。双方各自的后续修改，互不影响。</p>
<h4 id="引用类型参数的传递"><a class="header-anchor" href="#引用类型参数的传递">¶</a>引用类型参数的传递</h4>
<ol>
<li>传递的是对象地址的拷贝。Java的参数是以值的形式传入方法中，而不是引用传递。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</li>
<li>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响.</li>
</ol>
<h2 id="￼1"><a class="header-anchor" href="#￼1">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        String bob = <span class="string">"Bob"</span>;</span><br><span class="line">        p.setName(bob); <span class="comment">// 传入bob变量</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Bob"</span></span><br><span class="line">        bob = <span class="string">"Alice"</span>; <span class="comment">// bob改名为Alice</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Bob"还是"Alice"?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="构造方法：初始化实例"><a class="header-anchor" href="#构造方法：初始化实例">¶</a>构造方法：初始化实例</h2>
<pre><code>构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。
</code></pre>
<ul>
<li>编译器会自动创建构造方法。自定义了就不会再生成。</li>
<li>没有在构造方法中初始化field时，引用类型的field默认是null，数值类型的field用默认值，int类型默认值是0，布尔类型默认值是false</li>
</ul>
<h3 id="多构造方法"><a class="header-anchor" href="#多构造方法">¶</a>多构造方法</h3>
<p>系统会自动匹配。构造方法可以调用其他构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"Unnamed"</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法重载overload"><a class="header-anchor" href="#方法重载overload">¶</a>方法重载overload</h3>
<pre><code>功能类似，方法名相同，参数不同。
</code></pre>
<hr>
<h2 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用extends关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person：超类（super class），父类（parent class），基类（base class）。<br>
Student：子类（subclass），扩展类（extended class）。</p>
<h3 id="继承树"><a class="header-anchor" href="#继承树">¶</a>继承树</h3>
<p>在Java中，没有明确写extends的类都会被自动加上extends Object。一个子类自能继承自一个父类。</p>
<h3 id="访问权限"><a class="header-anchor" href="#访问权限">¶</a>访问权限</h3>
<p>子类不能访问父类的private fields和methods。<br>
protected可以字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问。</p>
<h3 id="super"><a class="header-anchor" href="#super">¶</a>super</h3>
<ul>
<li>子类引用父类的fields时用。</li>
<li>如果父类没有默认的构造方法（父类有自定义构造方法），子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。</li>
<li>子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转型"><a class="header-anchor" href="#转型">¶</a>转型</h3>
<pre><code>引用类型的声明和对象类型可以不同。
可以upcasting不可以downcasting，可以将子类转型成父类，不可以将父类转型成子类，多出来的功能不可能凭空增加。
</code></pre>
<ul>
<li>转型失败的时候，Java虚拟机会报ClassCastException。</li>
<li>可以用instanceof先判断，其实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">    Student s = (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承和组合"><a class="header-anchor" href="#继承和组合">¶</a>继承和组合</h3>
<p>student继承自person，可以拥有一个book实例。</p>
<h2 id="￼6"><a class="header-anchor" href="#￼6">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="多态"><a class="header-anchor" href="#多态">¶</a>多态</h2>
<h3 id="覆写override"><a class="header-anchor" href="#覆写override">¶</a>覆写override</h3>
<p>子类的方法名，参数与父类的相同，返回值也相同则是override。否则是overload。@Override可以让编译器帮助检查是否进行了正确的覆写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// Compile error!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String s)</span> </span>&#123;&#125; <span class="comment">//参数名不同，overload</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>那么，一个实际类型为Student，引用类型为Person的变量，调用其run()方法，调用的是Person还是Student的run()方法？
调用的为实际类型Student的方法。
</code></pre>
<h3 id="多态-v2"><a class="header-anchor" href="#多态-v2">¶</a>多态</h3>
<pre><code>定义：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。
多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。
通过override，允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。
</code></pre>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> Income[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Income(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> Salary(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> StateCouncilSpecialAllowance(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Income</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateCouncilSpecialAllowance</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="覆写Object方法"><a class="header-anchor" href="#覆写Object方法">¶</a>覆写Object方法</h3>
<p>object类中重要的方法：<br>
.toString(): 把instance输出为String();<br>
.equals(): 判断两个instances是否逻辑相等;<br>
.hashCode(): 计算一个instance的哈希值;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 显示更有意义的字符串:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person:name="</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较是否相等:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当且仅当o为Person类型:</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person p = (Person) o;</span><br><span class="line">            <span class="comment">// 并且name字段相同时，返回true:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算hash:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用super"><a class="header-anchor" href="#调用super">¶</a>调用super</h3>
<p>在子类的覆写方法中, 调用父类被覆写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student extends Person &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的hello()方法:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hello() + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常量final"><a class="header-anchor" href="#常量final">¶</a>常量final</h3>
<p>父类的方法不允许override：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student extends Person &#123;</span><br><span class="line">    <span class="comment">// compile error: 不允许覆写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>final用于初始化值，则这个变量不再可以修改。可以通过构造方法或者代码块来进行初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="￼13"><a class="header-anchor" href="#￼13">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"><span class="comment">//初始化局部变量，则不可修改。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="抽象类"><a class="header-anchor" href="#抽象类">¶</a>抽象类</h2>
<p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，则可以用abstract。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类中有抽象方法，则这个类无法被实例化，编译器会无法编译这个类。除非person类也声明abstract。</p>
<h3 id="抽象类-v2"><a class="header-anchor" href="#抽象类-v2">¶</a>抽象类</h3>
<p>抽象类无法被实例化。抽象类的设计本身就是被继承，抽象类强迫子类覆写其定义的抽象方法，否则报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//abstract声明</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面向抽象编程"><a class="header-anchor" href="#面向抽象编程">¶</a>面向抽象编程</h3>
<p>尽量引用高层类型，而不引用子类。</p>
<ul>
<li>上层代码只定义规范（例如：abstract class Person）；</li>
<li>不需要子类就可以实现业务逻辑（正常编译）；</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心。<br>
抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现</li>
</ul>
<hr>
<h1>接口</h1>
<pre><code>如果一个抽象类没有字段，全是抽象的方法，则可用interface改写成接口。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个class实现接口：用implements(实现)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多接口"><a class="header-anchor" href="#多接口">¶</a>多接口</h2>
<p>可以实现多个interface：本来是不能继承多个的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Hello</span> </span>&#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口继承"><a class="header-anchor" href="#接口继承">¶</a>接口继承</h2>
<p>一个接口可以继承自另一接口，用extends。</p>
<h2 id="继承关系"><a class="header-anchor" href="#继承关系">¶</a>继承关系</h2>
<p>充分的复用代码，参考集合类定义的一组接口：<br>
<img src="/.io//%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="继承关系"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总是用更抽象的类来引用实际类型。</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 用List接口引用具体子类的实例</span></span><br><span class="line">Collection coll = list; <span class="comment">// 向上转型为Collection接口</span></span><br><span class="line">Iterable it = coll; <span class="comment">// 向上转型为Iterable接口</span></span><br></pre></td></tr></table></figure>
<h2 id="default方法"><a class="header-anchor" href="#default方法">¶</a>default方法</h2>
<p>实现类可以不必实现default方法。其目的：<br>
给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。</li>
</ul>
<hr>
<h1>静态字段和静态方法</h1>
<pre><code>静态字段和静态方法是属于class而不是intances的。
</code></pre>
<h2 id="静态字段"><a class="header-anchor" href="#静态字段">¶</a>静态字段</h2>
<p>静态字段是同一个class所有实例共享的，实例中并没有静态字段，不推荐用 实例名.静态字段 来访问，因为编译器是根据实例类型自动转换为类名.静态字段来访问静态对象。</p>
<h2 id="静态方法"><a class="header-anchor" href="#静态方法">¶</a>静态方法</h2>
<p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。</p>
<h2 id="用途"><a class="header-anchor" href="#用途">¶</a>用途</h2>
<ol>
<li>静态方法经常用于工具类。例如：<br>
Arrays.sort()<br>
Math.random()</li>
<li>静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。</li>
</ol>
<h2 id="接口的静态字段"><a class="header-anchor" href="#接口的静态字段">¶</a>接口的静态字段</h2>
<p>interface是可以有静态字段的，并且静态字段必须为final类型：</p>
<h2 id="￼21"><a class="header-anchor" href="#￼21">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static + final</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//都去掉也可以，编译器会自动补上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h1>包packages</h1>
<p>使用package来解决名字冲突。JVM只看完整类名，因此，只要包名不同，类就不同。</p>
<ul>
<li>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</li>
</ul>
<h2 id="包作用域"><a class="header-anchor" href="#包作用域">¶</a>包作用域</h2>
<h2 id="同一个包中，不用public、protected、private修饰的字段和方法就是包作用域。一般使用倒置的域名来确保唯一性。"><a class="header-anchor" href="#同一个包中，不用public、protected、private修饰的字段和方法就是包作用域。一般使用倒置的域名来确保唯一性。">¶</a>同一个包中，不用public、protected、private修饰的字段和方法就是包作用域。<br>
一般使用倒置的域名来确保唯一性。</h2>
<h1>作用域</h1>
<ul>
<li>public: field、method可以被其他类访问，前提是首先有访问class的权限。</li>
<li>private: 访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面。Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限。</li>
<li>protected：作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类</li>
</ul>
<ul>
<li>一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。</li>
</ul>
<hr>
<h1>classpath和jar</h1>
<h2 id="classpath"><a class="header-anchor" href="#classpath">¶</a>classpath</h2>
<pre><code>JVM用到的环境变量，用于搜索class文件的目录。
要在JVM启动时设置环境变量，没有设置则默认为当前目录。
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>
<ul>
<li>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</li>
</ul>
<h2 id="jar"><a class="header-anchor" href="#jar">¶</a>jar</h2>
<pre><code>把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件.
</code></pre>
<p>MANIFEST.MF文件可以提供jar包的信息，如Main-Class，这样可以直接运行jar包。</p>
<h2 id="￼23-MANIFEST-MF文件里配置classpath"><a class="header-anchor" href="#￼23-MANIFEST-MF文件里配置classpath">¶</a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure><br>
MANIFEST.MF文件里配置classpath.</h2>
<h1>模块</h1>
<p>JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫rt.jar。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门</title>
    <url>/2020/02/28/java%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Cloud computing要用到Java，正好打算学习后端开发，就从Java开始入门，慢慢学，慢慢更新,先开个坑。</p>
<a id="more"></a>
<h1>基本知识</h1>
<h2 id="代码块规范："><a class="header-anchor" href="#代码块规范：">¶</a>代码块规范：</h2>
<ul>
<li>类名首字母要大写</li>
<li>public static void main(String[] args){} 方法是固定入口</li>
<li>方法的代码每一行都要以；结尾</li>
<li>类名和文件名必须保持一致</li>
<li>区分大小写！</li>
</ul>
<h2 id="运行原理："><a class="header-anchor" href="#运行原理：">¶</a>运行原理：</h2>
<pre><code>javac编译器先把.java文件编译成.class的字节码文件，然后向java虚拟机传递类名，查找到对应文件然后运行。
</code></pre>
<h2 id="基本数据类型"><a class="header-anchor" href="#基本数据类型">¶</a>基本数据类型</h2>
<pre><code>整数类型：byte(一个字节)，short（2），int（4），long（8）
浮点数类型：float（float型后缀加f）[最大可表示10^38]，double[10^308]
字符类型：char（使用单引号）
布尔类型：boolean (在JVM里是4字节整数)
*常量*： 类型名前加final, 避免魔术数字，通常全部大写
var关键字：类名太长，编译器自动判断变量类型
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>
<ul>
<li>变量的作用域：{}</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 变量i从这里开始定义</span></span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// 变量x从这里开始定义</span></span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            String s = <span class="string">"hello"</span>; <span class="comment">// 变量s从这里开始定义</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="comment">// 变量s作用域到此结束</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 注意，这是一个新的变量s，它和上面的变量同名，</span></span><br><span class="line">        <span class="comment">// 但是因为作用域不同，它们是两个不同的变量:</span></span><br><span class="line">        String s = <span class="string">"hi"</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="comment">// 变量x和s作用域到此结束</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 变量i作用域到此结束</span></span><br></pre></td></tr></table></figure>
<p>要遵循作用域最小的原则，且变量不用重名。</p>
<h2 id="整数运算"><a class="header-anchor" href="#整数运算">¶</a>整数运算</h2>
<p>%：取余</p>
<ul>
<li>位移运算：右移（相当于除以2） &gt;&gt; （符号位不动，&gt;&gt;&gt;（符号位跟着动）<br>
<em>要小心溢出，注意数据类型</em></li>
<li>位运算： 与：&amp;， 或：｜， 非：～ 异或：^，不同为1，同为。<br>
整数的位运算是按位对齐做位运算。通过与运算可以快速判断两个IP是否在同一个网段。</li>
<li>强制类型转换：（short）</li>
</ul>
<h2 id="浮点型"><a class="header-anchor" href="#浮点型">¶</a>浮点型</h2>
<p>浮点型的比较，将两数的差的绝对值小于某一范围，即可认为相等。<br>
浮点型四舍五入时，+0.5，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">2.6</span>;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) (d + <span class="number">0.5</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>整型相除时，要先进行类型转换，否则会只留下整数位</li>
</ul>
<h2 id="布尔类型"><a class="header-anchor" href="#布尔类型">¶</a>布尔类型</h2>
<p>运算有 与&amp;&amp;，或||,非！，注意跟整型运算的区别。</p>
<h3 id="三元运算符"><a class="header-anchor" href="#三元运算符">¶</a>三元运算符</h3>
<p>b ? x:y</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x,y的类型必须相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = -<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> x = n &gt;= <span class="number">0</span> ? n : -n;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为true时调用表达式1，为false时调用表达式2。</p>
<h2 id="字符字符串"><a class="header-anchor" href="#字符字符串">¶</a>字符字符串</h2>
<ul>
<li>char: 保存一个unicode字符，英文和中文都占用2个字节，’’</li>
<li>String： “”, 可以用+连接任意字符串和其他数据类型。<br>
“”&quot;… “”&quot;表示多行字符串，但是要用Java13特性，编译的时候；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac --<span class="built_in">source</span> 13 --<span class="built_in">enable</span>-preview Main.java</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串不可变：字符串是引用类型，字符串的内容是不变的，变量的本质是一个指针</li>
<li>null: 空值，指针指向空</li>
</ul>
<h2 id="数组类型"><a class="header-anchor" href="#数组类型">¶</a>数组类型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        <span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//自动推算长度</span></span><br><span class="line">        <span class="keyword">int</span>[] ns1 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        <span class="comment">//简写</span></span><br><span class="line">        <span class="keyword">int</span>[] ns2 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">        ns[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">//查看数组长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组大小不可变，同理字符串，变量的本质是指针</li>
</ul>
<h3 id="字符串数组"><a class="header-anchor" href="#字符串数组">¶</a>字符串数组</h3>
<p>数组的元素是引用类型时，</p>
<h2 id="￼6"><a class="header-anchor" href="#￼6">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] StrArray = &#123;<span class="string">"as"</span>,<span class="string">"asv"</span>&#125;;</span><br></pre></td></tr></table></figure></h2>
<h1>流程控制</h1>
<h2 id="输入输出"><a class="header-anchor" href="#输入输出">¶</a>输入输出</h2>
<h3 id="格式化输出-System-out-printf"><a class="header-anchor" href="#格式化输出-System-out-printf">¶</a>格式化输出: System.out.printf()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">        System.out.printf(<span class="string">"%.2f\n"</span>, d); <span class="comment">// 显示两位小数3.14</span></span><br><span class="line">        System.out.printf(<span class="string">"%.4f\n"</span>, d); <span class="comment">// 显示4位小数3.1416</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:right">占位符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">%d</td>
<td style="text-align:left">格式化输出整数</td>
</tr>
<tr>
<td style="text-align:right">%x</td>
<td style="text-align:left">格式化输出十六进制整数</td>
</tr>
<tr>
<td style="text-align:right">%f</td>
<td style="text-align:left">格式化输出浮点数</td>
</tr>
<tr>
<td style="text-align:right">%e</td>
<td style="text-align:left">格式化输出科学计数法表示的浮点数</td>
</tr>
<tr>
<td style="text-align:right">%s</td>
<td style="text-align:left">格式化字符串</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//16进制输出用0补足8位</span></span><br><span class="line">System.out.printf(<span class="string">"n=%d, hex=%08x"</span>, n, n); <span class="comment">// 注意，两个%占位符必须传入两个数</span></span><br></pre></td></tr></table></figure>
<h3 id="输入"><a class="header-anchor" href="#输入">¶</a>输入</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">//导入控制台库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">"Input your name: "</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        String name = scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">"Input your age: "</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="keyword">int</span> age = scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">"Hi, %s, you are %d\n"</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="if语句"><a class="header-anchor" href="#if语句">¶</a>if语句</h2>
<ul>
<li>判断相等一定要范围，否则浮点型不准确：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">1</span> - <span class="number">9.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x - <span class="number">0.1</span>) &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"x is 0.1"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"x is NOT 0.1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>要判断引用类型的变量内容是否相等，必须使用equals()方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1 != <span class="keyword">null</span> &amp;&amp;s1.equals(s2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"相等"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"不等"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果变量s1为null，则会报错，所以要&amp;&amp;。</p>
<h2 id="switch"><a class="header-anchor" href="#switch">¶</a>switch</h2>
<p>旧版的switch：具有穿透性，只负责匹配，匹配成功将继续向下匹配。所以不能漏泄break；<br>
新版的switch: 自动break；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String option = <span class="string">"apple"</span>;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="keyword">switch</span>(option)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"apple"</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"peer"</span>,<span class="string">"banana"</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//可以用&#123;&#125;框住，执行多条语句。</span></span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> code = fruit.hashCode();</span><br><span class="line">                yield code; <span class="comment">//返回code值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">//赋值语句要以；结束， 没赋值就不用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>switch也是java13的新特性：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac --<span class="built_in">source</span> 13 --<span class="built_in">enable</span>-preview Main.java</span><br></pre></td></tr></table></figure>
<h2 id="while"><a class="header-anchor" href="#while">¶</a>while</h2>
<ul>
<li>死循环中，int自增到最大再加一会变成负数，从而跳出循环。</li>
<li>do … while是先执行再判断，所以至少会执行一次。要注意边界问题。</li>
</ul>
<h2 id="for"><a class="header-anchor" href="#for">¶</a>for</h2>
<ul>
<li>注意：循环中定义的变量的作用域只在循环中，循环外将无法访问。</li>
</ul>
<h3 id="for-each"><a class="header-anchor" href="#for-each">¶</a>for each</h3>
<p>便于遍历数组，但是无法获得数组的索引:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">int</span> ns[] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n:ns)&#123;</span><br><span class="line">            sum = sum +n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for each能遍历所有可迭代的对象，包括list，map…</li>
</ul>
<h3 id="i-i"><a class="header-anchor" href="#i-i">¶</a>i++,++i</h3>
<p>在循环体中，i<ins>和</ins>i的作用是一样的。<br>
运行时间的差别。在Java中i<ins>语句是需要一个临时变量取存储返回自增前的值，而</ins>i不需要。这样就导致使用i++时系统需要先申请一段内存空间，然后将值塞如进去，最后不用了才去释放。多了这么一系列操作时间。</p>
<h2 id="break和continue"><a class="header-anchor" href="#break和continue">¶</a>break和continue</h2>
<pre><code>break：跳出一层循环。
continue： 提前结束本次循环，进入下一次循环。
</code></pre>
<hr>
<h1>数组操作</h1>
<p>遍历数组就不说了，需要索引用for，不需要索引用for each。</p>
<h2 id="打印数组内容"><a class="header-anchor" href="#打印数组内容">¶</a>打印数组内容</h2>
<p>直接打印数组，获得的是JVM中的引用地址<br>
可以用for each循环打印，也可以用Arrays.toString()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组排序"><a class="header-anchor" href="#数组排序">¶</a>数组排序</h2>
<p>用Arrays.sort()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        Arrays.sort(ns); <span class="comment">//排序</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多维数组"><a class="header-anchor" href="#多维数组">¶</a>多维数组</h2>
<p>数组是引用类型，将引用类型又存入一个数组，就成了二维数组。<br>
访问二维数组：array[row][col]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二维数组的声明是两个方括号</span></span><br><span class="line">        <span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;; <span class="comment">//赋值后面要加；</span></span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">//用Arrays.deepToString(ns)打印数组</span></span><br><span class="line">        System.out.println(Arrays.deepToString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命令行参数"><a class="header-anchor" href="#命令行参数">¶</a>命令行参数</h2>
<p>Java程序的入口main()方法可以接受一个 String[]数组类型的命令行参数。<br>
这个命令行参数由JVM接收用户输入并传给main方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java Main -version</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git一文通</title>
    <url>/2020/02/26/Git_learning/</url>
    <content><![CDATA[<h1>Git</h1>
<pre><code>免费分布式版本管理系统。相比于集中式管理的CVS，SVN：不必联网修改，强大的分支管理。更关键的是：Git跟踪并管理的是文件的修改，减少了上传量
</code></pre>
<a id="more"></a>
<h2 id="创建版本库"><a class="header-anchor" href="#创建版本库">¶</a>创建版本库</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step 0: 初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># step 1: 将文件加入仓库</span></span><br><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt file3.txt</span><br><span class="line"><span class="comment"># step 2：提交（可以一次提交多个文件） -m表示添加说明</span></span><br><span class="line">git commit -m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure>
<h2 id="版本回退"><a class="header-anchor" href="#版本回退">¶</a>版本回退</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看版本日志</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment">#一堆乱乱的字符是十六进制的commit id，防止多人协作版本号冲突</span></span><br><span class="line"><span class="comment">#一行显示</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line"><span class="comment">#返回上一个版本 HEAD^ 上上个版本 HEAD^^</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"><span class="comment">#回到未来的那个被去掉的版本，找到commit id</span></span><br><span class="line">git reset --hard 1094a</span><br><span class="line">git reflog <span class="comment">#可以查看每次每次命令从而找到commit id</span></span><br></pre></td></tr></table></figure>
<h2 id="工作区和暂存区"><a class="header-anchor" href="#工作区和暂存区">¶</a>工作区和暂存区</h2>
<pre><code>工作区：每次的working directory, 比如/learngit
版本库：工作区中的隐藏目录 /learngit/.git
暂存区：版本库中的stage(index)。暂存区自动创建第一个分支 master， 并创建一个指针head指向master。
工作流程：git add的时候将文件的修改存入暂存区，git commit将暂存区的所有内容提交到当前分支
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看stage</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#查看工作区和版本库里文件的不同</span></span><br><span class="line">git diff HEAD -- readme.txt</span><br></pre></td></tr></table></figure>
<h2 id="撤销修改"><a class="header-anchor" href="#撤销修改">¶</a>撤销修改</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Level 1: 返回到修改的上一个状态</span></span><br><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure>
<p>有两种情况：<br>
一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>
一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>
（后续的分支管理，也会有check out， <em>–</em> 这个很关键）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Level 2: 可以从暂存区回退至工作区，HEAD表示最新版本</span></span><br><span class="line">git reset HEAD readme.txt</span><br><span class="line"><span class="comment">#再接上 git checkout --readme.txt 彻底消失</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Level 3: 版本回退</span></span><br></pre></td></tr></table></figure>
<h2 id="删除文件"><a class="header-anchor" href="#删除文件">¶</a>删除文件</h2>
<ol>
<li>确实删除文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在工作区删除了文件</span></span><br><span class="line">rm test.txt</span><br><span class="line"><span class="comment">#git status会提</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#在版本库里删除文件</span></span><br><span class="line">it rm test.txt</span><br><span class="line"><span class="comment">#确认提交</span></span><br><span class="line">git commit -m <span class="string">"remove test.txt"</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>误删了</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用返回上一个状态来还原，其实是从版本库中替换回来</span></span><br><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库"><a class="header-anchor" href="#远程仓库">¶</a>远程仓库</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在git库里添加sshkey</span></span><br><span class="line">ssh-add <span class="string">"你的 id-rsa 文件地址"</span></span><br><span class="line"><span class="comment">#将本地内容推送到远程 远程库名字：origin</span></span><br><span class="line">git remote add origin git@github.com:noonett/learngit.git</span><br><span class="line"><span class="comment">#将github仓库的内容git pull下来</span></span><br><span class="line">git pull origin master --allow-unrelated-histories</span><br><span class="line"><span class="comment">#将本地库master分支推送到远端， </span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="comment">#-u是关联起来，之后就可以不带-u了</span></span><br></pre></td></tr></table></figure>
<h2 id="￼8"><a class="header-anchor" href="#￼8">¶</a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#克隆仓库下来, 支持https和ssh，ssh是原生的速度更快</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;url&gt;</span><br></pre></td></tr></table></figure></h2>
<h2 id="分支管理"><a class="header-anchor" href="#分支管理">¶</a>分支管理</h2>
<pre><code>HEAD指向的是当前分支，master是主分支。创建新分支实际上就是创建一个新指针，每次修改，让指针往前一步，工作区的文件没有改变。合并分支实际就是把新分支跟master合并
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建新分支，-b表示切换到这个分支</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="comment">#查看当前分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="comment">#切换分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="comment">#合并分支</span></span><br><span class="line">git merge dev</span><br><span class="line"><span class="comment">#删除分支 delete （强行删除 -D）</span></span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>
<pre><code>如果合并有冲突，则需要修改文件，再重新提交。
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看合并分支图</span></span><br><span class="line">git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure>
<h3 id="bug管理"><a class="header-anchor" href="#bug管理">¶</a>bug管理</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存工作现场</span></span><br><span class="line">git stash</span><br><span class="line"><span class="comment">#查看工作现场</span></span><br><span class="line">git stash list</span><br><span class="line"><span class="comment">#恢复工作现场</span></span><br><span class="line">git stash apply</span><br><span class="line">git stash drop</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">git stash pop</span><br><span class="line"><span class="comment">#可以恢复指定现场</span></span><br><span class="line">git stash pop stash@&#123;&#125;</span><br><span class="line"><span class="comment">#复制一个修改到当前分支</span></span><br><span class="line">git cherry-pick &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<h3 id="多人合作"><a class="header-anchor" href="#多人合作">¶</a>多人合作</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看远程库 -v详情</span></span><br><span class="line">git remote -vg</span><br><span class="line"><span class="comment">#创建远程的dev分支到本地</span></span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line"><span class="comment">#远程仓库有新的提交起了冲突则需要pull下来，本地合并，解决冲突</span></span><br><span class="line">git pull</span><br><span class="line"><span class="comment">#如果提示no tracking information则：</span></span><br><span class="line"><span class="comment">#指定本地dev分支与远程origin/dev分支的链接，再pull</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure>
<h3 id="rebase"><a class="header-anchor" href="#rebase">¶</a>rebase</h3>
<ul>
<li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li>
<li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。试得维护commit记录变得简单清晰。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase</span><br></pre></td></tr></table></figure>
<ul>
<li>远程push master，遇到了冲突，可以rebase来避免三方合并，即变基：</li>
</ul>
<h2 id="￼14"><a class="header-anchor" href="#￼14">¶</a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br><span class="line"><span class="comment">#rebase之后就修改冲突，然后continue（不用commit）</span></span><br><span class="line">git add readme.txt</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line"><span class="comment">#切换回master快速合并</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure></h2>
<h2 id="标签管理"><a class="header-anchor" href="#标签管理">¶</a>标签管理</h2>
<pre><code>给commit打上标签，便于版本管理。
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加标签 -a指代标签名 -m留下备注</span></span><br><span class="line">git tag -a v0.1 -m <span class="string">"version 0.1 released"</span> 1094adb</span><br><span class="line"><span class="comment">#查看标签</span></span><br><span class="line">git tag</span><br><span class="line"><span class="comment">#查看标签信息</span></span><br><span class="line">git show &lt;tagname&gt;</span><br><span class="line"><span class="comment">#删除标签</span></span><br><span class="line">git tag -d v0.1</span><br><span class="line"><span class="comment">#推送标签到远端</span></span><br><span class="line">git push origin v1.0</span><br><span class="line">git push origin --tags  <span class="comment">#推送所有的标签</span></span><br><span class="line"><span class="comment">#删除远程的标签</span></span><br><span class="line">git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵与Numpy</title>
    <url>/2020/02/24/Math/</url>
    <content><![CDATA[<h1>矩阵乘法实现</h1>
<pre><code>这个函数还是很简单的，就是对应位置相乘就完事了，最后再用numpy来确认一下函数的正确性。
</code></pre>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Matrix_multiplication</span><span class="params">(A,B, data = [])</span>:</span></span><br><span class="line">    C = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> A) <span class="keyword">or</span> (<span class="keyword">not</span> B):</span><br><span class="line">        <span class="keyword">return</span> C</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        row = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(B[<span class="number">0</span>])):</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(range(len(A[<span class="number">0</span>])),range(len(B))):</span><br><span class="line">                temp += A[i][a] * B[b][j]</span><br><span class="line">            row.append(temp)</span><br><span class="line">        C.append(row)</span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">        row.append(i+j)</span><br><span class="line">    A.append(row)</span><br><span class="line">print(<span class="string">'A:'</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> A:</span><br><span class="line">    print(row) </span><br><span class="line">    </span><br><span class="line">B = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">9</span>):</span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">        row.append(i+j)</span><br><span class="line">    B.append(row)</span><br><span class="line">print(<span class="string">'B:'</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> B:</span><br><span class="line">    print(row)</span><br></pre></td></tr></table></figure>
<pre><code>A:
[2, 3, 4, 5, 6, 7]
[3, 4, 5, 6, 7, 8]
[4, 5, 6, 7, 8, 9]
[5, 6, 7, 8, 9, 10]
[6, 7, 8, 9, 10, 11]
[7, 8, 9, 10, 11, 12]
B:
[3, 4, 5, 6, 7, 8]
[4, 5, 6, 7, 8, 9]
[5, 6, 7, 8, 9, 10]
[6, 7, 8, 9, 10, 11]
[7, 8, 9, 10, 11, 12]
[8, 9, 10, 11, 12, 13]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#A = []</span></span><br><span class="line">Matrix_multiplication(A,B)</span><br></pre></td></tr></table></figure>
<pre><code>[[166, 193, 220, 247, 274, 301],
 [199, 232, 265, 298, 331, 364],
 [232, 271, 310, 349, 388, 427],
 [265, 310, 355, 400, 445, 490],
 [298, 349, 400, 451, 502, 553],
 [331, 388, 445, 502, 559, 616]]
</code></pre>
<h1>Numpy</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>)])</span><br><span class="line">b = np.array([</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>)])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#矩阵乘法</span></span><br><span class="line">np.dot(a,b)</span><br></pre></td></tr></table></figure>
<pre><code>array([[166, 193, 220, 247, 274, 301],
       [199, 232, 265, 298, 331, 364],
       [232, 271, 310, 349, 388, 427],
       [265, 310, 355, 400, 445, 490],
       [298, 349, 400, 451, 502, 553],
       [331, 388, 445, 502, 559, 616]])
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#矩阵加减</span></span><br><span class="line">print(a + b)</span><br><span class="line"><span class="comment">#矩阵平方</span></span><br><span class="line">print(a**<span class="number">2</span>)</span><br><span class="line"><span class="comment">#矩阵转置</span></span><br><span class="line">print(a.T)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 5  7  9 11 13 15]
 [ 7  9 11 13 15 17]
 [ 9 11 13 15 17 19]
 [11 13 15 17 19 21]
 [13 15 17 19 21 23]
 [15 17 19 21 23 25]]
[[  4   9  16  25  36  49]
 [  9  16  25  36  49  64]
 [ 16  25  36  49  64  81]
 [ 25  36  49  64  81 100]
 [ 36  49  64  81 100 121]
 [ 49  64  81 100 121 144]]
[[ 2  3  4  5  6  7]
 [ 3  4  5  6  7  8]
 [ 4  5  6  7  8  9]
 [ 5  6  7  8  9 10]
 [ 6  7  8  9 10 11]
 [ 7  8  9 10 11 12]]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回逆矩阵</span></span><br><span class="line">c = np.array([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">print(np.linalg.inv(c))</span><br><span class="line"><span class="comment"># 矩阵的迹</span></span><br><span class="line">print(np.trace(c))</span><br></pre></td></tr></table></figure>
<pre><code>[[-2.   1. ]
 [ 1.5 -0.5]]
5.0
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 特征值和特征向量</span></span><br><span class="line">eigenvalues, eigenvector = np.linalg.eig(c)</span><br><span class="line">print(eigenvalues)</span><br><span class="line">print(eigenvector)</span><br></pre></td></tr></table></figure>
<pre><code>[-0.37228132  5.37228132]
[[-0.82456484 -0.41597356]
 [ 0.56576746 -0.90937671]]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取豆瓣电影前250的数据</title>
    <url>/2020/02/23/douban_movie-3/</url>
    <content><![CDATA[<pre><code>爬一下豆瓣top250的电影做一下练习，今天效率比较低只做了一点，明天做完再重构一下代码，用多线程实现。
2/24 封装了函数，最近得上课，慢慢更新了。
</code></pre>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> lxml</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br></pre></td></tr></table></figure>
<h1>发送请求</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#send request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_request</span><span class="params">(url, headers)</span>:</span></span><br><span class="line">    r = requests.get(url,headers=headers)</span><br><span class="line">    print(r.status_code)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h1>提取数据</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#fetch data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(resp, headers)</span>:</span></span><br><span class="line">    selector = lxml.etree.HTML(resp.text)    <span class="comment">#generate object</span></span><br><span class="line">    titles = selector.xpath(<span class="string">'//div[@class = "hd"]/a/span[1]/text()'</span>)<span class="comment">#fetching titles of movies       </span></span><br><span class="line">    urls = selector.xpath(<span class="string">'//div[@class = "hd"]/a/@href'</span>) <span class="comment">#fetching urls of description</span></span><br><span class="line">    <span class="comment">#visit the url to fetch the descriptions</span></span><br><span class="line">    movie_text = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        sub_r = requests.get(url,headers=headers)</span><br><span class="line">        selector = lxml.etree.HTML(sub_r.text)</span><br><span class="line">        url_text = <span class="string">' '</span>.join(selector.xpath(<span class="string">'//span[@property="v:summary"]/text()'</span>)).replace(<span class="string">' '</span>,<span class="string">''</span>).replace(<span class="string">'\n'</span>,<span class="string">''</span>).replace(<span class="string">'\u3000'</span>,<span class="string">''</span>)</span><br><span class="line">        movie_text.append(url_text)        </span><br><span class="line">    <span class="comment">#zip the content together</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    data.update(zip(titles,movie_text))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<h1>存入文件中</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        filepath = os.curdir</span><br><span class="line">        filename = <span class="string">'douban_top250.txt'</span>  </span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">'DouBan Movie--Top 250'</span>)</span><br><span class="line">            <span class="keyword">for</span> key,value <span class="keyword">in</span> data.items():</span><br><span class="line">                f.write(<span class="string">'\n\n'</span>)</span><br><span class="line">                f.write(key)</span><br><span class="line">                f.write(<span class="string">'\n'</span>)</span><br><span class="line">                f.write(value)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'Download error!!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Download success!!'</span>)</span><br></pre></td></tr></table></figure>
<h1>主函数</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#main, 循环实现翻页</span></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chro'</span></span><br><span class="line">                      <span class="string">'me/53.0.2785.104 Safari/537.36 Core/1.53.2372.400 QQBrowser/9.5.10548.400'</span></span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">data = &#123;&#125;</span><br><span class="line"><span class="keyword">while</span>(a != <span class="number">250</span>):</span><br><span class="line">    url =  <span class="string">"https://movie.douban.com/top250?start="</span>+ str(a) +<span class="string">"&amp;filter="</span></span><br><span class="line">    resp = send_request(url, headers)</span><br><span class="line">    data_chunk = fetch(resp, headers)</span><br><span class="line">    data.update(data_chunk)</span><br><span class="line">    a += <span class="number">25</span></span><br><span class="line">download(data)</span><br></pre></td></tr></table></figure>
<pre><code>200
200
200
200
200
200
200
200
200
200
Download success!!
</code></pre>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>beatiful-soup和lxml</title>
    <url>/2020/02/20/beatiful-soup/</url>
    <content><![CDATA[<p>beautiful soup是一个从html或xml文件中提取数据的python库，很方便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> beautifulsoup</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html_doc = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">'html.parser'</span>) <span class="comment">#创建一个soup对象</span></span><br><span class="line">print(soup.prettify()) <span class="comment">#标准格式输出</span></span><br></pre></td></tr></table></figure>
<h2 id="浏览结构化数据"><a class="header-anchor" href="#浏览结构化数据">¶</a>浏览结构化数据</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.title <span class="comment">#获取title</span></span><br><span class="line">soup.a.attrs <span class="comment">#取出a标签的树型</span></span><br><span class="line">soup.find(id=<span class="string">'link3'</span>) <span class="comment">#</span></span><br><span class="line"><span class="comment">#找到所有a标签的链接，find_all('')返回的是list</span></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">    print(link.get(<span class="string">'href'</span>))</span><br><span class="line">    <span class="comment"># http://example.com/elsie</span></span><br><span class="line">    <span class="comment"># http://example.com/lacie</span></span><br><span class="line">    <span class="comment"># http://example.com/tillie</span></span><br><span class="line">print(soup.get_text()) <span class="comment">#获取所有文字内容</span></span><br></pre></td></tr></table></figure>
<h2 id="支持css选择器"><a class="header-anchor" href="#支持css选择器">¶</a>支持css选择器</h2>
<h2 id="￼3"><a class="header-anchor" href="#￼3">¶</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.select(<span class="string">'.story'</span>) <span class="comment">#查找类名为story的类标签</span></span><br><span class="line">soup.select(<span class="string">'#link'</span>) <span class="comment">#tag id查找也可以</span></span><br></pre></td></tr></table></figure></h2>
<h1>lxml</h1>
<p>用lxml作为解析的引擎。底层是c写的，速度比较快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup_lxml = BeautifulSoup(html_doc, <span class="string">'lxml'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="xpath"><a class="header-anchor" href="#xpath">¶</a>xpath</h2>
<p>xpath的性能挺不错，xml文档中查找信息的语言。</p>
<h3 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h3>
<h4 id="Node-节点"><a class="header-anchor" href="#Node-节点">¶</a>Node: 节点</h4>
<p>元素，属性，文本，命名空间，文档（根）节点</p>
<h4 id="节点关系"><a class="header-anchor" href="#节点关系">¶</a>节点关系</h4>
<p>Parent 父<br>
Children 子<br>
Sibling：同胞，共用parent<br>
Ancestor：先辈<br>
Descendant：后代</p>
<h3 id="xpath语法"><a class="header-anchor" href="#xpath语法">¶</a>xpath语法</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodename</td>
<td style="text-align:center">选取此节点的所有子节点的文本</td>
</tr>
<tr>
<td>//</td>
<td style="text-align:center">从任意子节点中选取文本</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:center">从根节点中选取(已选择的节点的节点中)</td>
</tr>
<tr>
<td>.</td>
<td style="text-align:center">表示选取当前节点</td>
</tr>
<tr>
<td>…</td>
<td style="text-align:center">表示选取当前节点的父节点</td>
</tr>
<tr>
<td>@</td>
<td style="text-align:center">选取属性</td>
</tr>
</tbody>
</table>
<h2 id="￼5"><a class="header-anchor" href="#￼5">¶</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">r = requests.get(<span class="string">'http://iguye.com/books.xml'</span>)</span><br><span class="line">se = etree.HTML(r.text) <span class="comment">#创建一个选择器对象</span></span><br><span class="line">print(se.xpath(<span class="string">'//book'</span>)) <span class="comment">#//表示从任意子节点中选取</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book/author/text()'</span>)) <span class="comment">#选取书店下所有的书本的作者名字</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book/title/@lang'</span>))<span class="comment">#选取书店下所有的书本的语言信息</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[1]/title/text()'</span>)) <span class="comment">#第一本书</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[last()]/title/text()'</span>)) <span class="comment">#最后一本书</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[last()-1]/title/text()'</span>)) <span class="comment">#倒数第二本书</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[position()&lt;3]/title/text()'</span>)) <span class="comment">#前两本书</span></span><br><span class="line">print(se.xpath(<span class="string">'//book[@category="web"]/title/text()'</span>))<span class="comment">#选取所有分类为web的节点</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[price&gt;3]/price/text()'</span>))<span class="comment">#选取所有价格大于30.0元的书本</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[contains(@class,"book")]/@class/text()'</span>))<span class="comment">#类名中包含book的书本</span></span><br></pre></td></tr></table></figure></h2>
<h1>解析器比较</h1>
<p>re虽然速度最快，但是学习成本高。beautifulsoup则较慢。所有折中的方案选择lxml为佳。</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>requests</title>
    <url>/2020/02/19/requests/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br></pre></td></tr></table></figure>
<p>requests比标准库的urllib方便很多，代码也很简洁明了。</p>
<a id="more"></a>
<h1>发送请求</h1>
<h2 id="request发送get和post请求"><a class="header-anchor" href="#request发送get和post请求">¶</a>request发送get和post请求</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://api.github.com/events'</span>) <span class="comment">#发送get请求</span></span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;) <span class="comment">#发送post请求</span></span><br></pre></td></tr></table></figure>
<h2 id="传递url参数"><a class="header-anchor" href="#传递url参数">¶</a>传递url参数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: [<span class="string">'value2'</span>, <span class="string">'value3'</span>]&#125; <span class="comment">#可以添加一个列表</span></span><br><span class="line">r = requests.get(<span class="string">'https://api.github.com/events'</span>, params = payload) </span><br><span class="line">print(r.url) <span class="comment">#URL会被正确编码</span></span><br><span class="line"><span class="comment">#字典中的None值不会被添加到URL里</span></span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;) <span class="comment">#发送post请求</span></span><br><span class="line"><span class="comment">#http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</span></span><br></pre></td></tr></table></figure>
<h2 id="响应内容"><a class="header-anchor" href="#响应内容">¶</a>响应内容</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r.text    <span class="comment">#响应报文</span></span><br><span class="line">r.encoding <span class="comment">#查看编码方式</span></span><br><span class="line">r.encoding = <span class="string">'ISO-8859-1'</span> <span class="comment">#改变响应报文的编码方式</span></span><br><span class="line">r.content <span class="comment">#原本的报文</span></span><br><span class="line">r.json()  <span class="comment">#json解码</span></span><br></pre></td></tr></table></figure>
<h2 id="定制请求头"><a class="header-anchor" href="#定制请求头">¶</a>定制请求头</h2>
<h3 id="自定义user-agent"><a class="header-anchor" href="#自定义user-agent">¶</a>自定义user-agent</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ua = <span class="string">' Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Safari/605.1.15'</span></span><br><span class="line">headers = &#123;<span class="string">'user-agent'</span>:ua&#125;</span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/headers'</span>, headers = headers)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
<h3 id="cookie"><a class="header-anchor" href="#cookie">¶</a>cookie</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cookies = dict(userid = <span class="string">'123456'</span>, token = <span class="string">'#####'</span>)</span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/cookies'</span>, cookies = cookies)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
<h3 id="basic-auth认证"><a class="header-anchor" href="#basic-auth认证">¶</a>basic-auth认证</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">'http://httpbin.org/basic-auth/xxx/1123'</span>, auth = (<span class="string">'xxx'</span>,<span class="string">'1123'</span>))</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
<h3 id="状态码"><a class="header-anchor" href="#状态码">¶</a>状态码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">'http://httpbin.org/status/404'</span>)</span><br><span class="line">r.status_code</span><br><span class="line">r.raise_for_status() <span class="comment">#抛出异常，4xx和5xx的</span></span><br></pre></td></tr></table></figure>
<h3 id="session对象"><a class="header-anchor" href="#session对象">¶</a>session对象</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#session对象会保存服务器返回的set-cookie头信息里的内容</span></span><br><span class="line">s = requests.session()</span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/userid/123456789'</span>)</span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/token/######'</span>)</span><br><span class="line"><span class="comment">#下一次请求会将本地所有的cookies信息自动添加到请求头信息里</span></span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
<h3 id="在requests中使用代理"><a class="header-anchor" href="#在requests中使用代理">¶</a>在requests中使用代理</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'不使用代理：'</span>, requests.get(<span class="string">'http://httpbin.org/ip'</span>).json())</span><br><span class="line">print(<span class="string">'使用代理：'</span>,requests.get(<span class="string">'http://httpbin.org/ip'</span>, proxies=&#123;<span class="string">'http'</span>:<span class="string">'http://iguye.com:41801'</span>&#125;).json())</span><br></pre></td></tr></table></figure>
<h3 id="超时报错"><a class="header-anchor" href="#超时报错">¶</a>超时报错</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">'http://httpbin.org/delay/5'</span>,timeout = <span class="number">5</span>)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>url结构</title>
    <url>/2020/02/19/url%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:right">scheme</th>
<th style="text-align:center">Domain</th>
<th style="text-align:center">port</th>
<th style="text-align:center">path</th>
<th style="text-align:center">pathinfo</th>
<th style="text-align:left">Query string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">http:</td>
<td style="text-align:center"><a href="//localhost" target="_blank" rel="noopener">//localhost</a>:</td>
<td style="text-align:center">4000/</td>
<td style="text-align:center">2020/02/19/</td>
<td style="text-align:center">requests/</td>
<td style="text-align:left">#more</td>
</tr>
</tbody>
</table>
<center>url结构</center>
<a id="more"></a>
从上面的URL可以看出，一个完整的URL包括以下几部分：
<p>1、协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&quot;HTTP&quot;后面的“//”为分隔符</p>
<p>2、域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com" target="_blank" rel="noopener">www.aspxfans.com</a>”。一个URL中，也可以使用IP地址作为域名使用</p>
<p>3、端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口80</p>
<p>4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>
<p>5、文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
<p>6、锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>
<p>7、参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>curl和wget</title>
    <url>/2020/02/18/curl%E5%92%8Cwget%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h1>curl</h1>
<p>curl是系统自带的c库，简单过一下，记录一下参数。<br>
不带参数就是，GET请求。</p>
<a id="more"></a>
<h2 id="A"><a class="header-anchor" href="#A">¶</a>-A</h2>
<p>指定客户端的代理标头</p>
<h2 id="B"><a class="header-anchor" href="#B">¶</a>-B</h2>
<p>发送cookie</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b <span class="string">'foo1=bar;foo2=bar2'</span> https://google.com</span><br></pre></td></tr></table></figure>
<h2 id="X"><a class="header-anchor" href="#X">¶</a>-X</h2>
<p>用指定方式请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X Post https://google.com</span><br></pre></td></tr></table></figure>
<h2 id="d"><a class="header-anchor" href="#d">¶</a>-d</h2>
<p>用Post请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">"a=1&amp;b=1"</span> https://google.com</span><br></pre></td></tr></table></figure>
<h2 id="L"><a class="header-anchor" href="#L">¶</a>-L</h2>
<p>跟随服务器重定向</p>
<h2 id="H"><a class="header-anchor" href="#H">¶</a>-H</h2>
<p>设置http请求头信息</p>
<h2 id="k"><a class="header-anchor" href="#k">¶</a>-k</h2>
<p>跳过ssl检测(https)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://www.example.com</span><br></pre></td></tr></table></figure>
<h2 id="O"><a class="header-anchor" href="#O">¶</a>-O</h2>
<p>以远程的文件名下载保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://httpbin.org/image/jpeg</span><br></pre></td></tr></table></figure>
<h2 id="o"><a class="header-anchor" href="#o">¶</a>-o</h2>
<p>以自定的文件名下载保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o wolf.jpeg https://httpbin.org/image/jpeg</span><br></pre></td></tr></table></figure>
<h2 id="s"><a class="header-anchor" href="#s">¶</a>-s</h2>
<p>不显示无关信息</p>
<h2 id="v"><a class="header-anchor" href="#v">¶</a>-v</h2>
<p>显示所有信息</p>
<hr>
<h1>wget</h1>
<p>系统自带的下载文件的工具。</p>
<h2 id="O-v2"><a class="header-anchor" href="#O-v2">¶</a>-O</h2>
<p>以指定文件名存文件</p>
<h2 id="–limit-rate"><a class="header-anchor" href="#–limit-rate">¶</a>–limit-rate=</h2>
<p>限速</p>
<h2 id="c"><a class="header-anchor" href="#c">¶</a>-c</h2>
<p>断点续传</p>
<h2 id="b"><a class="header-anchor" href="#b">¶</a>-b</h2>
<p>后台下载</p>
<h2 id="U"><a class="header-anchor" href="#U">¶</a>-U</h2>
<p>设置user-agent</p>
<h2 id="mirror"><a class="header-anchor" href="#mirror">¶</a>-mirror</h2>
<p>镜像某个网站</p>
<h2 id="p"><a class="header-anchor" href="#p">¶</a>-p</h2>
<p>下载网页的所有内容</p>
<h2 id="r"><a class="header-anchor" href="#r">¶</a>-r</h2>
<p>递归下载所有网页中所有链接</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>http(超文本传输协议)</title>
    <url>/2020/02/17/http%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<pre><code>基于TCP/IP的应用层协议，客户端和服务端数据传输的格式，默认端口：80。 基于请求与响应模式，无状态。
</code></pre>
<a id="more"></a>
<h1>http header</h1>
<h2 id="请求报文"><a class="header-anchor" href="#请求报文">¶</a>请求报文</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;test.php HTTP&#x2F;1.1               &#x2F;&#x2F;请求行</span><br><span class="line">HOST：www.test.com                    &#x2F;&#x2F;请求头</span><br><span class="line">User-Agent：Mozilla&#x2F;5.0 （windows NT 6.1；rv：15.0）Gecko&#x2F;20100101 Firefox&#x2F;15.0        </span><br><span class="line">                                    &#x2F;&#x2F;空白行，代表请求头结束</span><br><span class="line">Username&#x3D;admin&amp;password&#x3D;admin       &#x2F;&#x2F;请求正文</span><br></pre></td></tr></table></figure>
<p>请求行：请求方式 + 请求资源路径 + 版本<br>
请求头：发起请求的主机信息<br>
正文：  optional</p>
<h3 id="请求头"><a class="header-anchor" href="#请求头">¶</a>请求头</h3>
<ul>
<li>Host 请求报头域主要用于指定被请求资源的Internet主机和端口。</li>
<li>User-Agent 请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。</li>
<li>Referer 包含一个URL，代表当前访问URL的上一个URL，也就是说，用户是从什么地方来到本页面。当前请求的原始URL地址。</li>
<li>Cookie 是非常重要的请求头，常用来表示请求者的身份等。</li>
<li>Accept 这个消息头用于告诉服务器客户端愿意接受那些内容，比如图像类，办公文档格式等等。</li>
</ul>
<h3 id="请求方式"><a class="header-anchor" href="#请求方式">¶</a>请求方式</h3>
<p><img src="http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png" alt="http请求方式"></p>
<hr>
<h2 id="响应报文"><a class="header-anchor" href="#响应报文">¶</a>响应报文</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK   					 &#x2F;&#x2F;响应行</span><br><span class="line">Date: Sun, 15 Nov 2015 11:02:04 GMT    &#x2F;&#x2F;响应头</span><br><span class="line">Server: bfe&#x2F;1.0.8.9</span><br><span class="line">Content-Length: 2605</span><br><span class="line">Content-Type: application&#x2F;javascript</span><br><span class="line">Cache-Control: max-age&#x3D;315360000</span><br><span class="line">Expires: Fri, 13 Jun 2025 09:54:00 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Set-Cookie: H_PS_PSSID&#x3D;2022_1438_1944_1788; path&#x3D;&#x2F;; domain&#x3D;test.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">					      &#x2F;&#x2F;空白行，代表响应头结束</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt; Index.html &lt;&#x2F;title&gt;&lt;&#x2F;head&gt;  &#x2F;&#x2F;响应正文消息主题</span><br></pre></td></tr></table></figure>
<p>响应行：版本+状态码<br>
响应头：服务端的信息</p>
<h3 id="响应头"><a class="header-anchor" href="#响应头">¶</a>响应头</h3>
<p><img src="http%E5%93%8D%E5%BA%94%E5%A4%B4.png" alt="http响应头"></p>
<h3 id="状态码"><a class="header-anchor" href="#状态码">¶</a>状态码</h3>
<p>常见的状态码描述如下：</p>
<ul>
<li>200：客户端请求成功，是最常见的状态。</li>
<li>302：重定向。</li>
<li>404：请求资源不存在，是最常见的状态。</li>
<li>400：客户端请求有语法错误，不能被服务器所理解。</li>
<li>401：请求未经授权。</li>
<li>403：服务器收到请求，但是拒绝提供服务。</li>
<li>500：服务器内部错误，是最常见的状态。</li>
<li>503：服务器当前不能处理客户端的请求。</li>
</ul>
<hr>
<h2 id="Q-A"><a class="header-anchor" href="#Q-A">¶</a>Q&amp;A</h2>
<ul>
<li>
<p>get和post的区别<br>
get请求的参数在url后面添加<br>
post在请求体中间</p>
</li>
<li>
<p>https加ssl, tsl, 证书</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客是怎么创建的</title>
    <url>/2020/02/16/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>简单记录一下，博客的创建过程。</p>
<a id="more"></a>
<h2 id="安装环境"><a class="header-anchor" href="#安装环境">¶</a>安装环境</h2>
<pre><code>在创建博客之前，首先要有Github账号，还有确保系统里有git工具。
</code></pre>
<hr>
<h4 id="下载hexo"><a class="header-anchor" href="#下载hexo">¶</a>下载hexo</h4>
<ol>
<li>直接去nodejs.org官网下载node.js</li>
<li>打开terminal下载hexo需要用到node.js的npm安装包管理器:</li>
</ol>
<h2 id="￼0"><a class="header-anchor" href="#￼0">¶</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su                     ##获取最高权限</span><br><span class="line">npm install -g cnpm --registry&#x3D;&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org </span><br><span class="line">                            ##淘宝的镜像源，用cnpm下载比较快</span><br><span class="line">cnpm intall -g hexo-cli     ##开始下载hexo</span><br></pre></td></tr></table></figure></h2>
<h2 id="创建博客"><a class="header-anchor" href="#创建博客">¶</a>创建博客</h2>
<h4 id="初始化博客"><a class="header-anchor" href="#初始化博客">¶</a>初始化博客</h4>
<p>创建博客的代码也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog                     ##创个文件夹好管理</span><br><span class="line">sudo hexo init              ##初始化hexo</span><br><span class="line">hexo s                      ##可以在本地看一下，blog的模版，后续添加了内容也可以用这个指令去预览</span><br></pre></td></tr></table></figure>
<h3 id="创建新文章"><a class="header-anchor" href="#创建新文章">¶</a>创建新文章</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new 文章名.md</span><br></pre></td></tr></table></figure>
<p>一行代码即创建markdown格式的文章，也可以自己直接创建，一般存在 /blog/source/_posts 的路径下。</p>
<hr>
<h2 id="配置到远端仓库"><a class="header-anchor" href="#配置到远端仓库">¶</a>配置到远端仓库</h2>
<h4 id="创建github仓库"><a class="header-anchor" href="#创建github仓库">¶</a>创建github仓库</h4>
<p>这一步就是在github里面创建一个repository，就是存blog文件的，repository的name一定要是 github name + .github.io, <a href="http://xn--noonett-i22mo3ry3qkvkl5qky6a.github.io" target="_blank" rel="noopener">比如我的就是noonett.github.io</a></p>
<h4 id="修过配置文件"><a class="header-anchor" href="#修过配置文件">¶</a>修过配置文件</h4>
<p>在/blog/ 路径下有一个 _config.yml 文件，进入修改，找到deploy下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: https:&#x2F;&#x2F;github.com&#x2F;noonett&#x2F;noonett.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<p>这里的repo就是repository仓库的地址。</p>
<h4 id="部署至仓库"><a class="header-anchor" href="#部署至仓库">¶</a>部署至仓库</h4>
<p>将本地现有的blog部署至远端仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>然后就有自己的博客啦： 就是你的repository名字。</p>
<h4 id="主题的更换"><a class="header-anchor" href="#主题的更换">¶</a>主题的更换</h4>
<p>主题的更换也很简单方便，网上找到主题，clone到自己的仓库里，然后修改yml里的theme改成主题的名字即可，百度上，知乎上挺多的。</p>
<hr>
<h2 id="结束语"><a class="header-anchor" href="#结束语">¶</a>结束语</h2>
<p>网上其实有很多教程，这里就是记录一下我的博客是如何创建的</p>
<hr>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<p><a href="https://www.bilibili.com/video/av44544186?from=search&amp;seid=16653039335337070050" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186?from=search&amp;seid=16653039335337070050</a>  手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>我来网上冲浪了</title>
    <url>/2020/02/16/%E6%88%91%E6%9D%A5%E7%BD%91%E4%B8%8A%E5%86%B2%E6%B5%AA%E4%BA%86/</url>
    <content><![CDATA[<h1>hello world</h1>
<p>村通网了。</p>
<a id="more"></a>
<h1>Overview</h1>
<p>近期基于github和hexo创建了这个blog，用next主题美化。</p>
<h2 id="目的"><a class="header-anchor" href="#目的">¶</a>目的</h2>
<p>记录一下学习笔记，同时也是记录一下生活，说白了就是一个笔记本吧。</p>
<h2 id="接下来"><a class="header-anchor" href="#接下来">¶</a>接下来</h2>
<p>接下来可能会做一篇blog创建的简单教程</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
