<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java异常处理</title>
    <url>/2020/03/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>今朝酒</title>
    <url>/2020/03/03/top/</url>
    <content><![CDATA[<pre><code>这几天忙于学业。才刚把核心类看完，看异常处理，刷《剑指offer》。
</code></pre>
<a id="more"></a>
<ul>
<li>
<p>2020-02-29 22:13:14<br>
面向对象是搞定了，还真的猛这门语言。课内任务还没做，due要到了。</p>
</li>
<li>
<p>2020-02-28 22:17:14<br>
学了波Java入门，从搭环境到这门语言基础。<br>
准备开始这门语言的第一个特性，面向对象。<br>
然后把课内的任务给清了。</p>
</li>
<li>
<p>2020-02-26 21:27:14<br>
最近刚开课，得准备上课和补数学，没时间搞爬虫。刚好cloud computing要用Git和Jave，整好系统得学一下Git。<br>
更新完了Git，打算开始学Java，同时也补后端的知识。</p>
</li>
</ul>
<h2 id="廖老师Java基础课待干："><a class="header-anchor" href="#廖老师Java基础课待干：">¶</a>廖老师Java基础课待干：</h2>
<table>
<thead>
<tr>
<th>章节</th>
<th style="text-align:left">OK？</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java入门</td>
<td style="text-align:left">👌</td>
</tr>
<tr>
<td>面向对象编程</td>
<td style="text-align:left">👌</td>
</tr>
<tr>
<td>Java核心类</td>
<td style="text-align:left">👌</td>
</tr>
<tr>
<td>异常处理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>反射</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>注解</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>泛型</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>集合</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>IO</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>日期与时间</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>单元测试</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>正则表达式</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>加密与安全</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>多线程</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>Maven基础</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>网络编程</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>XML与JSON</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>JDBC编程</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>函数式编程</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>设计模式</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="Java核心技术卷I"><a class="header-anchor" href="#Java核心技术卷I">¶</a>Java核心技术卷I</h2>
]]></content>
      <tags>
        <tag>置顶</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬取偷廖老师的Java教程</title>
    <url>/2020/03/01/%E5%81%B7%E5%BB%96%E8%80%81%E5%B8%88%E7%9A%84Java%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<pre><code>今天想学点Java，访问了一下廖老师的网站，结果网很卡，可能廖老师在更新网站，然后突然想到可以写个爬虫一劳永逸。做这个爬虫的目的也是方便学习廖雪峰老师的Java教程，毕竟把网页存在本地方便浏览，并无他意。
</code></pre>
<a id="more"></a>
<h1>Code</h1>
<p>用的是requerst和xpath，推荐用Chrome上的xpath helper，真香。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##导入库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> lxml</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br></pre></td></tr></table></figure>
<h2 id="发送请求"><a class="header-anchor" href="#发送请求">¶</a>发送请求</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#send request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_request</span><span class="params">(url, headers)</span>:</span></span><br><span class="line">    r = requests.get(url,headers=headers)</span><br><span class="line">    print(<span class="string">'状态码:'</span>,r.status_code)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h2 id="提取数据"><a class="header-anchor" href="#提取数据">¶</a>提取数据</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#fetch data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(domain,resp, headers)</span>:</span></span><br><span class="line">    selector = lxml.etree.HTML(resp.text)    <span class="comment">#generate object</span></span><br><span class="line">    titles = selector.xpath(<span class="string">'//a[@class="x-wiki-index-item"]/text()'</span>)<span class="comment">#拿到各个页面的小标题，比如《面向对象》这种      </span></span><br><span class="line">    uri = selector.xpath(<span class="string">'//a[@class="x-wiki-index-item"]/@href'</span>) <span class="comment">#拿到各个页面的url的参数</span></span><br><span class="line">    <span class="comment">#打包到一起返回      </span></span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> uri:</span><br><span class="line">        urls.append(domain + i)    </span><br><span class="line">    <span class="keyword">return</span> titles, urls</span><br></pre></td></tr></table></figure>
<h1>下载页面</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(titles,urls)</span>:</span></span><br><span class="line">    <span class="comment">#设置下载路径</span></span><br><span class="line">    cwd=os.getcwd()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(cwd + <span class="string">'/廖雪峰Java教程HTML'</span>):</span><br><span class="line">        os.mkdir(cwd + <span class="string">'/廖雪峰Java教程HTML'</span>)</span><br><span class="line">    filepath = cwd + <span class="string">'/廖雪峰Java教程HTML/'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> zip(titles, urls):</span><br><span class="line">        resp = requests.get(value,headers=headers)</span><br><span class="line">        selector = lxml.etree.HTML(resp.text)    </span><br><span class="line">        <span class="comment">#拿到各个页面的正文</span></span><br><span class="line">        html = selector.xpath(<span class="string">'//div[@class="uk-flex-item-1"]'</span>) </span><br><span class="line">        <span class="comment">#转换类型</span></span><br><span class="line">        html = etree.tostring(html[<span class="number">0</span>], pretty_print = <span class="literal">True</span>, method = <span class="string">"html"</span>)</span><br><span class="line">        <span class="comment">#设置文件名</span></span><br><span class="line">        filename = filepath + <span class="string">"%d"</span> % titles.index(key) + key +<span class="string">'.html'</span></span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">'wb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">            f.write(html)</span><br><span class="line">        <span class="comment">#加一个延时，别访问太快</span></span><br><span class="line">        time.sleep(<span class="number">0.3</span>)</span><br><span class="line">    print(<span class="string">"下载完成"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a class="header-anchor" href="#主函数">¶</a>主函数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#main</span></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chro'</span></span><br><span class="line">                      <span class="string">'me/53.0.2785.104 Safari/537.36 Core/1.53.2372.400 QQBrowser/9.5.10548.400'</span></span><br><span class="line">&#125;</span><br><span class="line">domain = <span class="string">'http://www.liaoxuefeng.com'</span>           <span class="comment">#廖雪峰网站的域名</span></span><br><span class="line">url =  <span class="string">"https://www.liaoxuefeng.com/wiki/1252599548343744"</span> <span class="comment">#Java教程的url</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取Java教程的页面</span></span><br><span class="line">resp = send_request(url, headers)</span><br><span class="line"><span class="comment">#提取所有的数据回来，包括标题和urls</span></span><br><span class="line">titles, urls = fetch(domain, resp, headers)</span><br><span class="line"><span class="comment">#开始下载</span></span><br><span class="line">download(titles,urls)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心类</title>
    <url>/2020/03/01/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
    <content><![CDATA[<p>Java内部的核心类。</p>
<a id="more"></a>
<h1>String</h1>
<p>String本身是一个class，Java编译器允许它用…来表示一个字符串。其本质是通过char[]数组来表示的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s2 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'!'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>Java字符串是不可变的，其原理是：<br>
通过private final char[]字段，以及没有任何改变char[]的方法来实现的。<br>
而字符串的改变，实际是开辟了新的内存空间，通过内存地址“断开-连接”变化，改变指向。</p>
<h2 id="字符串操作"><a class="header-anchor" href="#字符串操作">¶</a>字符串操作</h2>
<h3 id="比较"><a class="header-anchor" href="#比较">¶</a>比较</h3>
<p>用a.equals(b)，忽略大小写比较，使用equalsIgnoreCase()方法。‘==’比较的是两者的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"HELLO"</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索"><a class="header-anchor" href="#搜索">¶</a>搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello"</span>.contains(<span class="string">"ll"</span>); <span class="comment">//true</span></span><br><span class="line"><span class="string">"Hello"</span>.indexof(<span class="string">"l"</span>); <span class="comment">//2</span></span><br><span class="line"><span class="string">"Hello"</span>.lastIndexof(<span class="string">"l"</span>); <span class="comment">//3</span></span><br><span class="line"><span class="string">"Hello"</span>.startsWith(<span class="string">"He"</span>); <span class="comment">//ture</span></span><br><span class="line"><span class="string">"Hello"</span>.endWith(<span class="string">"lo"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="提取"><a class="header-anchor" href="#提取">¶</a>提取</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>); <span class="comment">//"llo"</span></span><br><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>,<span class="number">4</span>) <span class="comment">//"llo"</span></span><br></pre></td></tr></table></figure>
<h3 id="去除首尾空白字符"><a class="header-anchor" href="#去除首尾空白字符">¶</a>去除首尾空白字符</h3>
<p>使用.trim()，包括\t,\n,\r</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"  \tHello\r\n "</span>.trim(); <span class="comment">// "Hello"</span></span><br></pre></td></tr></table></figure>
<p>strip()同时还会移除\u3000，中文空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"\u3000Hello\u3000"</span>.strip(); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="comment">//移除首或尾</span></span><br><span class="line"><span class="string">" Hello "</span>.stripLeading(); <span class="comment">// "Hello "</span></span><br><span class="line"><span class="string">" Hello "</span>.stripTrailing(); <span class="comment">// " Hello"</span></span><br></pre></td></tr></table></figure>
<h3 id="判空和空白字符"><a class="header-anchor" href="#判空和空白字符">¶</a>判空和空白字符</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">"  "</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">"  \n"</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">" Hello "</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure>
<h3 id="替换字串"><a class="header-anchor" href="#替换字串">¶</a>替换字串</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">s.replace(<span class="string">'l'</span>, <span class="string">'w'</span>); <span class="comment">// "hewwo"，所有字符'l'被替换为'w'</span></span><br><span class="line">s.replace(<span class="string">"ll"</span>, <span class="string">"~~"</span>); <span class="comment">// "he~~o"，所有子串"ll"被替换为"~~"</span></span><br></pre></td></tr></table></figure>
<p>正则表达式替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"A,,B;C ,D"</span>;</span><br><span class="line">s.replaceAll(<span class="string">"[\\,\\;\\s]+"</span>, <span class="string">","</span>); <span class="comment">// "A,B,C,D"</span></span><br></pre></td></tr></table></figure>
<h3 id="分割合并"><a class="header-anchor" href="#分割合并">¶</a>分割合并</h3>
<h2 id="￼9"><a class="header-anchor" href="#￼9">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"A,B,C,D"</span>;</span><br><span class="line"><span class="comment">//分割</span></span><br><span class="line">String[] ss = s.split(<span class="string">"\\,"</span>); <span class="comment">// &#123;"A", "B", "C", "D"&#125;</span></span><br><span class="line"><span class="comment">//合并字符串数组</span></span><br><span class="line">String[] arr = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">String s = String.join(<span class="string">"***"</span>, arr); <span class="comment">// "A***B***C"</span></span><br></pre></td></tr></table></figure></h2>
<h1>类型转换</h1>
<h3 id="转换成String"><a class="header-anchor" href="#转换成String">¶</a>转换成String()</h3>
<p>用静态方法valueof(),这是重载方法，自动检测类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// "123"</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// "45.67"</span></span><br><span class="line">String.valueOf(<span class="keyword">true</span>); <span class="comment">// "true"</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> Object()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>
<h3 id="String转换成其他类型"><a class="header-anchor" href="#String转换成其他类型">¶</a>String转换成其他类型</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换成int</span></span><br><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(<span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">int</span> n2 = Integer.parseInt(<span class="string">"ff"</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br><span class="line"><span class="comment">//String转换成boolean</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = Boolean.parseBoolean(<span class="string">"true"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = Boolean.parseBoolean(<span class="string">"FALSE"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要特别注意，Integer有个getInteger(String)方法，它不是将字符串转换为int，而是把该字符串对应的系统变量转换为Integer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">"java.version"</span>); <span class="comment">// 版本号，11</span></span><br></pre></td></tr></table></figure>
<ul>
<li>非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同。</li>
<li>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。<br>
原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。</li>
</ul>
<h3 id="与char-相互转换"><a class="header-anchor" href="#与char-相互转换">¶</a>与char[]相互转换</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="string">"Hello"</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line">String s = <span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>
<p>如果修改了char[]数组，String并不会改变。这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份。</p>
<p>如果类内部直接引用了外部传入的int[]数组，而外部代码对int[]数组的修改，会影响到Score类的字段。如果外部代码不可信，这就会造成安全隐患。</p>
<h2 id="￼14"><a class="header-anchor" href="#￼14">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] scores = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">88</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">66</span> &#125;;</span><br><span class="line">        Score s = <span class="keyword">new</span> Score(scores);</span><br><span class="line">        s.printScores();</span><br><span class="line">        scores[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        s.printScores();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] scores;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Score</span><span class="params">(<span class="keyword">int</span>[] scores)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用clone()方法拷贝副本，而不是复制引用</span></span><br><span class="line">        <span class="keyword">this</span>.scores = scores.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printScores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(scores));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h1>字符编码</h1>
<ul>
<li>统一全球的编码Unicode编码需要两个或者更多字节表示，ASCII一个字节、GB2312两个字节。</li>
<li>UTF-8把固定长度的Unicode编码变成1～4字节的变长编码。编码依靠高字节位来确定一个字符究竟是几个字节，用来作为传输编码。</li>
<li>转换编码后，就不再是char类型，而是byte类型表示的数组。</li>
</ul>
<h4 id="始终牢记：Java的String和char在内存中总是以Unicode编码表示。"><a class="header-anchor" href="#始终牢记：Java的String和char在内存中总是以Unicode编码表示。">¶</a>始终牢记：Java的String和char在内存中总是以Unicode编码表示。</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b1 = <span class="string">"Hello"</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"GBK"</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b3 = <span class="string">"Hello"</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="comment">//将字节码转回String类型</span></span><br><span class="line"><span class="keyword">byte</span>[] b = ...</span><br><span class="line">String s1 = <span class="keyword">new</span> String(b, <span class="string">"GBK"</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure>
<pre><code>而较新的JDK版本的String则以byte[]存储：如果String仅包含ASCII字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的String通常仅包含ASCII字符：
</code></pre>
<h2 id="￼16"><a class="header-anchor" href="#￼16">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure></h2>
<h1>StringBuilder</h1>
<p>s = s + “,” + i;可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。<br>
StringBuilder，它是一个可变对象，可以预分配缓冲区，新增字符时，不会创建新的临时对象：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//申请缓冲区空间</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//用append增加字符串</span></span><br><span class="line">    sb.append(<span class="string">','</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转成字符串</span></span><br><span class="line">String s = sb.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以链式操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">"Mr "</span>)</span><br><span class="line">          .append(<span class="string">"Bob"</span>)</span><br><span class="line">          .append(<span class="string">"!"</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">"Hello, "</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式操作的关键是，append()方法会返回this，从而不断调用自身。</p>
<p>注意：对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。</p>
<h2 id="StringBuilder和StringBuffer接口完全相同，同步会带来执行速度的下降，现在完全没有必要使用StringBuffer。"><a class="header-anchor" href="#StringBuilder和StringBuffer接口完全相同，同步会带来执行速度的下降，现在完全没有必要使用StringBuffer。">¶</a>StringBuilder和StringBuffer接口完全相同，同步会带来执行速度的下降，现在完全没有必要使用StringBuffer。</h2>
<h1>StringJoiner</h1>
<p>连接字符串数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"Grace"</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">", "</span>, <span class="string">"Hello "</span>, <span class="string">"!"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定连接符， 开头，结尾</span></span><br></pre></td></tr></table></figure>
<p>其源码内部就是用StringBuilder实现的。<br>
String.join()：静态方法，其内部是用StringJoiner实现的，但是不能加开头和结尾。</p>
<h2 id="￼19"><a class="header-anchor" href="#￼19">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"Grace"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> s = String.join(<span class="string">", "</span>, names);</span><br></pre></td></tr></table></figure></h2>
<h1>包装类型 Wrapper class</h1>
<p>Java的数据类型分两种：</p>
<ul>
<li>基本类型：byte，short，int，long，boolean，float，double，char</li>
<li>引用类型：所有class和interface类型<br>
引用类型可以为null，基本类型不行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        Integer n1 = <span class="keyword">new</span> Integer(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        Integer n2 = Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        Integer n3 = Integer.valueOf(<span class="string">"100"</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Auto-Boxing"><a class="header-anchor" href="#Auto-Boxing">¶</a>Auto Boxing</h2>
<p>Java编译器可以帮助我们自动在int和Integer之间转型(自动包装，自动拆箱)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将int变为Integer赋值：auto boxing</span></span><br><span class="line">Integer n = <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="keyword">int</span> x = n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。</li>
<li>自动拆箱执行时可能会报NullPointerException。将null值的Integer赋值给int。</li>
</ul>
<h2 id="所有包装类型都是不变类"><a class="header-anchor" href="#所有包装类型都是不变类">¶</a>所有包装类型都是不变类</h2>
<p>一旦创建了Integer()类型就是用不变的。Integer必须用equals()比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">127</span>;</span><br><span class="line">        Integer y = <span class="number">127</span>;</span><br><span class="line">        Integer m = <span class="number">99999</span>;</span><br><span class="line">        Integer n = <span class="number">99999</span>;</span><br><span class="line">        System.out.println(<span class="string">"x == y: "</span> + (x==y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"m == n: "</span> + (m==n)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"x.equals(y): "</span> + x.equals(y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"m.equals(n): "</span> + m.equals(n)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。<br>
方法1：Integer n = new Integer(100);<br>
方法2：Integer n = Integer.valueOf(100);</p>
<ul>
<li>方法2更好，Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</li>
<li>创建新对象时，尽量使用静态工厂方法，而不是使用new操作符。</li>
</ul>
<h2 id="进制转换"><a class="header-anchor" href="#进制转换">¶</a>进制转换</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Integer将String解析成整数</span></span><br><span class="line"><span class="keyword">int</span> x1 = Integer.parseInt(<span class="string">"100"</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">int</span> x2 = Integer.parseInt(<span class="string">"100"</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将整数格式化成特定字符</span></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// "100",表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// "2s",表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// "64",表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// "144",表示为8进制</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// "1100100",表示为2进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内存中总是以二进制的形式存在，比如int是4字节二进制。<br>
System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示。</p>
<ul>
<li>程序设计的重要原则： 存储和显示相分离</li>
<li>所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型。</li>
</ul>
<h2 id="无符号整型"><a class="header-anchor" href="#无符号整型">¶</a>无符号整型</h2>
<h2 id="￼24-还可以将int转成无符号short，short转成无符号long。"><a class="header-anchor" href="#￼24-还可以将int转成无符号short，short转成无符号long。">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将byte转为无符号int</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> y = <span class="number">127</span>;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>
还可以将int转成无符号short，short转成无符号long。</h2>
<h1>JavaBean</h1>
<ul>
<li>class中，一般private定义字段，public方法访问字段。如果class的属性(property)读(getter)写(setter)方法满足：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getXyz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXyz</span><span class="params">(Type value)</span></span></span><br></pre></td></tr></table></figure>
<p>这种class即为JavaBean。</p>
<ul>
<li>boolean字段比较特殊，它的读方法一般命名为isXyz()：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="keyword">boolean</span> value)</span></span></span><br></pre></td></tr></table></figure>
<p>只有setter称为（write-only），只有getter称为（read-only）。</p>
<ul>
<li>使用Introspector.getBeanInfo()可以获取属性列表。</li>
</ul>
<h2 id="￼27"><a class="header-anchor" href="#￼27">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.*;</span><br></pre></td></tr></table></figure></h2>
<h1>枚举类</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekdays&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类时，编译器能自动检查某个值是否在枚举的集合中。</p>
<ul>
<li>可以检查出类型</li>
<li>不可以引用非枚举类型的值</li>
<li>不同类型的枚举不能互相比较或者赋值</li>
</ul>
<h3 id="enum的比较"><a class="header-anchor" href="#enum的比较">¶</a>enum的比较</h3>
<p>引用类型只能用equals()，但是enum可以用==，因为enum的每一个常量在JVM只有一个实例。</p>
<h3 id="enum类型"><a class="header-anchor" href="#enum类型">¶</a>enum类型</h3>
<ul>
<li>enum继承自Java.lang.Enum，且无法被继承。</li>
<li>无法通过new创建enum的实例</li>
<li>enum可以用switch</li>
</ul>
<h3 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回常量名</span></span><br><span class="line">String s = Weekday.SUN.name(); <span class="comment">// "SUN"</span></span><br><span class="line"><span class="comment">//返回顺序</span></span><br><span class="line"><span class="keyword">int</span> n = Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>可以给枚举类型添加字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Work at home!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Work at office!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以覆写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Today is "</span> + day + <span class="string">". Work at home!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Today is "</span> + day + <span class="string">". Work at office!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">"星期一"</span>), TUE(<span class="number">2</span>, <span class="string">"星期二"</span>), WED(<span class="number">3</span>, <span class="string">"星期三"</span>), THU(<span class="number">4</span>, <span class="string">"星期四"</span>), FRI(<span class="number">5</span>, <span class="string">"星期五"</span>), SAT(<span class="number">6</span>, <span class="string">"星期六"</span>), SUN(<span class="number">0</span>, <span class="string">"星期日"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue, String chinese)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="keyword">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>注意，判断枚举常量的名字一定要用name()，不可以用toString()</b></p>
<h3 id="Switch"><a class="header-anchor" href="#Switch">¶</a>Switch</h3>
<h2 id="￼32-加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。"><a class="header-anchor" href="#￼32-加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">"Today is "</span> + day + <span class="string">". Work at office!"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">"Today is "</span> + day + <span class="string">". Work at home!"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"cannot process "</span> + day);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>
加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</h2>
<h1>BigInteger</h1>
<p>Cpu最大的范围是64位long，可以通过Cpu指令直接计算。<br>
超过long的范围，用java.math.BigInteger类型，其内部用一个int[]模拟非常大的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br><span class="line"><span class="comment">//运算时</span></span><br><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">"12345678901234567890"</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br><span class="line"><span class="comment">//转换类型</span></span><br><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">"123456789000"</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure>
<p>其也是不变类，继承自number。<br>
转换为byte：byteValue()<br>
转换为short：shortValue()<br>
转换为int：intValue()<br>
转换为long：longValue()<br>
转换为float：floatValue()<br>
转换为double：doubleValue()</p>
<h2 id="BigDecimal"><a class="header-anchor" href="#BigDecimal">¶</a>BigDecimal</h2>
<h2 id="用scale-表示小数位数，返回负数则表示是整数，大小为后面有几个0-使用equals也要注意scale的值相等才行。BigDecimal是用一个BigInteger和scale表示的。"><a class="header-anchor" href="#用scale-表示小数位数，返回负数则表示是整数，大小为后面有几个0-使用equals也要注意scale的值相等才行。BigDecimal是用一个BigInteger和scale表示的。">¶</a>用scale()表示小数位数，返回负数则表示是整数，大小为后面有几个0.<br>
使用equals也要注意scale的值相等才行。<br>
BigDecimal是用一个BigInteger和scale表示的。</h2>
<h1>常用工具类</h1>
<h2 id="math"><a class="header-anchor" href="#math">¶</a>math</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求绝对值</span></span><br><span class="line">Math.abs(-<span class="number">100</span>)</span><br><span class="line"><span class="comment">//取最大最小值</span></span><br><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br><span class="line"><span class="comment">//计算n次方</span></span><br><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br><span class="line"><span class="comment">//计算根号</span></span><br><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br><span class="line"><span class="comment">//计算以e为底的对数</span></span><br><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br><span class="line"><span class="comment">//以10为底</span></span><br><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//三角函数</span></span><br><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br><span class="line"><span class="comment">//数学常量</span></span><br><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br><span class="line"><span class="comment">//随机数</span></span><br><span class="line">Math.random();</span><br><span class="line"><span class="comment">//[Max,Min）范围的随机数</span></span><br><span class="line"><span class="comment">// 区间在[MIN, MAX)的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = Math.random(); <span class="comment">// x的范围是[0,1)</span></span><br><span class="line">        <span class="keyword">double</span> min = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> max = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">double</span> y = x * (max - min) + min; <span class="comment">// y的范围是[10,50)</span></span><br><span class="line">        <span class="keyword">long</span> n = (<span class="keyword">long</span>) y; <span class="comment">// n的范围是[10,50)的整数</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Random"><a class="header-anchor" href="#Random">¶</a>Random</h2>
<p>创建伪随机数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定种子</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random(<span class="number">1234</span>);</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure>
<p>Math.random()内部也是调用了Random类</p>
<h2 id="secureRandom"><a class="header-anchor" href="#secureRandom">¶</a>secureRandom</h2>
<p>真随机数，安全随机数。SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象基础</title>
    <url>/2020/02/29/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<pre><code>面向对象编程，没有对象，怎么编程？？🤔
顺手把面向抽象，面向接口给学了。
</code></pre>
<a id="more"></a>
<h2 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h2>
<h3 id="private"><a class="header-anchor" href="#private">¶</a>private</h3>
<ul>
<li>private修饰field可以拒绝外部访问，但是可以通过内部方法来间接修改field</li>
<li>private修饰method则拒绝外部调用，但是可以通过内部方法来调用</li>
</ul>
<h3 id="this"><a class="header-anchor" href="#this">¶</a>this</h3>
<p>隐式的变量，通过this.field来访问当前instance的field。</p>
<h3 id="可变参数"><a class="header-anchor" href="#可变参数">¶</a>可变参数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String[] name;</span><br><span class="line">    <span class="comment">//String ... 相当于数组类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String... name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Hello c = <span class="keyword">new</span> Hello();</span><br><span class="line">        <span class="comment">//数组类型则要先定义好，再传入参数</span></span><br><span class="line">		<span class="comment">//String[] name = &#123;"asdf", "casdf"&#125;;</span></span><br><span class="line">        <span class="comment">//可变参数可以直接传递参数</span></span><br><span class="line">		c.setName(<span class="string">"asdf"</span>, <span class="string">"casdf"</span>); </span><br><span class="line">		System.out.println(Arrays.toString(c.name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用方可以调用null，但是可变参数不可以，因为传入0个参数时，实际传入的是一个空数组。</li>
</ul>
<h3 id="参数绑定"><a class="header-anchor" href="#参数绑定">¶</a>参数绑定</h3>
<h4 id="基本类型参数的传递"><a class="header-anchor" href="#基本类型参数的传递">¶</a>基本类型参数的传递</h4>
<p>传递的是数据的拷贝。双方各自的后续修改，互不影响。</p>
<h4 id="引用类型参数的传递"><a class="header-anchor" href="#引用类型参数的传递">¶</a>引用类型参数的传递</h4>
<ol>
<li>传递的是对象地址的拷贝。Java的参数是以值的形式传入方法中，而不是引用传递。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</li>
<li>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响.</li>
</ol>
<h2 id="￼1"><a class="header-anchor" href="#￼1">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        String bob = <span class="string">"Bob"</span>;</span><br><span class="line">        p.setName(bob); <span class="comment">// 传入bob变量</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Bob"</span></span><br><span class="line">        bob = <span class="string">"Alice"</span>; <span class="comment">// bob改名为Alice</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Bob"还是"Alice"?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="构造方法：初始化实例"><a class="header-anchor" href="#构造方法：初始化实例">¶</a>构造方法：初始化实例</h2>
<pre><code>构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。
</code></pre>
<ul>
<li>编译器会自动创建构造方法。自定义了就不会再生成。</li>
<li>没有在构造方法中初始化field时，引用类型的field默认是null，数值类型的field用默认值，int类型默认值是0，布尔类型默认值是false</li>
</ul>
<h3 id="多构造方法"><a class="header-anchor" href="#多构造方法">¶</a>多构造方法</h3>
<p>系统会自动匹配。构造方法可以调用其他构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"Unnamed"</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法重载overload"><a class="header-anchor" href="#方法重载overload">¶</a>方法重载overload</h3>
<pre><code>功能类似，方法名相同，参数不同。
</code></pre>
<hr>
<h2 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用extends关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person：超类（super class），父类（parent class），基类（base class）。<br>
Student：子类（subclass），扩展类（extended class）。</p>
<h3 id="继承树"><a class="header-anchor" href="#继承树">¶</a>继承树</h3>
<p>在Java中，没有明确写extends的类都会被自动加上extends Object。一个子类自能继承自一个父类。</p>
<h3 id="访问权限"><a class="header-anchor" href="#访问权限">¶</a>访问权限</h3>
<p>子类不能访问父类的private fields和methods。<br>
protected可以字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问。</p>
<h3 id="super"><a class="header-anchor" href="#super">¶</a>super</h3>
<ul>
<li>子类引用父类的fields时用。</li>
<li>如果父类没有默认的构造方法（父类有自定义构造方法），子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。</li>
<li>子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转型"><a class="header-anchor" href="#转型">¶</a>转型</h3>
<pre><code>引用类型的声明和对象类型可以不同。
可以upcasting不可以downcasting，可以将子类转型成父类，不可以将父类转型成子类，多出来的功能不可能凭空增加。
</code></pre>
<ul>
<li>转型失败的时候，Java虚拟机会报ClassCastException。</li>
<li>可以用instanceof先判断，其实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">    Student s = (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承和组合"><a class="header-anchor" href="#继承和组合">¶</a>继承和组合</h3>
<p>student继承自person，可以拥有一个book实例。</p>
<h2 id="￼6"><a class="header-anchor" href="#￼6">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="多态"><a class="header-anchor" href="#多态">¶</a>多态</h2>
<h3 id="覆写override"><a class="header-anchor" href="#覆写override">¶</a>覆写override</h3>
<p>子类的方法名，参数与父类的相同，返回值也相同则是override。否则是overload。@Override可以让编译器帮助检查是否进行了正确的覆写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// Compile error!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String s)</span> </span>&#123;&#125; <span class="comment">//参数名不同，overload</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>那么，一个实际类型为Student，引用类型为Person的变量，调用其run()方法，调用的是Person还是Student的run()方法？
调用的为实际类型Student的方法。
</code></pre>
<h3 id="多态-v2"><a class="header-anchor" href="#多态-v2">¶</a>多态</h3>
<pre><code>定义：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。
多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。
通过override，允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。
</code></pre>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> Income[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Income(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> Salary(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> StateCouncilSpecialAllowance(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Income</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateCouncilSpecialAllowance</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="覆写Object方法"><a class="header-anchor" href="#覆写Object方法">¶</a>覆写Object方法</h3>
<p>object类中重要的方法：<br>
.toString(): 把instance输出为String();<br>
.equals(): 判断两个instances是否逻辑相等;<br>
.hashCode(): 计算一个instance的哈希值;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 显示更有意义的字符串:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person:name="</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较是否相等:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当且仅当o为Person类型:</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person p = (Person) o;</span><br><span class="line">            <span class="comment">// 并且name字段相同时，返回true:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算hash:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用super"><a class="header-anchor" href="#调用super">¶</a>调用super</h3>
<p>在子类的覆写方法中, 调用父类被覆写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student extends Person &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的hello()方法:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hello() + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常量final"><a class="header-anchor" href="#常量final">¶</a>常量final</h3>
<p>父类的方法不允许override：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student extends Person &#123;</span><br><span class="line">    <span class="comment">// compile error: 不允许覆写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>final用于初始化值，则这个变量不再可以修改。可以通过构造方法或者代码块来进行初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="￼13"><a class="header-anchor" href="#￼13">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"><span class="comment">//初始化局部变量，则不可修改。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="抽象类"><a class="header-anchor" href="#抽象类">¶</a>抽象类</h2>
<p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，则可以用abstract。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类中有抽象方法，则这个类无法被实例化，编译器会无法编译这个类。除非person类也声明abstract。</p>
<h3 id="抽象类-v2"><a class="header-anchor" href="#抽象类-v2">¶</a>抽象类</h3>
<p>抽象类无法被实例化。抽象类的设计本身就是被继承，抽象类强迫子类覆写其定义的抽象方法，否则报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//abstract声明</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面向抽象编程"><a class="header-anchor" href="#面向抽象编程">¶</a>面向抽象编程</h3>
<p>尽量引用高层类型，而不引用子类。</p>
<ul>
<li>上层代码只定义规范（例如：abstract class Person）；</li>
<li>不需要子类就可以实现业务逻辑（正常编译）；</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心。<br>
抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现</li>
</ul>
<hr>
<h1>接口</h1>
<pre><code>如果一个抽象类没有字段，全是抽象的方法，则可用interface改写成接口。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个class实现接口：用implements(实现)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多接口"><a class="header-anchor" href="#多接口">¶</a>多接口</h2>
<p>可以实现多个interface：本来是不能继承多个的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Hello</span> </span>&#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口继承"><a class="header-anchor" href="#接口继承">¶</a>接口继承</h2>
<p>一个接口可以继承自另一接口，用extends。</p>
<h2 id="继承关系"><a class="header-anchor" href="#继承关系">¶</a>继承关系</h2>
<p>充分的复用代码，参考集合类定义的一组接口：<br>
<img src="/.io//%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="继承关系"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总是用更抽象的类来引用实际类型。</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 用List接口引用具体子类的实例</span></span><br><span class="line">Collection coll = list; <span class="comment">// 向上转型为Collection接口</span></span><br><span class="line">Iterable it = coll; <span class="comment">// 向上转型为Iterable接口</span></span><br></pre></td></tr></table></figure>
<h2 id="default方法"><a class="header-anchor" href="#default方法">¶</a>default方法</h2>
<p>实现类可以不必实现default方法。其目的：<br>
给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。</li>
</ul>
<hr>
<h1>静态字段和静态方法</h1>
<pre><code>静态字段和静态方法是属于class而不是intances的。
</code></pre>
<h2 id="静态字段"><a class="header-anchor" href="#静态字段">¶</a>静态字段</h2>
<p>静态字段是同一个class所有实例共享的，实例中并没有静态字段，不推荐用 实例名.静态字段 来访问，因为编译器是根据实例类型自动转换为类名.静态字段来访问静态对象。</p>
<h2 id="静态方法"><a class="header-anchor" href="#静态方法">¶</a>静态方法</h2>
<p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。</p>
<h2 id="用途"><a class="header-anchor" href="#用途">¶</a>用途</h2>
<ol>
<li>静态方法经常用于工具类。例如：<br>
Arrays.sort()<br>
Math.random()</li>
<li>静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。</li>
</ol>
<h2 id="接口的静态字段"><a class="header-anchor" href="#接口的静态字段">¶</a>接口的静态字段</h2>
<p>interface是可以有静态字段的，并且静态字段必须为final类型：</p>
<h2 id="￼21"><a class="header-anchor" href="#￼21">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static + final</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//都去掉也可以，编译器会自动补上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h1>包packages</h1>
<p>使用package来解决名字冲突。JVM只看完整类名，因此，只要包名不同，类就不同。</p>
<ul>
<li>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</li>
</ul>
<h2 id="包作用域"><a class="header-anchor" href="#包作用域">¶</a>包作用域</h2>
<h2 id="同一个包中，不用public、protected、private修饰的字段和方法就是包作用域。一般使用倒置的域名来确保唯一性。"><a class="header-anchor" href="#同一个包中，不用public、protected、private修饰的字段和方法就是包作用域。一般使用倒置的域名来确保唯一性。">¶</a>同一个包中，不用public、protected、private修饰的字段和方法就是包作用域。<br>
一般使用倒置的域名来确保唯一性。</h2>
<h1>作用域</h1>
<ul>
<li>public: field、method可以被其他类访问，前提是首先有访问class的权限。</li>
<li>private: 访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面。Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限。</li>
<li>protected：作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类</li>
</ul>
<ul>
<li>一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。</li>
</ul>
<hr>
<h1>classpath和jar</h1>
<h2 id="classpath"><a class="header-anchor" href="#classpath">¶</a>classpath</h2>
<pre><code>JVM用到的环境变量，用于搜索class文件的目录。
要在JVM启动时设置环境变量，没有设置则默认为当前目录。
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>
<ul>
<li>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</li>
</ul>
<h2 id="jar"><a class="header-anchor" href="#jar">¶</a>jar</h2>
<pre><code>把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件.
</code></pre>
<p>MANIFEST.MF文件可以提供jar包的信息，如Main-Class，这样可以直接运行jar包。</p>
<h2 id="￼23-MANIFEST-MF文件里配置classpath"><a class="header-anchor" href="#￼23-MANIFEST-MF文件里配置classpath">¶</a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure><br>
MANIFEST.MF文件里配置classpath.</h2>
<h1>模块</h1>
<p>JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫rt.jar。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门</title>
    <url>/2020/02/28/java%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Cloud computing要用到Java，正好打算学习后端开发，就从Java开始入门，慢慢学，慢慢更新,先开个坑。</p>
<a id="more"></a>
<h1>基本知识</h1>
<h2 id="代码块规范："><a class="header-anchor" href="#代码块规范：">¶</a>代码块规范：</h2>
<ul>
<li>类名首字母要大写</li>
<li>public static void main(String[] args){} 方法是固定入口</li>
<li>方法的代码每一行都要以；结尾</li>
<li>类名和文件名必须保持一致</li>
<li>区分大小写！</li>
</ul>
<h2 id="运行原理："><a class="header-anchor" href="#运行原理：">¶</a>运行原理：</h2>
<pre><code>javac编译器先把.java文件编译成.class的字节码文件，然后向java虚拟机传递类名，查找到对应文件然后运行。
</code></pre>
<h2 id="基本数据类型"><a class="header-anchor" href="#基本数据类型">¶</a>基本数据类型</h2>
<pre><code>整数类型：byte(一个字节)，short（2），int（4），long（8）
浮点数类型：float（float型后缀加f）[最大可表示10^38]，double[10^308]
字符类型：char（使用单引号）
布尔类型：boolean (在JVM里是4字节整数)
*常量*： 类型名前加final, 避免魔术数字，通常全部大写
var关键字：类名太长，编译器自动判断变量类型
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>
<ul>
<li>变量的作用域：{}</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 变量i从这里开始定义</span></span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// 变量x从这里开始定义</span></span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            String s = <span class="string">"hello"</span>; <span class="comment">// 变量s从这里开始定义</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="comment">// 变量s作用域到此结束</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 注意，这是一个新的变量s，它和上面的变量同名，</span></span><br><span class="line">        <span class="comment">// 但是因为作用域不同，它们是两个不同的变量:</span></span><br><span class="line">        String s = <span class="string">"hi"</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="comment">// 变量x和s作用域到此结束</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 变量i作用域到此结束</span></span><br></pre></td></tr></table></figure>
<p>要遵循作用域最小的原则，且变量不用重名。</p>
<h2 id="整数运算"><a class="header-anchor" href="#整数运算">¶</a>整数运算</h2>
<p>%：取余</p>
<ul>
<li>位移运算：右移（相当于除以2） &gt;&gt; （符号位不动，&gt;&gt;&gt;（符号位跟着动）<br>
<em>要小心溢出，注意数据类型</em></li>
<li>位运算： 与：&amp;， 或：｜， 非：～ 异或：^，不同为1，同为。<br>
整数的位运算是按位对齐做位运算。通过与运算可以快速判断两个IP是否在同一个网段。</li>
<li>强制类型转换：（short）</li>
</ul>
<h2 id="浮点型"><a class="header-anchor" href="#浮点型">¶</a>浮点型</h2>
<p>浮点型的比较，将两数的差的绝对值小于某一范围，即可认为相等。<br>
浮点型四舍五入时，+0.5，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">2.6</span>;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) (d + <span class="number">0.5</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>整型相除时，要先进行类型转换，否则会只留下整数位</li>
</ul>
<h2 id="布尔类型"><a class="header-anchor" href="#布尔类型">¶</a>布尔类型</h2>
<p>运算有 与&amp;&amp;，或||,非！，注意跟整型运算的区别。</p>
<h3 id="三元运算符"><a class="header-anchor" href="#三元运算符">¶</a>三元运算符</h3>
<p>b ? x:y</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x,y的类型必须相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = -<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> x = n &gt;= <span class="number">0</span> ? n : -n;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符字符串"><a class="header-anchor" href="#字符字符串">¶</a>字符字符串</h2>
<ul>
<li>char: 保存一个unicode字符，英文和中文都占用2个字节，’’</li>
<li>String： “”, 可以用+连接任意字符串和其他数据类型。<br>
“”&quot;… “”&quot;表示多行字符串，但是要用Java13特性，编译的时候；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac --<span class="built_in">source</span> 13 --<span class="built_in">enable</span>-preview Main.java</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串不可变：字符串是引用类型，字符串的内容是不变的，变量的本质是一个指针</li>
<li>null: 空值，指针指向空</li>
</ul>
<h2 id="数组类型"><a class="header-anchor" href="#数组类型">¶</a>数组类型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        <span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//自动推算长度</span></span><br><span class="line">        <span class="keyword">int</span>[] ns1 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        <span class="comment">//简写</span></span><br><span class="line">        <span class="keyword">int</span>[] ns2 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">        ns[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">//查看数组长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组大小不可变，同理字符串，变量的本质是指针</li>
</ul>
<h3 id="字符串数组"><a class="header-anchor" href="#字符串数组">¶</a>字符串数组</h3>
<p>数组的元素是引用类型时，</p>
<h2 id="￼6"><a class="header-anchor" href="#￼6">¶</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] StrArray = &#123;<span class="string">"as"</span>,<span class="string">"asv"</span>&#125;;</span><br></pre></td></tr></table></figure></h2>
<h1>流程控制</h1>
<h2 id="输入输出"><a class="header-anchor" href="#输入输出">¶</a>输入输出</h2>
<h3 id="格式化输出-System-out-printf"><a class="header-anchor" href="#格式化输出-System-out-printf">¶</a>格式化输出: System.out.printf()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">        System.out.printf(<span class="string">"%.2f\n"</span>, d); <span class="comment">// 显示两位小数3.14</span></span><br><span class="line">        System.out.printf(<span class="string">"%.4f\n"</span>, d); <span class="comment">// 显示4位小数3.1416</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:right">占位符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">%d</td>
<td style="text-align:left">格式化输出整数</td>
</tr>
<tr>
<td style="text-align:right">%x</td>
<td style="text-align:left">格式化输出十六进制整数</td>
</tr>
<tr>
<td style="text-align:right">%f</td>
<td style="text-align:left">格式化输出浮点数</td>
</tr>
<tr>
<td style="text-align:right">%e</td>
<td style="text-align:left">格式化输出科学计数法表示的浮点数</td>
</tr>
<tr>
<td style="text-align:right">%s</td>
<td style="text-align:left">格式化字符串</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//16进制输出用0补足8位</span></span><br><span class="line">System.out.printf(<span class="string">"n=%d, hex=%08x"</span>, n, n); <span class="comment">// 注意，两个%占位符必须传入两个数</span></span><br></pre></td></tr></table></figure>
<h3 id="输入"><a class="header-anchor" href="#输入">¶</a>输入</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">//导入控制台库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">"Input your name: "</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        String name = scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">"Input your age: "</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="keyword">int</span> age = scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">"Hi, %s, you are %d\n"</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="if语句"><a class="header-anchor" href="#if语句">¶</a>if语句</h2>
<ul>
<li>判断相等一定要范围，否则浮点型不准确：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">1</span> - <span class="number">9.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x - <span class="number">0.1</span>) &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"x is 0.1"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"x is NOT 0.1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>要判断引用类型的变量内容是否相等，必须使用equals()方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1 != <span class="keyword">null</span> &amp;&amp;s1.equals(s2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"相等"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"不等"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果变量s1为null，则会报错，所以要&amp;&amp;。</p>
<h2 id="switch"><a class="header-anchor" href="#switch">¶</a>switch</h2>
<p>旧版的switch：具有穿透性，只负责匹配，匹配成功将继续向下匹配。所以不能漏泄break；<br>
新版的switch: 自动break；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String option = <span class="string">"apple"</span>;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="keyword">switch</span>(option)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"apple"</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"peer"</span>,<span class="string">"banana"</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//可以用&#123;&#125;框住，执行多条语句。</span></span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> code = fruit.hashCode();</span><br><span class="line">                yield code; <span class="comment">//返回code值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">//赋值语句要以；结束， 没赋值就不用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>switch也是java13的新特性：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac --<span class="built_in">source</span> 13 --<span class="built_in">enable</span>-preview Main.java</span><br></pre></td></tr></table></figure>
<h2 id="while"><a class="header-anchor" href="#while">¶</a>while</h2>
<ul>
<li>死循环中，int自增到最大再加一会变成负数，从而跳出循环。</li>
<li>do … while是先执行再判断，所以至少会执行一次。要注意边界问题。</li>
</ul>
<h2 id="for"><a class="header-anchor" href="#for">¶</a>for</h2>
<ul>
<li>注意：循环中定义的变量的作用域只在循环中，循环外将无法访问。</li>
</ul>
<h3 id="for-each"><a class="header-anchor" href="#for-each">¶</a>for each</h3>
<p>便于遍历数组，但是无法获得数组的索引:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">int</span> ns[] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n:ns)&#123;</span><br><span class="line">            sum = sum +n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for each能遍历所有可迭代的对象，包括list，map…</li>
</ul>
<h2 id="break和continue"><a class="header-anchor" href="#break和continue">¶</a>break和continue</h2>
<pre><code>break：跳出一层循环。
continue： 提前结束本次循环，进入下一次循环。
</code></pre>
<hr>
<h1>数组操作</h1>
<p>遍历数组就不说了，需要索引用for，不需要索引用for each。</p>
<h2 id="打印数组内容"><a class="header-anchor" href="#打印数组内容">¶</a>打印数组内容</h2>
<p>直接打印数组，获得的是JVM中的引用地址<br>
可以用for each循环打印，也可以用Arrays.toString()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组排序"><a class="header-anchor" href="#数组排序">¶</a>数组排序</h2>
<p>用Arrays.sort()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        Arrays.sort(ns); <span class="comment">//排序</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多维数组"><a class="header-anchor" href="#多维数组">¶</a>多维数组</h2>
<p>数组是引用类型，将引用类型又存入一个数组，就成了二维数组。<br>
访问二维数组：array[row][col]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二维数组的声明是两个方括号</span></span><br><span class="line">        <span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;; <span class="comment">//赋值后面要加；</span></span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">//用Arrays.deepToString(ns)打印数组</span></span><br><span class="line">        System.out.println(Arrays.deepToString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命令行参数"><a class="header-anchor" href="#命令行参数">¶</a>命令行参数</h2>
<p>Java程序的入口main()方法可以接受一个 String[]数组类型的命令行参数。<br>
这个命令行参数由JVM接收用户输入并传给main方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java Main -version</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git一文通</title>
    <url>/2020/02/26/Git_learning/</url>
    <content><![CDATA[<h1>Git</h1>
<pre><code>免费分布式版本管理系统。相比于集中式管理的CVS，SVN：不必联网修改，强大的分支管理。更关键的是：Git跟踪并管理的是文件的修改，减少了上传量
</code></pre>
<a id="more"></a>
<h2 id="创建版本库"><a class="header-anchor" href="#创建版本库">¶</a>创建版本库</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step 0: 初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># step 1: 将文件加入仓库</span></span><br><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt file3.txt</span><br><span class="line"><span class="comment"># step 2：提交（可以一次提交多个文件） -m表示添加说明</span></span><br><span class="line">git commit -m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure>
<h2 id="版本回退"><a class="header-anchor" href="#版本回退">¶</a>版本回退</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看版本日志</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment">#一堆乱乱的字符是十六进制的commit id，防止多人协作版本号冲突</span></span><br><span class="line"><span class="comment">#一行显示</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line"><span class="comment">#返回上一个版本 HEAD^ 上上个版本 HEAD^^</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"><span class="comment">#回到未来的那个被去掉的版本，找到commit id</span></span><br><span class="line">git reset --hard 1094a</span><br><span class="line">git reflog <span class="comment">#可以查看每次每次命令从而找到commit id</span></span><br></pre></td></tr></table></figure>
<h2 id="工作区和暂存区"><a class="header-anchor" href="#工作区和暂存区">¶</a>工作区和暂存区</h2>
<pre><code>工作区：每次的working directory, 比如/learngit
版本库：工作区中的隐藏目录 /learngit/.git
暂存区：版本库中的stage(index)。暂存区自动创建第一个分支 master， 并创建一个指针head指向master。
工作流程：git add的时候将文件的修改存入暂存区，git commit将暂存区的所有内容提交到当前分支
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看stage</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#查看工作区和版本库里文件的不同</span></span><br><span class="line">git diff HEAD -- readme.txt</span><br></pre></td></tr></table></figure>
<h2 id="撤销修改"><a class="header-anchor" href="#撤销修改">¶</a>撤销修改</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Level 1: 返回到修改的上一个状态</span></span><br><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure>
<p>有两种情况：<br>
一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>
一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>
（后续的分支管理，也会有check out， <em>–</em> 这个很关键）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Level 2: 可以从暂存区回退至工作区，HEAD表示最新版本</span></span><br><span class="line">git reset HEAD readme.txt</span><br><span class="line"><span class="comment">#再接上 git checkout --readme.txt 彻底消失</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Level 3: 版本回退</span></span><br></pre></td></tr></table></figure>
<h2 id="删除文件"><a class="header-anchor" href="#删除文件">¶</a>删除文件</h2>
<ol>
<li>确实删除文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在工作区删除了文件</span></span><br><span class="line">rm test.txt</span><br><span class="line"><span class="comment">#git status会提</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#在版本库里删除文件</span></span><br><span class="line">it rm test.txt</span><br><span class="line"><span class="comment">#确认提交</span></span><br><span class="line">git commit -m <span class="string">"remove test.txt"</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>误删了</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用返回上一个状态来还原，其实是从版本库中替换回来</span></span><br><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库"><a class="header-anchor" href="#远程仓库">¶</a>远程仓库</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在git库里添加sshkey</span></span><br><span class="line">ssh-add <span class="string">"你的 id-rsa 文件地址"</span></span><br><span class="line"><span class="comment">#将本地内容推送到远程 远程库名字：origin</span></span><br><span class="line">git remote add origin git@github.com:noonett/learngit.git</span><br><span class="line"><span class="comment">#将github仓库的内容git pull下来</span></span><br><span class="line">git pull origin master --allow-unrelated-histories</span><br><span class="line"><span class="comment">#将本地库master分支推送到远端， </span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="comment">#-u是关联起来，之后就可以不带-u了</span></span><br></pre></td></tr></table></figure>
<h2 id="￼8"><a class="header-anchor" href="#￼8">¶</a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#克隆仓库下来, 支持https和ssh，ssh是原生的速度更快</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;url&gt;</span><br></pre></td></tr></table></figure></h2>
<h2 id="分支管理"><a class="header-anchor" href="#分支管理">¶</a>分支管理</h2>
<pre><code>HEAD指向的是当前分支，master是主分支。创建新分支实际上就是创建一个新指针，每次修改，让指针往前一步，工作区的文件没有改变。合并分支实际就是把新分支跟master合并
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建新分支，-b表示切换到这个分支</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="comment">#查看当前分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="comment">#切换分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="comment">#合并分支</span></span><br><span class="line">git merge dev</span><br><span class="line"><span class="comment">#删除分支 delete （强行删除 -D）</span></span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>
<pre><code>如果合并有冲突，则需要修改文件，再重新提交。
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看合并分支图</span></span><br><span class="line">git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure>
<h3 id="bug管理"><a class="header-anchor" href="#bug管理">¶</a>bug管理</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存工作现场</span></span><br><span class="line">git stash</span><br><span class="line"><span class="comment">#查看工作现场</span></span><br><span class="line">git stash list</span><br><span class="line"><span class="comment">#恢复工作现场</span></span><br><span class="line">git stash apply</span><br><span class="line">git stash drop</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">git stash pop</span><br><span class="line"><span class="comment">#可以恢复指定现场</span></span><br><span class="line">git stash pop stash@&#123;&#125;</span><br><span class="line"><span class="comment">#复制一个修改到当前分支</span></span><br><span class="line">git cherry-pick &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<h3 id="多人合作"><a class="header-anchor" href="#多人合作">¶</a>多人合作</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看远程库 -v详情</span></span><br><span class="line">git remote -vg</span><br><span class="line"><span class="comment">#创建远程的dev分支到本地</span></span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line"><span class="comment">#远程仓库有新的提交起了冲突则需要pull下来，本地合并，解决冲突</span></span><br><span class="line">git pull</span><br><span class="line"><span class="comment">#如果提示no tracking information则：</span></span><br><span class="line"><span class="comment">#指定本地dev分支与远程origin/dev分支的链接，再pull</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure>
<h3 id="rebase"><a class="header-anchor" href="#rebase">¶</a>rebase</h3>
<ul>
<li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li>
<li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。试得维护commit记录变得简单清晰。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase</span><br></pre></td></tr></table></figure>
<ul>
<li>远程push master，遇到了冲突，可以rebase来避免三方合并，即变基：</li>
</ul>
<h2 id="￼14"><a class="header-anchor" href="#￼14">¶</a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br><span class="line"><span class="comment">#rebase之后就修改冲突，然后continue（不用commit）</span></span><br><span class="line">git add readme.txt</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line"><span class="comment">#切换回master快速合并</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure></h2>
<h2 id="标签管理"><a class="header-anchor" href="#标签管理">¶</a>标签管理</h2>
<pre><code>给commit打上标签，便于版本管理。
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加标签 -a指代标签名 -m留下备注</span></span><br><span class="line">git tag -a v0.1 -m <span class="string">"version 0.1 released"</span> 1094adb</span><br><span class="line"><span class="comment">#查看标签</span></span><br><span class="line">git tag</span><br><span class="line"><span class="comment">#查看标签信息</span></span><br><span class="line">git show &lt;tagname&gt;</span><br><span class="line"><span class="comment">#删除标签</span></span><br><span class="line">git tag -d v0.1</span><br><span class="line"><span class="comment">#推送标签到远端</span></span><br><span class="line">git push origin v1.0</span><br><span class="line">git push origin --tags  <span class="comment">#推送所有的标签</span></span><br><span class="line"><span class="comment">#删除远程的标签</span></span><br><span class="line">git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵与Numpy</title>
    <url>/2020/02/24/Math/</url>
    <content><![CDATA[<h1>矩阵乘法实现</h1>
<pre><code>这个函数还是很简单的，就是对应位置相乘就完事了，最后再用numpy来确认一下函数的正确性。
</code></pre>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Matrix_multiplication</span><span class="params">(A,B, data = [])</span>:</span></span><br><span class="line">    C = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> A) <span class="keyword">or</span> (<span class="keyword">not</span> B):</span><br><span class="line">        <span class="keyword">return</span> C</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        row = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(B[<span class="number">0</span>])):</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(range(len(A[<span class="number">0</span>])),range(len(B))):</span><br><span class="line">                temp += A[i][a] * B[b][j]</span><br><span class="line">            row.append(temp)</span><br><span class="line">        C.append(row)</span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">        row.append(i+j)</span><br><span class="line">    A.append(row)</span><br><span class="line">print(<span class="string">'A:'</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> A:</span><br><span class="line">    print(row) </span><br><span class="line">    </span><br><span class="line">B = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">9</span>):</span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">        row.append(i+j)</span><br><span class="line">    B.append(row)</span><br><span class="line">print(<span class="string">'B:'</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> B:</span><br><span class="line">    print(row)</span><br></pre></td></tr></table></figure>
<pre><code>A:
[2, 3, 4, 5, 6, 7]
[3, 4, 5, 6, 7, 8]
[4, 5, 6, 7, 8, 9]
[5, 6, 7, 8, 9, 10]
[6, 7, 8, 9, 10, 11]
[7, 8, 9, 10, 11, 12]
B:
[3, 4, 5, 6, 7, 8]
[4, 5, 6, 7, 8, 9]
[5, 6, 7, 8, 9, 10]
[6, 7, 8, 9, 10, 11]
[7, 8, 9, 10, 11, 12]
[8, 9, 10, 11, 12, 13]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#A = []</span></span><br><span class="line">Matrix_multiplication(A,B)</span><br></pre></td></tr></table></figure>
<pre><code>[[166, 193, 220, 247, 274, 301],
 [199, 232, 265, 298, 331, 364],
 [232, 271, 310, 349, 388, 427],
 [265, 310, 355, 400, 445, 490],
 [298, 349, 400, 451, 502, 553],
 [331, 388, 445, 502, 559, 616]]
</code></pre>
<h1>Numpy</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>)])</span><br><span class="line">b = np.array([</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>)])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#矩阵乘法</span></span><br><span class="line">np.dot(a,b)</span><br></pre></td></tr></table></figure>
<pre><code>array([[166, 193, 220, 247, 274, 301],
       [199, 232, 265, 298, 331, 364],
       [232, 271, 310, 349, 388, 427],
       [265, 310, 355, 400, 445, 490],
       [298, 349, 400, 451, 502, 553],
       [331, 388, 445, 502, 559, 616]])
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#矩阵加减</span></span><br><span class="line">print(a + b)</span><br><span class="line"><span class="comment">#矩阵平方</span></span><br><span class="line">print(a**<span class="number">2</span>)</span><br><span class="line"><span class="comment">#矩阵转置</span></span><br><span class="line">print(a.T)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 5  7  9 11 13 15]
 [ 7  9 11 13 15 17]
 [ 9 11 13 15 17 19]
 [11 13 15 17 19 21]
 [13 15 17 19 21 23]
 [15 17 19 21 23 25]]
[[  4   9  16  25  36  49]
 [  9  16  25  36  49  64]
 [ 16  25  36  49  64  81]
 [ 25  36  49  64  81 100]
 [ 36  49  64  81 100 121]
 [ 49  64  81 100 121 144]]
[[ 2  3  4  5  6  7]
 [ 3  4  5  6  7  8]
 [ 4  5  6  7  8  9]
 [ 5  6  7  8  9 10]
 [ 6  7  8  9 10 11]
 [ 7  8  9 10 11 12]]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回逆矩阵</span></span><br><span class="line">c = np.array([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">print(np.linalg.inv(c))</span><br><span class="line"><span class="comment"># 矩阵的迹</span></span><br><span class="line">print(np.trace(c))</span><br></pre></td></tr></table></figure>
<pre><code>[[-2.   1. ]
 [ 1.5 -0.5]]
5.0
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 特征值和特征向量</span></span><br><span class="line">eigenvalues, eigenvector = np.linalg.eig(c)</span><br><span class="line">print(eigenvalues)</span><br><span class="line">print(eigenvector)</span><br></pre></td></tr></table></figure>
<pre><code>[-0.37228132  5.37228132]
[[-0.82456484 -0.41597356]
 [ 0.56576746 -0.90937671]]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取豆瓣电影前250的数据</title>
    <url>/2020/02/23/douban_movie-3/</url>
    <content><![CDATA[<pre><code>爬一下豆瓣top250的电影做一下练习，今天效率比较低只做了一点，明天做完再重构一下代码，用多线程实现。
2/24 封装了函数，最近得上课，慢慢更新了。
</code></pre>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> lxml</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br></pre></td></tr></table></figure>
<h1>发送请求</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#send request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_request</span><span class="params">(url, headers)</span>:</span></span><br><span class="line">    r = requests.get(url,headers=headers)</span><br><span class="line">    print(r.status_code)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h1>提取数据</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#fetch data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(resp, headers)</span>:</span></span><br><span class="line">    selector = lxml.etree.HTML(resp.text)    <span class="comment">#generate object</span></span><br><span class="line">    titles = selector.xpath(<span class="string">'//div[@class = "hd"]/a/span[1]/text()'</span>)<span class="comment">#fetching titles of movies       </span></span><br><span class="line">    urls = selector.xpath(<span class="string">'//div[@class = "hd"]/a/@href'</span>) <span class="comment">#fetching urls of description</span></span><br><span class="line">    <span class="comment">#visit the url to fetch the descriptions</span></span><br><span class="line">    movie_text = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        sub_r = requests.get(url,headers=headers)</span><br><span class="line">        selector = lxml.etree.HTML(sub_r.text)</span><br><span class="line">        url_text = <span class="string">' '</span>.join(selector.xpath(<span class="string">'//span[@property="v:summary"]/text()'</span>)).replace(<span class="string">' '</span>,<span class="string">''</span>).replace(<span class="string">'\n'</span>,<span class="string">''</span>).replace(<span class="string">'\u3000'</span>,<span class="string">''</span>)</span><br><span class="line">        movie_text.append(url_text)        </span><br><span class="line">    <span class="comment">#zip the content together</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    data.update(zip(titles,movie_text))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<h1>存入文件中</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        filepath = os.curdir</span><br><span class="line">        filename = <span class="string">'douban_top250.txt'</span>  </span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">'DouBan Movie--Top 250'</span>)</span><br><span class="line">            <span class="keyword">for</span> key,value <span class="keyword">in</span> data.items():</span><br><span class="line">                f.write(<span class="string">'\n\n'</span>)</span><br><span class="line">                f.write(key)</span><br><span class="line">                f.write(<span class="string">'\n'</span>)</span><br><span class="line">                f.write(value)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'Download error!!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Download success!!'</span>)</span><br></pre></td></tr></table></figure>
<h1>主函数</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#main, 循环实现翻页</span></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chro'</span></span><br><span class="line">                      <span class="string">'me/53.0.2785.104 Safari/537.36 Core/1.53.2372.400 QQBrowser/9.5.10548.400'</span></span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">data = &#123;&#125;</span><br><span class="line"><span class="keyword">while</span>(a != <span class="number">250</span>):</span><br><span class="line">    url =  <span class="string">"https://movie.douban.com/top250?start="</span>+ str(a) +<span class="string">"&amp;filter="</span></span><br><span class="line">    resp = send_request(url, headers)</span><br><span class="line">    data_chunk = fetch(resp, headers)</span><br><span class="line">    data.update(data_chunk)</span><br><span class="line">    a += <span class="number">25</span></span><br><span class="line">download(data)</span><br></pre></td></tr></table></figure>
<pre><code>200
200
200
200
200
200
200
200
200
200
Download success!!
</code></pre>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>beatiful-soup和lxml</title>
    <url>/2020/02/20/beatiful-soup/</url>
    <content><![CDATA[<p>beautiful soup是一个从html或xml文件中提取数据的python库，很方便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> beautifulsoup</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html_doc = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">'html.parser'</span>) <span class="comment">#创建一个soup对象</span></span><br><span class="line">print(soup.prettify()) <span class="comment">#标准格式输出</span></span><br></pre></td></tr></table></figure>
<h2 id="浏览结构化数据"><a class="header-anchor" href="#浏览结构化数据">¶</a>浏览结构化数据</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.title <span class="comment">#获取title</span></span><br><span class="line">soup.a.attrs <span class="comment">#取出a标签的树型</span></span><br><span class="line">soup.find(id=<span class="string">'link3'</span>) <span class="comment">#</span></span><br><span class="line"><span class="comment">#找到所有a标签的链接，find_all('')返回的是list</span></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">    print(link.get(<span class="string">'href'</span>))</span><br><span class="line">    <span class="comment"># http://example.com/elsie</span></span><br><span class="line">    <span class="comment"># http://example.com/lacie</span></span><br><span class="line">    <span class="comment"># http://example.com/tillie</span></span><br><span class="line">print(soup.get_text()) <span class="comment">#获取所有文字内容</span></span><br></pre></td></tr></table></figure>
<h2 id="支持css选择器"><a class="header-anchor" href="#支持css选择器">¶</a>支持css选择器</h2>
<h2 id="￼3"><a class="header-anchor" href="#￼3">¶</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.select(<span class="string">'.story'</span>) <span class="comment">#查找类名为story的类标签</span></span><br><span class="line">soup.select(<span class="string">'#link'</span>) <span class="comment">#tag id查找也可以</span></span><br></pre></td></tr></table></figure></h2>
<h1>lxml</h1>
<p>用lxml作为解析的引擎。底层是c写的，速度比较快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup_lxml = BeautifulSoup(html_doc, <span class="string">'lxml'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="xpath"><a class="header-anchor" href="#xpath">¶</a>xpath</h2>
<p>xpath的性能挺不错，xml文档中查找信息的语言。</p>
<h3 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h3>
<h4 id="Node-节点"><a class="header-anchor" href="#Node-节点">¶</a>Node: 节点</h4>
<p>元素，属性，文本，命名空间，文档（根）节点</p>
<h4 id="节点关系"><a class="header-anchor" href="#节点关系">¶</a>节点关系</h4>
<p>Parent 父<br>
Children 子<br>
Sibling：同胞，共用parent<br>
Ancestor：先辈<br>
Descendant：后代</p>
<h3 id="xpath语法"><a class="header-anchor" href="#xpath语法">¶</a>xpath语法</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodename</td>
<td style="text-align:center">选取此节点的所有子节点的文本</td>
</tr>
<tr>
<td>//</td>
<td style="text-align:center">从任意子节点中选取文本</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:center">从根节点中选取(已选择的节点的节点中)</td>
</tr>
<tr>
<td>.</td>
<td style="text-align:center">表示选取当前节点</td>
</tr>
<tr>
<td>…</td>
<td style="text-align:center">表示选取当前节点的父节点</td>
</tr>
<tr>
<td>@</td>
<td style="text-align:center">选取属性</td>
</tr>
</tbody>
</table>
<h2 id="￼5"><a class="header-anchor" href="#￼5">¶</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">r = requests.get(<span class="string">'http://iguye.com/books.xml'</span>)</span><br><span class="line">se = etree.HTML(r.text) <span class="comment">#创建一个选择器对象</span></span><br><span class="line">print(se.xpath(<span class="string">'//book'</span>)) <span class="comment">#//表示从任意子节点中选取</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book/author/text()'</span>)) <span class="comment">#选取书店下所有的书本的作者名字</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book/title/@lang'</span>))<span class="comment">#选取书店下所有的书本的语言信息</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[1]/title/text()'</span>)) <span class="comment">#第一本书</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[last()]/title/text()'</span>)) <span class="comment">#最后一本书</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[last()-1]/title/text()'</span>)) <span class="comment">#倒数第二本书</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[position()&lt;3]/title/text()'</span>)) <span class="comment">#前两本书</span></span><br><span class="line">print(se.xpath(<span class="string">'//book[@category="web"]/title/text()'</span>))<span class="comment">#选取所有分类为web的节点</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[price&gt;3]/price/text()'</span>))<span class="comment">#选取所有价格大于30.0元的书本</span></span><br><span class="line">print(se.xpath(<span class="string">'//bookstore/book[contains(@class,"book")]/@class/text()'</span>))<span class="comment">#类名中包含book的书本</span></span><br></pre></td></tr></table></figure></h2>
<h1>解析器比较</h1>
<p>re虽然速度最快，但是学习成本高。beautifulsoup则较慢。所有折中的方案选择lxml为佳。</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>requests</title>
    <url>/2020/02/19/requests/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br></pre></td></tr></table></figure>
<p>requests比标准库的urllib方便很多，代码也很简洁明了。</p>
<a id="more"></a>
<h1>发送请求</h1>
<h2 id="request发送get和post请求"><a class="header-anchor" href="#request发送get和post请求">¶</a>request发送get和post请求</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://api.github.com/events'</span>) <span class="comment">#发送get请求</span></span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;) <span class="comment">#发送post请求</span></span><br></pre></td></tr></table></figure>
<h2 id="传递url参数"><a class="header-anchor" href="#传递url参数">¶</a>传递url参数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: [<span class="string">'value2'</span>, <span class="string">'value3'</span>]&#125; <span class="comment">#可以添加一个列表</span></span><br><span class="line">r = requests.get(<span class="string">'https://api.github.com/events'</span>, params = payload) </span><br><span class="line">print(r.url) <span class="comment">#URL会被正确编码</span></span><br><span class="line"><span class="comment">#字典中的None值不会被添加到URL里</span></span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;) <span class="comment">#发送post请求</span></span><br><span class="line"><span class="comment">#http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</span></span><br></pre></td></tr></table></figure>
<h2 id="响应内容"><a class="header-anchor" href="#响应内容">¶</a>响应内容</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r.text    <span class="comment">#响应报文</span></span><br><span class="line">r.encoding <span class="comment">#查看编码方式</span></span><br><span class="line">r.encoding = <span class="string">'ISO-8859-1'</span> <span class="comment">#改变响应报文的编码方式</span></span><br><span class="line">r.content <span class="comment">#原本的报文</span></span><br><span class="line">r.json()  <span class="comment">#json解码</span></span><br></pre></td></tr></table></figure>
<h2 id="定制请求头"><a class="header-anchor" href="#定制请求头">¶</a>定制请求头</h2>
<h3 id="自定义user-agent"><a class="header-anchor" href="#自定义user-agent">¶</a>自定义user-agent</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ua = <span class="string">' Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Safari/605.1.15'</span></span><br><span class="line">headers = &#123;<span class="string">'user-agent'</span>:ua&#125;</span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/headers'</span>, headers = headers)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
<h3 id="cookie"><a class="header-anchor" href="#cookie">¶</a>cookie</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cookies = dict(userid = <span class="string">'123456'</span>, token = <span class="string">'#####'</span>)</span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/cookies'</span>, cookies = cookies)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
<h3 id="basic-auth认证"><a class="header-anchor" href="#basic-auth认证">¶</a>basic-auth认证</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">'http://httpbin.org/basic-auth/xxx/1123'</span>, auth = (<span class="string">'xxx'</span>,<span class="string">'1123'</span>))</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
<h3 id="状态码"><a class="header-anchor" href="#状态码">¶</a>状态码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">'http://httpbin.org/status/404'</span>)</span><br><span class="line">r.status_code</span><br><span class="line">r.raise_for_status() <span class="comment">#抛出异常，4xx和5xx的</span></span><br></pre></td></tr></table></figure>
<h3 id="session对象"><a class="header-anchor" href="#session对象">¶</a>session对象</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#session对象会保存服务器返回的set-cookie头信息里的内容</span></span><br><span class="line">s = requests.session()</span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/userid/123456789'</span>)</span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/token/######'</span>)</span><br><span class="line"><span class="comment">#下一次请求会将本地所有的cookies信息自动添加到请求头信息里</span></span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
<h3 id="在requests中使用代理"><a class="header-anchor" href="#在requests中使用代理">¶</a>在requests中使用代理</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'不使用代理：'</span>, requests.get(<span class="string">'http://httpbin.org/ip'</span>).json())</span><br><span class="line">print(<span class="string">'使用代理：'</span>,requests.get(<span class="string">'http://httpbin.org/ip'</span>, proxies=&#123;<span class="string">'http'</span>:<span class="string">'http://iguye.com:41801'</span>&#125;).json())</span><br></pre></td></tr></table></figure>
<h3 id="超时报错"><a class="header-anchor" href="#超时报错">¶</a>超时报错</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">'http://httpbin.org/delay/5'</span>,timeout = <span class="number">5</span>)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>url结构</title>
    <url>/2020/02/19/url%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:right">scheme</th>
<th style="text-align:center">Domain</th>
<th style="text-align:center">port</th>
<th style="text-align:center">path</th>
<th style="text-align:center">pathinfo</th>
<th style="text-align:left">Query string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">http:</td>
<td style="text-align:center"><a href="//localhost" target="_blank" rel="noopener">//localhost</a>:</td>
<td style="text-align:center">4000/</td>
<td style="text-align:center">2020/02/19/</td>
<td style="text-align:center">requests/</td>
<td style="text-align:left">#more</td>
</tr>
</tbody>
</table>
<center>url结构</center>
<a id="more"></a>
从上面的URL可以看出，一个完整的URL包括以下几部分：
<p>1、协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&quot;HTTP&quot;后面的“//”为分隔符</p>
<p>2、域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com" target="_blank" rel="noopener">www.aspxfans.com</a>”。一个URL中，也可以使用IP地址作为域名使用</p>
<p>3、端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口80</p>
<p>4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>
<p>5、文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
<p>6、锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>
<p>7、参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>curl和wget</title>
    <url>/2020/02/18/curl%E5%92%8Cwget%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h1>curl</h1>
<p>curl是系统自带的c库，简单过一下，记录一下参数。<br>
不带参数就是，GET请求。</p>
<a id="more"></a>
<h2 id="A"><a class="header-anchor" href="#A">¶</a>-A</h2>
<p>指定客户端的代理标头</p>
<h2 id="B"><a class="header-anchor" href="#B">¶</a>-B</h2>
<p>发送cookie</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b <span class="string">'foo1=bar;foo2=bar2'</span> https://google.com</span><br></pre></td></tr></table></figure>
<h2 id="X"><a class="header-anchor" href="#X">¶</a>-X</h2>
<p>用指定方式请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X Post https://google.com</span><br></pre></td></tr></table></figure>
<h2 id="d"><a class="header-anchor" href="#d">¶</a>-d</h2>
<p>用Post请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">"a=1&amp;b=1"</span> https://google.com</span><br></pre></td></tr></table></figure>
<h2 id="L"><a class="header-anchor" href="#L">¶</a>-L</h2>
<p>跟随服务器重定向</p>
<h2 id="H"><a class="header-anchor" href="#H">¶</a>-H</h2>
<p>设置http请求头信息</p>
<h2 id="k"><a class="header-anchor" href="#k">¶</a>-k</h2>
<p>跳过ssl检测(https)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://www.example.com</span><br></pre></td></tr></table></figure>
<h2 id="O"><a class="header-anchor" href="#O">¶</a>-O</h2>
<p>以远程的文件名下载保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://httpbin.org/image/jpeg</span><br></pre></td></tr></table></figure>
<h2 id="o"><a class="header-anchor" href="#o">¶</a>-o</h2>
<p>以自定的文件名下载保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o wolf.jpeg https://httpbin.org/image/jpeg</span><br></pre></td></tr></table></figure>
<h2 id="s"><a class="header-anchor" href="#s">¶</a>-s</h2>
<p>不显示无关信息</p>
<h2 id="v"><a class="header-anchor" href="#v">¶</a>-v</h2>
<p>显示所有信息</p>
<hr>
<h1>wget</h1>
<p>系统自带的下载文件的工具。</p>
<h2 id="O-v2"><a class="header-anchor" href="#O-v2">¶</a>-O</h2>
<p>以指定文件名存文件</p>
<h2 id="–limit-rate"><a class="header-anchor" href="#–limit-rate">¶</a>–limit-rate=</h2>
<p>限速</p>
<h2 id="c"><a class="header-anchor" href="#c">¶</a>-c</h2>
<p>断点续传</p>
<h2 id="b"><a class="header-anchor" href="#b">¶</a>-b</h2>
<p>后台下载</p>
<h2 id="U"><a class="header-anchor" href="#U">¶</a>-U</h2>
<p>设置user-agent</p>
<h2 id="mirror"><a class="header-anchor" href="#mirror">¶</a>-mirror</h2>
<p>镜像某个网站</p>
<h2 id="p"><a class="header-anchor" href="#p">¶</a>-p</h2>
<p>下载网页的所有内容</p>
<h2 id="r"><a class="header-anchor" href="#r">¶</a>-r</h2>
<p>递归下载所有网页中所有链接</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>http(超文本传输协议)</title>
    <url>/2020/02/17/http%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<pre><code>基于TCP/IP的应用层协议，客户端和服务端数据传输的格式，默认端口：80。 基于请求与响应模式，无状态。
</code></pre>
<a id="more"></a>
<h1>http header</h1>
<h2 id="请求报文"><a class="header-anchor" href="#请求报文">¶</a>请求报文</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;test.php HTTP&#x2F;1.1               &#x2F;&#x2F;请求行</span><br><span class="line">HOST：www.test.com                    &#x2F;&#x2F;请求头</span><br><span class="line">User-Agent：Mozilla&#x2F;5.0 （windows NT 6.1；rv：15.0）Gecko&#x2F;20100101 Firefox&#x2F;15.0        </span><br><span class="line">                                    &#x2F;&#x2F;空白行，代表请求头结束</span><br><span class="line">Username&#x3D;admin&amp;password&#x3D;admin       &#x2F;&#x2F;请求正文</span><br></pre></td></tr></table></figure>
<p>请求行：请求方式 + 请求资源路径 + 版本<br>
请求头：发起请求的主机信息<br>
正文：  optional</p>
<h3 id="请求头"><a class="header-anchor" href="#请求头">¶</a>请求头</h3>
<ul>
<li>Host 请求报头域主要用于指定被请求资源的Internet主机和端口。</li>
<li>User-Agent 请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。</li>
<li>Referer 包含一个URL，代表当前访问URL的上一个URL，也就是说，用户是从什么地方来到本页面。当前请求的原始URL地址。</li>
<li>Cookie 是非常重要的请求头，常用来表示请求者的身份等。</li>
<li>Accept 这个消息头用于告诉服务器客户端愿意接受那些内容，比如图像类，办公文档格式等等。</li>
</ul>
<h3 id="请求方式"><a class="header-anchor" href="#请求方式">¶</a>请求方式</h3>
<p><img src="http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png" alt="http请求方式"></p>
<hr>
<h2 id="响应报文"><a class="header-anchor" href="#响应报文">¶</a>响应报文</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK   					 &#x2F;&#x2F;响应行</span><br><span class="line">Date: Sun, 15 Nov 2015 11:02:04 GMT    &#x2F;&#x2F;响应头</span><br><span class="line">Server: bfe&#x2F;1.0.8.9</span><br><span class="line">Content-Length: 2605</span><br><span class="line">Content-Type: application&#x2F;javascript</span><br><span class="line">Cache-Control: max-age&#x3D;315360000</span><br><span class="line">Expires: Fri, 13 Jun 2025 09:54:00 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Set-Cookie: H_PS_PSSID&#x3D;2022_1438_1944_1788; path&#x3D;&#x2F;; domain&#x3D;test.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">					      &#x2F;&#x2F;空白行，代表响应头结束</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt; Index.html &lt;&#x2F;title&gt;&lt;&#x2F;head&gt;  &#x2F;&#x2F;响应正文消息主题</span><br></pre></td></tr></table></figure>
<p>响应行：版本+状态码<br>
响应头：服务端的信息</p>
<h3 id="响应头"><a class="header-anchor" href="#响应头">¶</a>响应头</h3>
<p><img src="http%E5%93%8D%E5%BA%94%E5%A4%B4.png" alt="http响应头"></p>
<h3 id="状态码"><a class="header-anchor" href="#状态码">¶</a>状态码</h3>
<p>常见的状态码描述如下：</p>
<ul>
<li>200：客户端请求成功，是最常见的状态。</li>
<li>302：重定向。</li>
<li>404：请求资源不存在，是最常见的状态。</li>
<li>400：客户端请求有语法错误，不能被服务器所理解。</li>
<li>401：请求未经授权。</li>
<li>403：服务器收到请求，但是拒绝提供服务。</li>
<li>500：服务器内部错误，是最常见的状态。</li>
<li>503：服务器当前不能处理客户端的请求。</li>
</ul>
<hr>
<h2 id="Q-A"><a class="header-anchor" href="#Q-A">¶</a>Q&amp;A</h2>
<ul>
<li>
<p>get和post的区别<br>
get请求的参数在url后面添加<br>
post在请求体中间</p>
</li>
<li>
<p>https加ssl, tsl, 证书</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客是怎么创建的</title>
    <url>/2020/02/16/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>简单记录一下，博客的创建过程。</p>
<a id="more"></a>
<h2 id="安装环境"><a class="header-anchor" href="#安装环境">¶</a>安装环境</h2>
<pre><code>在创建博客之前，首先要有Github账号，还有确保系统里有git工具。
</code></pre>
<hr>
<h4 id="下载hexo"><a class="header-anchor" href="#下载hexo">¶</a>下载hexo</h4>
<ol>
<li>直接去nodejs.org官网下载node.js</li>
<li>打开terminal下载hexo需要用到node.js的npm安装包管理器:</li>
</ol>
<h2 id="￼0"><a class="header-anchor" href="#￼0">¶</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su                     ##获取最高权限</span><br><span class="line">npm install -g cnpm --registry&#x3D;&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org </span><br><span class="line">                            ##淘宝的镜像源，用cnpm下载比较快</span><br><span class="line">cnpm intall -g hexo-cli     ##开始下载hexo</span><br></pre></td></tr></table></figure></h2>
<h2 id="创建博客"><a class="header-anchor" href="#创建博客">¶</a>创建博客</h2>
<h4 id="初始化博客"><a class="header-anchor" href="#初始化博客">¶</a>初始化博客</h4>
<p>创建博客的代码也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog                     ##创个文件夹好管理</span><br><span class="line">sudo hexo init              ##初始化hexo</span><br><span class="line">hexo s                      ##可以在本地看一下，blog的模版，后续添加了内容也可以用这个指令去预览</span><br></pre></td></tr></table></figure>
<h3 id="创建新文章"><a class="header-anchor" href="#创建新文章">¶</a>创建新文章</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new 文章名.md</span><br></pre></td></tr></table></figure>
<p>一行代码即创建markdown格式的文章，也可以自己直接创建，一般存在 /blog/source/_posts 的路径下。</p>
<hr>
<h2 id="配置到远端仓库"><a class="header-anchor" href="#配置到远端仓库">¶</a>配置到远端仓库</h2>
<h4 id="创建github仓库"><a class="header-anchor" href="#创建github仓库">¶</a>创建github仓库</h4>
<p>这一步就是在github里面创建一个repository，就是存blog文件的，repository的name一定要是 github name + .github.io, <a href="http://xn--noonett-i22mo3ry3qkvkl5qky6a.github.io" target="_blank" rel="noopener">比如我的就是noonett.github.io</a></p>
<h4 id="修过配置文件"><a class="header-anchor" href="#修过配置文件">¶</a>修过配置文件</h4>
<p>在/blog/ 路径下有一个 _config.yml 文件，进入修改，找到deploy下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: https:&#x2F;&#x2F;github.com&#x2F;noonett&#x2F;noonett.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<p>这里的repo就是repository仓库的地址。</p>
<h4 id="部署至仓库"><a class="header-anchor" href="#部署至仓库">¶</a>部署至仓库</h4>
<p>将本地现有的blog部署至远端仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>然后就有自己的博客啦： 就是你的repository名字。</p>
<h4 id="主题的更换"><a class="header-anchor" href="#主题的更换">¶</a>主题的更换</h4>
<p>主题的更换也很简单方便，网上找到主题，clone到自己的仓库里，然后修改yml里的theme改成主题的名字即可，百度上，知乎上挺多的。</p>
<hr>
<h2 id="结束语"><a class="header-anchor" href="#结束语">¶</a>结束语</h2>
<p>网上其实有很多教程，这里就是记录一下我的博客是如何创建的</p>
<hr>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<p><a href="https://www.bilibili.com/video/av44544186?from=search&amp;seid=16653039335337070050" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186?from=search&amp;seid=16653039335337070050</a>  手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>我来网上冲浪了</title>
    <url>/2020/02/16/%E6%88%91%E6%9D%A5%E7%BD%91%E4%B8%8A%E5%86%B2%E6%B5%AA%E4%BA%86/</url>
    <content><![CDATA[<h1>hello world</h1>
<p>村通网了。</p>
<a id="more"></a>
<h1>Overview</h1>
<p>近期基于github和hexo创建了这个blog，用next主题美化。</p>
<h2 id="目的"><a class="header-anchor" href="#目的">¶</a>目的</h2>
<p>记录一下学习笔记，同时也是记录一下生活，说白了就是一个笔记本吧。</p>
<h2 id="接下来"><a class="header-anchor" href="#接下来">¶</a>接下来</h2>
<p>接下来可能会做一篇blog创建的简单教程</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
