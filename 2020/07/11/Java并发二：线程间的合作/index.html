<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java并发二：线程间的合作"><meta name="keywords" content="Java,并发"><meta name="author" content="TYH"><meta name="copyright" content="TYH"><title>Java并发二：线程间的合作 | 21号避难所</title><link rel="shortcut icon" href="/images/yuhangyuanfeixiang.png"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.0.0/css/font-awesome.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-text">五、线程之间的协作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-join-%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E6%98%AFThread%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84join-%EF%BC%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%BC%9A%E6%8C%82%E8%B5%B7%E7%9B%B4%E5%88%B0%E7%9B%AE%E6%A0%87%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-text">1. join()方法用于同步，是Thread的方法，当前线程调用另一个线程的join()，当前线程会挂起直到目标线程结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-wait-%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%BB%E5%8A%A8%E6%8C%82%E8%B5%B7%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87notify-%E6%88%96%E8%80%85notifyAll-%E5%94%A4%E8%B5%B7%E8%A2%AB%E6%8C%82%E8%B5%B7%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">2. wait()方法是主动挂起当前线程，其他线程可以通过notify()或者notifyAll()唤起被挂起的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E4%B8%8Esleep-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%B1%E6%98%AF%E6%8C%82%E8%B5%B7%E4%B8%8E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">wait()与sleep()的区别就是挂起与阻塞的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-await-signal-signalAll"><span class="toc-text">3. await() signal() signalAll()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">六、线程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%EF%BC%88NEW%EF%BC%89"><span class="toc-text">新建（NEW）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BF%90%E8%A1%8C%EF%BC%88RUNABLE%EF%BC%89"><span class="toc-text">可运行（RUNABLE）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%EF%BC%88BLOCKED%EF%BC%89"><span class="toc-text">阻塞（BLOCKED）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85%EF%BC%88WAITING%EF%BC%89"><span class="toc-text">无限期等待（WAITING）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85-TIMED-WAITING"><span class="toc-text">限期等待(TIMED_WAITING)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BA%A1-TERMNATED"><span class="toc-text">死亡(TERMNATED)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81J-U-C-AQS"><span class="toc-text">七、J.U.C -AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CountDownLatch-%E5%80%92%E6%95%B0%E5%99%A8"><span class="toc-text">1. CountDownLatch 倒数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CyclicBarrier-%E5%BE%AA%E7%8E%AF%E5%B1%8F%E9%9A%9C"><span class="toc-text">2. CyclicBarrier 循环屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">3. Semaphore 信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81J-U-C-%E5%85%B6%E5%AE%83"><span class="toc-text">八、J.U.C -其它</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-FutureTask%E7%B1%BB"><span class="toc-text">1. FutureTask类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-BlockingQueue-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">2. BlockingQueue 阻塞队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ForkJoin"><span class="toc-text">3. ForkJoin</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2904152762,521104362&amp;fm=16&amp;gp=0.jpg"></div><div class="author-info__name text-center">TYH</div><div class="author-info__description text-center">反复敲打，登峰造极</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/noonett">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">159</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">56</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://pic.netbian.com/uploads/allimg/200710/220558-1594389958b5b5.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">21号避难所</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Java并发二：线程间的合作</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-11</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>继续上一章的Java并发，这一章主要是线程间的协作，包括JDK自带的join，wait， notify等方法，也有JUC的await, signal等方法，应用了几个JUC的组件，包括重要的AQS，阻塞队列等。还提及了JVM内部线程的几种状态。<br>
下一章深入一下Java多线程内部的内存模型，线程安全等原理。</p>
<a id="more"></a>
<h1>JUC</h1>
<p><img src="/2020/07/11/Java%E5%B9%B6%E5%8F%91%E4%BA%8C%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%88%E4%BD%9C/JUC.png" alt="思维导图"></p>
<h2 id="五、线程之间的协作"><a class="header-anchor" href="#五、线程之间的协作"></a>五、线程之间的协作</h2>
<h3 id="1-join-方法用于同步，是Thread的方法，当前线程调用另一个线程的join-，当前线程会挂起直到目标线程结束"><a class="header-anchor" href="#1-join-方法用于同步，是Thread的方法，当前线程调用另一个线程的join-，当前线程会挂起直到目标线程结束"></a>1. join()方法用于同步，是Thread的方法，当前线程调用另一个线程的join()，当前线程会挂起直到目标线程结束</h3>
<ul>
<li>双方都是出让CPU时间片。但是阻塞是等待某些资源。而挂起是一种用户或者系统主动对线程的操作，可能正处于就绪的状态，会释放当前线程的锁资源。</li>
</ul>
<h3 id="2-wait-方法是主动挂起当前线程，其他线程可以通过notify-或者notifyAll-唤起被挂起的线程"><a class="header-anchor" href="#2-wait-方法是主动挂起当前线程，其他线程可以通过notify-或者notifyAll-唤起被挂起的线程"></a>2. wait()方法是主动挂起当前线程，其他线程可以通过notify()或者notifyAll()唤起被挂起的线程</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait方法实际上就是把线程加入了某个对象monitor内的waitSet，当线程调用这个对象notify方法会随机从waitSet唤醒一个线程，将waitSet中的线程加入就绪的Set，重新进行锁的竞争</li>
</ul>
<h3 id="wait-与sleep-的区别就是挂起与阻塞的区别"><a class="header-anchor" href="#wait-与sleep-的区别就是挂起与阻塞的区别"></a>wait()与sleep()的区别就是挂起与阻塞的区别</h3>
<ul>
<li>
<ol>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
</ol>
</li>
<li>
<ol start="2">
<li>wait() 会释放锁，sleep() 不会。</li>
</ol>
</li>
</ul>
<h3 id="3-await-signal-signalAll"><a class="header-anchor" href="#3-await-signal-signalAll"></a>3. await() signal() signalAll()</h3>
<ul>
<li>java.util.concurrent 类库的方法，基本与wait()帮相同</li>
<li>相比于 wait() 这种等待方式，基于 Condition 的 await(), signal(), signalAll() 使得我们可以在同一个锁的代码块内， 优雅地实现基于多个条件的线程间挂起与唤醒操作。</li>
<li>使用 Lock 来获取一个 Condition 对象。</li>
</ul>
<h2 id="六、线程的状态"><a class="header-anchor" href="#六、线程的状态"></a>六、线程的状态</h2>
<p>这里的线程状态特指JVM内的线程状态</p>
<h3 id="新建（NEW）"><a class="header-anchor" href="#新建（NEW）"></a>新建（NEW）</h3>
<h3 id="可运行（RUNABLE）"><a class="header-anchor" href="#可运行（RUNABLE）"></a>可运行（RUNABLE）</h3>
<ul>
<li>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</li>
</ul>
<h3 id="阻塞（BLOCKED）"><a class="header-anchor" href="#阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h3>
<ul>
<li>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</li>
</ul>
<h3 id="无限期等待（WAITING）"><a class="header-anchor" href="#无限期等待（WAITING）"></a>无限期等待（WAITING）</h3>
<ul>
<li>等待其他线程显式的唤醒</li>
</ul>
<h3 id="限期等待-TIMED-WAITING"><a class="header-anchor" href="#限期等待-TIMED-WAITING"></a>限期等待(TIMED_WAITING)</h3>
<ul>
<li>设置了Timeout参数，一定时间后会被系统唤醒</li>
</ul>
<h3 id="死亡-TERMNATED"><a class="header-anchor" href="#死亡-TERMNATED"></a>死亡(TERMNATED)</h3>
<ul>
<li>可以是线程结束任务之后自己结束，或者产生了异常而结束。</li>
</ul>
<h2 id="七、J-U-C-AQS"><a class="header-anchor" href="#七、J-U-C-AQS"></a>七、J.U.C -AQS</h2>
<h3 id="1-CountDownLatch-倒数器"><a class="header-anchor" href="#1-CountDownLatch-倒数器"></a>1. CountDownLatch 倒数器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>是一个倒计时器，用来让一个线程或者多个线程等待多个线程执行完毕</p>
</li>
<li>
<p>维护了一个cnt量，当每次其中一个线程执行完，调用一次countDown()方法让计数器减一，当计数器为0，会自动唤醒await()的线程。</p>
</li>
<li>
<p>不足</p>
<ul>
<li>CountDownLatch是一次性的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。</li>
</ul>
</li>
</ul>
<h3 id="2-CyclicBarrier-循环屏障"><a class="header-anchor" href="#2-CyclicBarrier-循环屏障"></a>2. CyclicBarrier 循环屏障</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>控制多个线程相互等待，当多个线程到达，才会继续执行</li>
<li>同样是维护计数器，计数器为0，所有调用await()方法而等待的线程才能继续执行</li>
<li>与CountDownLatch方法不同的是，可以通过reset()方法循环使用</li>
<li>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</li>
</ul>
<h3 id="3-Semaphore-信号量"><a class="header-anchor" href="#3-Semaphore-信号量"></a>3. Semaphore 信号量</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类似于操作系统的信号量，控制对互斥资源访问的线程数</li>
</ul>
<h2 id="八、J-U-C-其它"><a class="header-anchor" href="#八、J-U-C-其它"></a>八、J.U.C -其它</h2>
<h3 id="1-FutureTask类"><a class="header-anchor" href="#1-FutureTask类"></a>1. FutureTask类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;other task is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现了RunnableFuture接口，可以作为任务执行和获取返回值</li>
<li>主要用于异步获取执行结果</li>
</ul>
<h3 id="2-BlockingQueue-阻塞队列"><a class="header-anchor" href="#2-BlockingQueue-阻塞队列"></a>2. BlockingQueue 阻塞队列</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者消费者模型实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;produce..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;consume..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>三种实现</p>
<ul>
<li>
<p>FIFO队列</p>
<ul>
<li>LinkedBlockingQueue</li>
<li>ArrayBlockingQueue: 固定长度</li>
</ul>
</li>
<li>
<p>优先级队列</p>
<ul>
<li>PriorityBlockingQueue</li>
</ul>
</li>
</ul>
</li>
<li>
<p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p>
</li>
</ul>
<h3 id="3-ForkJoin"><a class="header-anchor" href="#3-ForkJoin"></a>3. ForkJoin</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>并行计算，将大任务拆分成多个小任务并行计算</p>
</li>
<li>
<p>ForkJoin使用了ForkJoinPool来启动，它是一个线程池，线程数量取决于CPU的核心数</p>
</li>
<li>
<p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。</p>
<p>Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p>
</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/15/Java%E5%B9%B6%E5%8F%91%E4%B8%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><i class="fa fa-chevron-left">  </i><span>Java并发三：Java内存模型和线程安全</span></a></div><div class="next-post pull-right"><a href="/2020/07/09/Java%E5%B9%B6%E5%8F%91%E4%B8%80%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81/"><span>Java并发一：多线程和锁</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://pic.netbian.com/uploads/allimg/200710/220558-1594389958b5b5.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By TYH</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>