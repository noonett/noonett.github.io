<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Comparison of Write Ahead Log between MySQL and mongodb"><meta name="keywords" content="数据库,NoSQL"><meta name="author" content="TYH"><meta name="copyright" content="TYH"><title>Comparison of Write Ahead Log between MySQL and mongodb | 21号避难所</title><link rel="shortcut icon" href="/images/yuhangyuanfeixiang.png"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.0.0/css/font-awesome.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Log-format"><span class="toc-text">Log format</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Journal-Records-in-MongoDB"><span class="toc-text">1. Journal Records in MongoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Mini-Transaction-in-MySQL-in-terms-of-Document-Data-Model"><span class="toc-text">2. Mini-Transaction in MySQL in terms of Document Data Model</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File-Storage"><span class="toc-text">File Storage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Incremental-files-writing-In-MongoDB"><span class="toc-text">1. Incremental files writing In MongoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Circular-files-writing-In-MySQL"><span class="toc-text">2. Circular files writing In MySQL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mechanism"><span class="toc-text">Mechanism</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Journaling-Mechanism-in-MongoDB"><span class="toc-text">1. Journaling Mechanism in MongoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Redo-Log-Mechanism-in-MySQL"><span class="toc-text">2. Redo Log Mechanism in MySQL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Experiment"><span class="toc-text">Experiment</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hardware"><span class="toc-text">Hardware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Experiment-1"><span class="toc-text">Experiment 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Experimental-setup"><span class="toc-text">1. Experimental setup:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Experimental-Result"><span class="toc-text">2. Experimental Result</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Experiment-2"><span class="toc-text">Experiment 2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Experimental-setup-v2"><span class="toc-text">1. Experimental setup:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Experimental-Result-v2"><span class="toc-text">2. Experimental Result</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Discussion"><span class="toc-text">Discussion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2904152762,521104362&amp;fm=16&amp;gp=0.jpg"></div><div class="author-info__name text-center">TYH</div><div class="author-info__description text-center">反复敲打，登峰造极</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/noonett">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">162</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">57</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://pic.netbian.com/uploads/allimg/200710/220558-1594389958b5b5.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">21号避难所</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Comparison of Write Ahead Log between MySQL and mongodb</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-12</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 17 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>做的Redo Log和Journal的对比研究，资料源于两个数据库公开的文档，并设置了基于Python多进程的两个实验测试，主要是通过读系统变量获取数据库数据，并通过可视化分析来分析结果。<br>
Write Ahead Log is one of the important features that affects the persistence of a document data model. MySQL and MongoDB, to improve efficiency of write operation. However, if the database instance suddenly fails, the data in the buffer which is not flushed to disk may be lost. In order to coordinate the efficiency of write operations and durability, they all use write ahead log where they only need to write in the changes in document or the operation to document instead of the whole data. In MySQL, it is called Redo Log. In MongoDB, it is called Journal.</p>
<a id="more"></a>
<p>In this section, we show the comparison of file format, writing mechanism and file storage between MySQL InnoDB Redo Log and MongoDB WiredTiger Journal. And two experiments are shown after this section to show how I find these findings. The experiments are also in specific scenarios to compare their Write Ahead Log which would impact their durability and performance.</p>
<h2 id="Log-format"><a class="header-anchor" href="#Log-format"></a>Log format</h2>
<p>Logs essentially record what changes have been made to the data. Here we compare their log file format.<br>
Both of them use the conception of atomic operation group, which means one modification record related to a series of sub operations (change of index, modify header file etc.) would be stored together in the same log and persist at the same time (Group-Commit) to support atomic user operation.</p>
<h4 id="1-Journal-Records-in-MongoDB"><a class="header-anchor" href="#1-Journal-Records-in-MongoDB"></a>1. Journal Records in MongoDB</h4>
<p>The Journal record includes any internal write operations caused by the initial write. A user operation to a document in a collection may result in a series of modifications to the indexes; WiredTiger creates a single journal record that includes user operation and its series modifications related to user operation. Each record has a unique identifier and also it wouldrecord the timestamp. Then when recovery, server can compare the timestamp of Journal record with checkpoint to judge if this operation is already written to disk. If the timestamp of Journal records is earlier than checkpoint, then the Journal record would not be used to recover.</p>
<h4 id="2-Mini-Transaction-in-MySQL-in-terms-of-Document-Data-Model"><a class="header-anchor" href="#2-Mini-Transaction-in-MySQL-in-terms-of-Document-Data-Model"></a>2. Mini-Transaction in MySQL in terms of Document Data Model</h4>
<p>In InnoDB, the developers use a concept called Mini-Transaction (similar to the Record in Journal file) to keep the atomic of series sub operations. The difference is Redo Log stores the modified offsets of data and the bits. This type of log is called physical log, which makes MySQL to focus only on bit changes without distinguishing data types or operations types. It makes Redo Log compatible with Document Data Model and Relational Data Model. When recording the document log, you only need to record the position before and after the modification and the modified binary data. And the comparison between log and checkpoint is a bit different to Journal records since Redo Log doesn’t record the timestamp. Redo Log would record the Log sequence number. MySQL uses an incremental global variable to represent LSN. The newer Redo Log would have a higher log sequence. When MySQL is flushing data to disk it would increase another global variable called checkpoint_lsn which would record the LSN of the Redo Log of the last persistent data in the buffer. Similarly, when recovering, the storage engine can compare the LSN of Redo Log with checkpoint_lsn to judge if it needs to use this Redo Log.</p>
<h2 id="File-Storage"><a class="header-anchor" href="#File-Storage"></a>File Storage</h2>
<h4 id="1-Incremental-files-writing-In-MongoDB"><a class="header-anchor" href="#1-Incremental-files-writing-In-MongoDB"></a>1. Incremental files writing In MongoDB</h4>
<p>The Journals are stored as names with the following format WiredTigerLog. ‘sequence’ where 'sequence’is a zero-padded number starting from 0000000001.<br>
MongoDB uses an incremental writing files mechanism. And the size limit of each Log files is 100MB, if the data size in one file exceeds 100MB, WiredTiger would create a new file to store. WiredTiger automatically removes old journal files to maintain only the files needed to recover from the last checkpoint. We can see the file create and remove in the following experiment.<br>
<img src="/2020/11/12/mongodb/1.png" alt="Figure 1. Journals files"></p>
<h4 id="2-Circular-files-writing-In-MySQL"><a class="header-anchor" href="#2-Circular-files-writing-In-MySQL"></a>2. Circular files writing In MySQL</h4>
<p>MySQL uses a group of fixed size (default 48MB) file names with the format ib_logfile’sequence’ to store Redo log. The group size is 2 by default.<br>
MySQL uses a circular writing files mechanism. For example, if the data size in ib_logfile0 exceed 48MB, MySQL would write to ib_logfile1 and if the data size in ib_logfile1 exceed 48MB, MySQL would rewrite to ib_logfile0. We can see the log files are always in same size in the following experiment 1.<br>
<img src="/2020/11/12/mongodb/2.png" alt="Figure 2. Redo Logs files"></p>
<h2 id="Mechanism"><a class="header-anchor" href="#Mechanism"></a>Mechanism</h2>
<p>Their inner mechanism when modification occurs is quite different. The following is a brief comparison of the two mechanisms for writing WAL. Validation on these mechanisms is in the following experiments.</p>
<h4 id="1-Journaling-Mechanism-in-MongoDB"><a class="header-anchor" href="#1-Journaling-Mechanism-in-MongoDB"></a>1. Journaling Mechanism in MongoDB</h4>
<p>MongoDB uses a timestamp in MVCC which is used to the checkpoint. Cache would flush data to disk every 60s and remove the Journal Records in files which are before the checkpoint. And Journal cache would flush Journal records to disk every 100ms by default. Also if the write concern has attribute j:true, the Journal would write to disk immediately.<br>
<img src="/2020/11/12/mongodb/3.png" alt="Figure 3. Persistency mechanism of Journal and cache"></p>
<h4 id="2-Redo-Log-Mechanism-in-MySQL"><a class="header-anchor" href="#2-Redo-Log-Mechanism-in-MySQL"></a>2. Redo Log Mechanism in MySQL</h4>
<p>Similarly, MySQL InnoDB will continually brush the dirty data in the buffer pool back to the disk data file and flush bytes to Redo Log files. The Redo Log is done after the data is written into the buffer (MongoDB stores the journal record into the private view first). What’s more, the Redo Log is flushed to disk immediately before the transaction is committed to ensure the integrity of the transaction. Similarly, InnoDB will also enable background threads to persist Redo Log to disk every one second. And also if the Redo Log is filled full , Mysql would flush the dirty page to disk immediately and the file space can be re-used to write new coming operations. The following is the flow chart:<br>
<img src="/2020/11/12/mongodb/4.png" alt="Figure 4. Persistency mechanism of Redo Log and Buffer Pool"></p>
<h2 id="Experiment"><a class="header-anchor" href="#Experiment"></a>Experiment</h2>
<p>In this session, we are going to compare the difference of the writing mechanism and file storage of Write Ahead Log of two Databases.<br>
In the first experiment, we write the same large number of data to two databases. With the same large write load, we try to explore what is the difference between log files and mechanisms.<br>
In the second experiment, we base on the first experiment and explore the impact of log file size on the number of pages flushing to disk, and observe whether it affects database writing.</p>
<h3 id="Hardware"><a class="header-anchor" href="#Hardware"></a>Hardware</h3>
<p>Mac Pro (Early 2015) Intel Core i5 2 Core 2.9GHz 8GB RAM<br>
Software<br>
OS: Mac OS 10.15.7<br>
MySQL community server 8.0.21<br>
MongoDB community server version 4.4<br>
Robo 3T version 1.3.1<br>
MySQL Workbench 8.0.20<br>
Python 3.7<br>
Visual studio code 1.51.5 + pymongo 3.11.0 + pymysql 0.10.1</p>
<h3 id="Experiment-1"><a class="header-anchor" href="#Experiment-1"></a>Experiment 1</h3>
<p>Motivation:<br>
In this experiment, we are curious about what happens on the WAL log and buffer of each database if we push data to them with a huge write load.</p>
<h4 id="1-Experimental-setup"><a class="header-anchor" href="#1-Experimental-setup"></a>1. Experimental setup:</h4>
<ol>
<li>We use a dataset called companies.json whose size is 78.2MB with 18801 documents<br>
in it.</li>
<li>We use four processes to write these 18801 document records and remove them at the<br>
same time, so the total documents written to each database is 75204 and the total data<br>
size is 312.8MB in one round.</li>
<li>We continually write these documents in two databases for the 180s.</li>
<li>We use another process to inspect the total log files size of two databases every 50ms.<br>
In MongoDB, we also inspect the bytes written from cache to disk and the bytes written for checkpoint (MongoDB server status variable). In MySQL, we also inspect the number of requests to flush pages from the InnoDB buffer pool and the bytes of Redo Log written (MySQL server status variable).<br>
<img src="/2020/11/12/mongodb/5.png" alt="Figure 5. MongoDB server status variables"></li>
</ol>
<p><img src="/2020/11/12/mongodb/6.png" alt="Figure 6. MySQL server status variables"></p>
<ol start="6">
<li>In each database, the buffers were set to the same value and others configuration is default.</li>
<li>In the MySQL experiment, we also run the SQL with transaction commit and without commit to see if the transaction commit would let the Redo Log persist immediately.</li>
</ol>
<h4 id="2-Experimental-Result"><a class="header-anchor" href="#2-Experimental-Result"></a>2. Experimental Result</h4>
<ol>
<li>MongoDB<br>
we can see two processes finished 23 rounds and two finished 24 rounds. So the total round is 94 rounds. Totally, we write 7350.8MB documents in the 180s to MongoDB and 40.8MB per second.<br>
<img src="/2020/11/12/mongodb/7.png" alt="Figure 7. Total rounds of each process"></li>
</ol>
<p><img src="/2020/11/12/mongodb/8.png" alt="Figure 8. The bytes written from cache to disk"></p>
<p>As shown on Figure 8, the MongoDB writes 27.8MB (slope of graph) from cache to disk per seconds which is less than the writing speed with 40.8MB/sec. With the continuous writing of documents, because the average data written per second exceeds the data persistent in MongoDB memory, the creation speed of records in Journal exceeds the speed of eliminating expired journals. The upper limit of a single Journal file in MongoDB is 100MB. Therefore, new journal files will be created continuously to persist the continuously written data.<br>
And we plot the Journal log files size in disk can see:<br>
<img src="/2020/11/12/mongodb/9.png" alt="Figure 9. The log files size of Journal"></p>
<p><img src="/2020/11/12/mongodb/10.png" alt="Figure 10. The bytes written to disk for checkpoint"></p>
<p>The result shows the incremental writing mechanism of MongoDB. As shown on Figure 9, When the write load exceeds the speed of writing data from to disk, MongoDB will continue to create journal files to undertake the task of persistence, so as to maintain the amount of data written from the cache to the disk at a certain speed. And as shown on Figure 9 and 10, the checkpoint every 60s will persist the data not persisted in the cache to the disk, and delete the expired Journal records.</p>
<ol>
<li>MySQL<br>
<img src="/2020/11/12/mongodb/11.png" alt="Figure 11. Total rounds of each process"></li>
</ol>
<p>As shown in Figure 11, each process finished 9 rounds in 180 seconds. So total rounds are 36 and we write 2815.2MB documents in total in the 180s. Compared with the 7350.8MB written by MongoDB, we can see that MongoDB has higher throughput under the default system configuration.<br>
<img src="/2020/11/12/mongodb/12.png" alt="Figure 12. Bytes written to Redo Log files with transaction commit"></p>
<p><img src="/2020/11/12/mongodb/13.png" alt="Figure 13. Bytes written to Redo Log files without commit"></p>
<p>As shown in Figure 12 and Figure 13, comparing the write operation without a translation commit, after the 180s, there was no flushing on Redo Log. We can see when we run the write operation with transaction commit, the Redo Log would be flush to disk immediately. And. And in Figure 13, after 180s, we can see that MySQL continually flushes Redo Log from the buffer to the disk.<br>
<img src="/2020/11/12/mongodb/14.png" alt="Figure 14. The files size of Redo Log"></p>
<p><img src="/2020/11/12/mongodb/15.png" alt="Figure 15. The number of requests sent to flush pages with commit"></p>
<p>And as shown on Figure 14, the size of Redo Log didn’t change. And the number of requests sent to flush pages increased at the very beginning when buffer pool and Redo Log file was gradually filled fully. With the stable write rate and limit of flushing I/O, the speed of flushing pages tends to be stable. At the end of line, when we stop to write data, we can see that MySQL continually flushes dirty pages into the disk with constant speed.</p>
<h3 id="Experiment-2"><a class="header-anchor" href="#Experiment-2"></a>Experiment 2</h3>
<p>Motivation:<br>
In the last experiment, we compare the log file writing between two databases in terms of document data model. In this experiment, we are curious about how different Redo Log size affects the I/O of flushing dirty pages to disk, and further affects the write time of the database in MySQL in terms of JSON dataset.</p>
<h4 id="1-Experimental-setup-v2"><a class="header-anchor" href="#1-Experimental-setup-v2"></a>1. Experimental setup:</h4>
<ol>
<li>
<p>We still use the same dataset companies.json whose size is 78.2MB with 18801<br>
documents. We only use one process to write these documents in each experiment. Experiments will be conducted based on the initial settings of different Redo Log sizes. And each log size will be tested 10 times to get the average value.</p>
</li>
<li>
<p>As shown in Figure 16, we query system status variables to get how many pages were flushed to the disk from the buffer during writing.<br>
<img src="/2020/11/12/mongodb/16.png" alt="Figure 16. SQL to get system status"></p>
</li>
<li>
<p>As shown in Figure 17, we modify the log file size in the configuration file of MySQL. We do experiments when the single log size is 10MB, 15MB, 20MB, 25MB, 37.5MB, 50MB, 75MB, 100MB, 150MB and 250MB. The number of log groups is 2. So the total log size is 20MB, 30MB, 40MB, 50MB, 75MB, 100MB, 150MB, 200MB, 300MB and 500MB.<br>
<img src="/2020/11/12/mongodb/17.png" alt="Figure 17. Setting of log files size"></p>
</li>
<li>
<p>In addition, before doing each experiment, we would clean the bin log (Figure 18) and restart the server to keep the same usage of buffer pool (Figure 19, we inspect the usage using MySQL workbench) to make sure the isolation between each experiment.<br>
<img src="/2020/11/12/mongodb/18.png" alt="Figure 18. Query to clean bin log"></p>
</li>
</ol>
<p><img src="/2020/11/12/mongodb/19.png" alt="Figure 19. Buffer usage in MySQL Workbench"></p>
<h4 id="2-Experimental-Result-v2"><a class="header-anchor" href="#2-Experimental-Result-v2"></a>2. Experimental Result</h4>
<p>As shown in Figure 20, we can see from that there are two slopes. One is that when the size of a single log is less than the amount of data written, the number of disk pages flushed from the buffer increases sharply. The other is that when the size of a single log is larger than the amount of data written, the pages flushed into the disk from the buffer change slowly.<br>
<img src="/2020/11/12/mongodb/20.png" alt="Figure 20. Log size versus number of pages flushed into the disk"></p>
<p><img src="/2020/11/12/mongodb/21.png" alt="Figure 21. Log size versus time to finish writing"></p>
<p>As shown in Figure 21, we can see that when the log size is too small, the time of writing is a sharp rise.<br>
The result shows that according to the description of the adaptive flushing algorithm in the official documents, the buffer will dynamically adjust the buffer flushing speed according to the write speed of the Redo Log. When the log file is not too small, because the speed of writing the Redo Log does not change, the buffer maintains a certain speed of flushing dirty pages, and the completion time of writing is roughly the same. However, as described in the official documents, when the amount of data written is greater than the size of a single log file, in order to have enough space to write Redo Log files, the system has to increase the number of dirty pages that the buffer flushes into the disk. And when the log file is too small, due to the experimental conditions, the maximum disk I / O limit of input dirty pages is 9000 per round, which affects the writing time. (When log size is less than 40MB in this experiment)</p>
<h2 id="Discussion"><a class="header-anchor" href="#Discussion"></a>Discussion</h2>
<p>And MongoDB would continually create new Journal files to face the excessive amount of write operations and would not affect the checkpoint of the buffer. So the persistent strategy is periodically flushing dirty data. When the buffer is doing a checkpoint, MongoDB would use a timestamp to identify the checkpoint. We can relate it to MVCC of MongoDB, since MongoDB uses a timestamp to identify different versions snapshot in the buffer. Compared to MongoDB, MySQL continually flush dirty pages and Redo logs to the disk but it uses a global variable to identify the checkpoint rather than timestamp. And it emphasizes transactions. It usestransaction ID to identify different versions in the buffer (MVCC). The commit of a transaction will immediately persist the Redo log of the same transaction.<br>
The circular write mechanism used by MySQL can make full use of disk space and make the space occupied by log files as small as possible. However, if a large number of transactions are committed and a large number of Redo Logs are generated, and the file size is limited, the storage engine will have to update a large number of dirty data in the buffer pool to the disk to reuse the Redo Log file space, thus producing an I/O storm in a short period of time and affecting the duration of write operations.<br>
The incremental write mechanism used by MongoDB can continuously generate Journal Records. Compared with Mysql, MongoDB doesn’t have to manage the Journal file storage and this can let it cope with high throughput scenarios, but it will also generate a large number of Journal files on disk until the next checkpoint arrives to delete the expired Journal Records.</p>
<h2 id="Reference"><a class="header-anchor" href="#Reference"></a>Reference</h2>
<p>[1] ​WiredTiger Storage engine,​ MongoDB, retrieved from<br>
<a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/core/wiredtiger">https://docs.mongodb.com/manual/core/wiredtiger</a><br>
31<br>
[2]​JournalingMechanism,​ MongoDB,retrievedfrom<br>
<a target="_blank" rel="noopener" href="https://mongodb-documentation.readthedocs.io/en/latest/administration/journaling.html#gsc.tab=0">https://mongodb-documentation.readthedocs.io/en/latest/administration/journaling.html#gsc.tab=0</a></p>
<p>[3]​JournalRecords,​ MongoDB,retrievedfrom<br>
<a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/core/journaling/#journal-records%E2%80%8B">https://docs.mongodb.com/manual/core/journaling/#journal-records​</a>)</p>
<p>[4]​ Server status output​, MongoDB, retrieved from<br>
<a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/command/serverStatus/#server-status-output">https://docs.mongodb.com/manual/reference/command/serverStatus/#server-status-output</a></p>
<p>[5]​Bufferpoolflushing,​ MySQL,retrievedfrom<br>
<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool-flushing.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool-flushing.html</a></p>
<p>[6] ​Server status​, MySQL, retrieved from<br>
<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html#statvar_Innodb_buffer_pool_write_requests">https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html#statvar_Innodb_buffer_pool_write_requests</a></p>
<p>[7]​RedoLogdocument,​ MySQL,retrievedfrom<br>
<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-redo-log.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-redo-log.html</a></p>
<p>[8]​RedoLogconfiguration,​ MySQL,retrievedfrom<br>
<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-init-startup-configuration.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-init-startup-configuration.html</a></p>
<p>[9]​RedoLogsourcecode,​ MySQL,retrievedfrom<br>
<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_INNODB_REDO_LOG_FORMAT.hml">https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_INNODB_REDO_LOG_FORMAT.hml</a></p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/NoSQL/">NoSQL</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/31/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%B0%8F%E6%8C%87%E5%8D%97/"><i class="fa fa-chevron-left">  </i><span>云服务器部署小指南</span></a></div><div class="next-post pull-right"><a href="/2020/08/21/system%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span>GOODS设计的论文阅读笔记</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://pic.netbian.com/uploads/allimg/200710/220558-1594389958b5b5.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By TYH</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>