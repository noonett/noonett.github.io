<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaIO"><meta name="keywords" content="Java"><meta name="author" content="TYH"><meta name="copyright" content="TYH"><title>JavaIO | 21号避难所</title><link rel="shortcut icon" href="/images/yuhangyuanfeixiang.png"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.0.0/css/font-awesome.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">File对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件和目录"><span class="toc-text">文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建和删除文件"><span class="toc-text">创建和删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历文件和目录"><span class="toc-text">遍历文件和目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">Path</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">InputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲"><span class="toc-text">缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞"><span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream实现类"><span class="toc-text">InputStream实现类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">OutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileOutputStream"><span class="toc-text">FileOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞-v2"><span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStream实现类"><span class="toc-text">OutputStream实现类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">Filter模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">操作zip</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读取zip包"><span class="toc-text">读取zip包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写入zip包"><span class="toc-text">写入zip包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">classpath</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化"><span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反序列化"><span class="toc-text">反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全型"><span class="toc-text">安全型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FileReader"><span class="toc-text">FileReader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CharArrayReader"><span class="toc-text">CharArrayReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringReader"><span class="toc-text">StringReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStreamReader"><span class="toc-text">InputStreamReader</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileWriter"><span class="toc-text">FileWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CharArrayWriter"><span class="toc-text">CharArrayWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringWriter"><span class="toc-text">StringWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStreamWriter"><span class="toc-text">OutputStreamWriter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">PrintStream和PrintWriter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PrintWriter"><span class="toc-text">PrintWriter</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2904152762,521104362&amp;fm=16&amp;gp=0.jpg"></div><div class="author-info__name text-center">TYH</div><div class="author-info__description text-center">反复敲打，登峰造极</div><div class="follow-button"><a href="https://github.com/noonett" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">148</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">50</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://c-ssl.duitang.com/uploads/item/202005/15/20200515135004_tozxj.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">21号避难所</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">JavaIO</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 15 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><pre><code>I：input把数据从外部读入内存
O：output把数据从内存输出到外部
</code></pre>
<a id="more"></a>
<h1>File对象</h1>
<p>构建File对象，需要传入文件路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">"/usr/bin/javac"</span>);</span><br><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">"./sub/javac"</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">"../sub/javac"</span>); <span class="comment">// 绝对路径是C:\sub\javac</span></span><br></pre></td></tr></table></figure>
<p>.当前路径，…上级目录。<br>
File对象有3种形式表示的路径，一种是getPath()，返回构造方法传入的路径，一种是getAbsolutePath()，返回绝对路径，一种是getCanonicalPath，它和绝对路径类似，但是返回的是规范路径。</p>
<h3 id="文件和目录"><a class="header-anchor" href="#文件和目录"></a>文件和目录</h3>
<p>File对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。</p>
<p>例如，调用.isFile()，判断该File对象是否是一个已存在的文件，调用.isDirectory()，判断该File对象是否是一个已存在的目录。</p>
<p>用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p>
<ul>
<li>boolean canRead()：是否可读；</li>
<li>boolean canWrite()：是否可写；</li>
<li>boolean canExecute()：是否可执行；</li>
<li>long length()：文件字节大小。<br>
对目录而言，是否可执行表示能否列出它包含的文件和子目录。</li>
</ul>
<h3 id="创建和删除文件"><a class="header-anchor" href="#创建和删除文件"></a>创建和删除文件</h3>
<p>当File对象表示一个文件时，可以通过createNewFile()创建一个新文件，用delete()删除该文件。</p>
<p>有些时候，程序需要读写一些临时文件，File对象提供了createTempFile()来创建一个临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = File.createTempFile(<span class="string">"tmp-"</span>, <span class="string">".txt"</span>); <span class="comment">// 提供临时文件的前缀和后缀</span></span><br><span class="line">        f.deleteOnExit(); <span class="comment">// JVM退出时自动删除</span></span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历文件和目录"><a class="header-anchor" href="#遍历文件和目录"></a>遍历文件和目录</h3>
<p>当File对象表示一个目录时，可以使用list()和listFiles()列出目录下的文件和子目录名。listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"C:\\Windows"</span>);</span><br><span class="line">        File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">        printFiles(fs1);</span><br><span class="line">        File[] fs2 = f.listFiles(<span class="keyword">new</span> FilenameFilter() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">".exe"</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printFiles(fs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(File[] files)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========="</span>);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=========="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p>
<ul>
<li>boolean mkdir()：创建当前File对象表示的目录；</li>
<li>boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li>
<li>boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li>
</ul>
<h1>Path</h1>
<p>Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path p1 = Paths.get(<span class="string">"."</span>, <span class="string">"project"</span>, <span class="string">"study"</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        Path p2 = p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        Path p3 = p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        File f = p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">".."</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">"  "</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要对目录进行复杂的拼接、遍历等操作，使用Path对象更方便。</p>
<h1>InputStream</h1>
<p>InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。<br>
FileInputStream是InputStream的一个子类。顾名思义，FileInputStream就是从文件流中读取数据。<br>
一个潜在的问题：如果读取过程中发生了IO错误，InputStream就没法正确地关闭，资源也就没法及时释放。<br>
因此，我们需要用try … finally来保证InputStream在无论是否发生IO错误的时候都能够正确地关闭。<br>
用try … finally来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的try(resource)的语法，只需要编写try语句，让编译器自动为我们关闭资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，编译器并不会特别地为InputStream加上自动关闭。编译器只看try(resource = …)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上finally语句并调用close()方法。InputStream和OutputStream都实现了这个接口，因此，都可以用在try(resource)中。</p>
<h3 id="缓冲"><a class="header-anchor" href="#缓冲"></a>缓冲</h3>
<p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。InputStream提供了两个重载方法来支持读取多个字节：</p>
<ul>
<li>int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数</li>
<li>int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数<br>
利用上述方法一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。<br>
利用缓冲区一次读取多个字节的代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" bytes."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞"><a class="header-anchor" href="#阻塞"></a>阻塞</h3>
<p>在调用InputStream的read()方法读取数据时，我们说read()方法是阻塞（Blocking）的。必须等待read()方法返回才能执行下一行代码。</p>
<h3 id="InputStream实现类"><a class="header-anchor" href="#InputStream实现类"></a>InputStream实现类</h3>
<p>ByteArrayInputStream可以在内存中模拟一个InputStream。实际上是把一个byte[]数组在内存中变成一个InputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个InputStream。<br>
我们想从文件中读取所有字节，并转换成char然后拼成一个字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = readAsString(input);</span><br></pre></td></tr></table></figure>
<h1>OutputStream</h1>
<p>OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b)，签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b &amp; 0xff）。</p>
<p>和InputStream类似，OutputStream也提供了close()方法关闭输出流，以便释放系统资源。要特别注意：OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。</p>
<p>为什么要有flush()？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。</p>
<p>通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。</p>
<p>但是，在某些情况下，我们必须手动调用flush()方法。举个栗子：</p>
<p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过OutputStream的write()方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？</p>
<p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p>
<p>解决办法就是每输入一句话后，立刻调用flush()，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p>
<p>实际上，InputStream也有缓冲区。例如，从FileInputStream读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用read()，则会触发操作系统的下一次读取并再次填满缓冲区。</p>
<h3 id="FileOutputStream"><a class="header-anchor" href="#FileOutputStream"></a>FileOutputStream</h3>
<p>和InputStream一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用try(resource)来保证OutputStream在无论是否发生IO错误的时候都能够正确地关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"out/readme.txt"</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞-v2"><a class="header-anchor" href="#阻塞-v2"></a>阻塞</h3>
<p>和InputStream一样，OutputStream的write()方法也是阻塞的。</p>
<h3 id="OutputStream实现类"><a class="header-anchor" href="#OutputStream实现类"></a>OutputStream实现类</h3>
<p>ByteArrayOutputStream可以在内存中模拟一个OutputStream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br></pre></td></tr></table></figure>
<h1>Filter模式</h1>
<p>Java的IO标准库使用Filter模式为InputStream和OutputStream增加功能：</p>
<ul>
<li>可以把一个InputStream和任意个FilterInputStream组合；</li>
<li>可以把一个OutputStream和任意个FilterOutputStream组合。<br>
Filter模式可以在运行期动态增加功能（又称Decorator模式）。<br>
可以叠加多个FilterInputStream来提供功能。</li>
</ul>
<h1>操作zip</h1>
<p>JarInputStream是从ZipInputStream派生，它增加的主要功能是直接读取jar文件里面的MANIFEST.MF文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p>
<h2 id="读取zip包"><a class="header-anchor" href="#读取zip包"></a>读取zip包</h2>
<p>创建一个ZipInputStream，通常是传入一个FileInputStream作为数据源，然后，循环调用getNextEntry()，直到返回null，表示zip流结束。</p>
<p>一个ZipEntry表示一个压缩文件或目录，如果是压缩文件，我们就用read()方法不断读取，直到返回-1。</p>
<h2 id="写入zip包"><a class="header-anchor" href="#写入zip包"></a>写入zip包</h2>
<p>ZipOutputStream是一种FilterOutputStream，它可以直接写入内容到zip包。我们要先创建一个ZipOutputStream，通常是包装一个FileOutputStream，然后，每写入一个文件前，先调用putNextEntry()，然后用write()写入byte[]数据，写入完毕后调用closeEntry()结束这个文件的打包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipOutputStream zip = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(...))) &#123;</span><br><span class="line">    File[] files = ...</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        zip.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()));</span><br><span class="line">        zip.write(getFileDataAsBytes(file));</span><br><span class="line">        zip.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，new ZipEntry(name)传入的name要用相对路径。</p>
<h1>classpath</h1>
<p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把default.properties文件放到classpath中，就不用关心它的实际存放路径。<br>
在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件.<br>
调用getResourceAsStream()需要特别注意的一点是，如果资源文件不存在，它将返回null。因此，我们需要检查返回的InputStream是否为null，如果为null，表示资源文件在classpath中没有找到。</p>
<h1>序列化</h1>
<p>序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p>
<p>反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。</p>
<p>要能序列化，实现java.io.Serializable接口。Serializable接口没有定义任何方法，它是一个空接口，称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p>
<h3 id="序列化"><a class="header-anchor" href="#序列化"></a>序列化</h3>
<p>使用ObjectOutputStream。它负责把一个Java对象写入一个字节流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class="line">        <span class="comment">// 写入int:</span></span><br><span class="line">        output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">        output.writeUTF(<span class="string">"Hello"</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">        output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以写入实现了Serializable接口的Object。</p>
<h3 id="反序列化"><a class="header-anchor" href="#反序列化"></a>反序列化</h3>
<p>ObjectInputStream负责从一个字节流读取Java对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(...)) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = input.readInt();</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">    Double d = (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用readObject()可以直接返回一个Object对象。<br>
Java的序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。<br>
反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p>
<h3 id="安全型"><a class="header-anchor" href="#安全型"></a>安全型</h3>
<p>因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p>
<p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p>
<h1>Reader</h1>
<p>Reader是以字符流，即char为单位读取。<br>
这个方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。</p>
<h2 id="FileReader"><a class="header-anchor" href="#FileReader"></a>FileReader</h2>
<p>FileReader是Reader的一个子类，它可以打开文件并获取Reader。<br>
要避免乱码问题，我们需要在创建FileReader时指定编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>,StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<p>可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" chars."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CharArrayReader"><a class="header-anchor" href="#CharArrayReader"></a>CharArrayReader</h3>
<p>CharArrayReader可以在内存中模拟一个Reader，它的作用实际上是把一个char[]数组变成一个Reader，这和ByteArrayInputStream非常类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> CharArrayReader(<span class="string">"Hello"</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StringReader"><a class="header-anchor" href="#StringReader"></a>StringReader</h3>
<p>StringReader可以直接把String作为数据源。</p>
<h3 id="InputStreamReader"><a class="header-anchor" href="#InputStreamReader"></a>InputStreamReader</h3>
<p>FileReader的源码，它在内部实际上持有一个FileInputStream。Reader需要从InputStream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。<br>
InputStreamReader就是这样一个转换器，它可以把任何InputStream转换为Reader。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>), <span class="string">"UTF-8"</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Writer</h1>
<p>Writer带编码转换器的OutputStream，char转换为byte并输出。</p>
<h3 id="FileWriter"><a class="header-anchor" href="#FileWriter"></a>FileWriter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">'H'</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CharArrayWriter"><a class="header-anchor" href="#CharArrayWriter"></a>CharArrayWriter</h3>
<p>CharArrayWriter可以在内存中创建一个Writer，它的作用实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组，这和ByteArrayOutputStream非常类似。</p>
<h3 id="StringWriter"><a class="header-anchor" href="#StringWriter"></a>StringWriter</h3>
<p>实际上，StringWriter在内部维护了一个StringBuffer，并对外提供了Writer接口。</p>
<h3 id="OutputStreamWriter"><a class="header-anchor" href="#OutputStreamWriter"></a>OutputStreamWriter</h3>
<p>普通的Writer实际上是基于OutputStream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream。因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"readme.txt"</span>), <span class="string">"UTF-8"</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>PrintStream和PrintWriter</h1>
<p>PrintStream是一种FilterOutputStream，它在OutputStream的接口上，额外提供了一些写入各种数据类型的方法：<br>
println()方法，它会自动加上换行符。<br>
System.out是系统默认提供的PrintStream，表示标准输出。<br>
System.err是系统默认提供的标准错误输出。<br>
它还有一个额外的优点，就是不会抛出IOException。</p>
<h3 id="PrintWriter"><a class="header-anchor" href="#PrintWriter"></a>PrintWriter</h3>
<p>PrintStream最终输出的总是byte数据，而PrintWriter则是扩展了Writer接口，它的print()/println()方法最终输出的是char数据。两者的使用方法几乎是一模一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</span><br><span class="line">        StringWriter buffer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter pw = <span class="keyword">new</span> PrintWriter(buffer)) &#123;</span><br><span class="line">            pw.println(<span class="string">"Hello"</span>);</span><br><span class="line">            pw.println(<span class="number">12345</span>);</span><br><span class="line">            pw.println(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>排序算法总结</span></a></div><div class="next-post pull-right"><a href="/2020/03/10/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"><span>两个栈实现队列｜《剑指offer》</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://c-ssl.duitang.com/uploads/item/202005/15/20200515135004_tozxj.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By TYH</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>