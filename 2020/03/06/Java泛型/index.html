<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java泛型"><meta name="keywords" content="Java"><meta name="author" content="TYH"><meta name="copyright" content="TYH"><title>Java泛型 | 21号避难所</title><link rel="shortcut icon" href="/images/yuhangyuanfeixiang.png"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.0.0/css/font-awesome.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">向上转型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">使用泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">泛型接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">编写泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-text">多个泛型类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">擦拭法Type Erasure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82"><span class="toc-text">实现泛型的底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-text">Java泛型的局限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-text">泛型继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">extend通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E4%BC%A0%E5%85%A5%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BC%95%E7%94%A8%E7%BB%99%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84set%E6%96%B9%E6%B3%95"><span class="toc-text">不可传入泛型类型的引用给泛型类型的set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extend%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">extend的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8extend%E9%99%90%E5%AE%9A-T-%E7%B1%BB%E5%9E%8B"><span class="toc-text">使用extend限定类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">super通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PECS"><span class="toc-text">PECS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">无限定通配符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">泛型和反射</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2904152762,521104362&amp;fm=16&amp;gp=0.jpg"></div><div class="author-info__name text-center">TYH</div><div class="author-info__description text-center">反复敲打，登峰造极</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/noonett">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">164</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">58</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://pic.netbian.com/uploads/allimg/200710/220558-1594389958b5b5.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">21号避难所</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Java泛型</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-06</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 9 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>泛型是一种“代码模板”，可以用一套代码套用各种类型。编写一次，万能匹配。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList，它可以看作“可变长度”的数组，内部就是一个Object[]数组，配合存储一个当前分配的长度。</p>
<h4 id="向上转型"><a class="header-anchor" href="#向上转型"></a>向上转型</h4>
<p>在Java标准库中的ArrayList<T>实现了List<T>接口，它可以向上转型为List<T>。<br>
要特别注意：不能把ArrayList<Integer>向上转型为ArrayList<Number>或List<Number>。<br>
我们把一个ArrayList<Integer>转型为ArrayList<Number>类型后，这个ArrayList<Number>就可以接受Float类型，因为Float是Number的子类。但是，ArrayList<Number>实际上和ArrayList<Integer>是同一个对象，也就是ArrayList<Integer>类型，它不可能接受Float类型， 所以在获取Integer的时候将产生ClassCastException。</Integer></Integer></Number></Number></Number></Integer></Number></Number></Integer></T></T></T></p>
<h1>使用泛型</h1>
<p>编译器看到泛型类型List<Number>就可以自动推断出后面的ArrayList<T>的泛型类型必须是ArrayList<Number>，因此，可以把代码简写为：</Number></T></Number></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="泛型接口"><a class="header-anchor" href="#泛型接口"></a>泛型接口</h3>
<p>除了ArrayList<T>使用了泛型，还可以在接口中使用泛型。例如，Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable<T>这个泛型接口：<br>
可以直接对String数组进行排序,这是因为String本身已经实现了Comparable<String>接口。如果换成我们自定义的Person类型试试：</String></T></T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] ps = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(ps);</span><br><span class="line">System.out.println(Arrays.toString(ps));</span><br></pre></td></tr></table></figure>
<p>运行程序，我们会得到ClassCastException，即无法将Person转型为Comparable。我们修改代码，让Person实现Comparable<T>接口：</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以正确实现按name进行排序。也可以修改比较逻辑，例如，按score从高到低排序。</p>
<h1>编写泛型</h1>
<p>通常来说，泛型类一般用在集合类中。<br>
首先，按照某种类型，例如：String，来编写类。<br>
然后，标记所有的特定类型，这里是String。<br>
最后，把特定类型String替换为T，并申明<T>。</T></p>
<h3 id="静态方法"><a class="header-anchor" href="#静态方法"></a>静态方法</h3>
<p>编写泛型类时，要特别注意，泛型类型<T>不能用于静态方法。<br>
可以在static修饰符后面加一个<T>，编译就能通过：</T></T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以编译通过:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上，这个<T>和Pair<T>类型的<T>已经没有任何关系了<br>
对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的create()静态方法，我们应该把它改为另一种泛型类型，例如，<K>：这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</K></T></T></T></p>
<h3 id="多个泛型类型"><a class="header-anchor" href="#多个泛型类型"></a>多个泛型类型</h3>
<p>泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型&lt;T, K&gt;：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时特别指出两种类型：</span></span><br><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>Java标准库的Map&lt;K, V&gt;就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p>
<h1>擦拭法Type Erasure</h1>
<h3 id="实现泛型的底层"><a class="header-anchor" href="#实现泛型的底层"></a>实现泛型的底层</h3>
<p>Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<T>视为Object；</T></li>
<li>编译器根据<T>实现安全的强制转型。<br>
所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</T></li>
</ul>
<h3 id="Java泛型的局限"><a class="header-anchor" href="#Java泛型的局限"></a>Java泛型的局限</h3>
<p>局限一：<T>不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型。<br>
局限二：无法取得带泛型的Class。<br>
因为T是Object，我们对Pair<String>和Pair<Integer>类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。<br>
换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair<Object>。<br>
局限三：无法判断带泛型的Class<br>
局限四：不能实例化T类型<br>
创建new Pair<String>()和创建new Pair<Integer>()就全部成了Object，显然编译器要阻止这种类型不对的代码。<br>
要实例化T类型，我们必须借助额外的Class<T>参数：</T></Integer></String></Object></Integer></String></T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法要防止重复定义方法。定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。<br>
换个方法名，避开与Object.equals(Object)的冲突就可以成功编译，如same(T t)。</p>
<h3 id="泛型继承"><a class="header-anchor" href="#泛型继承"></a>泛型继承</h3>
<p>一个类可以继承自一个泛型类</p>
<h1>extend通配符</h1>
<p>有没有办法使得方法参数接受Pair<Integer>？办法是有的，这就是使用Pair&lt;? extends Number&gt;使得方法接收所有泛型类型为Number或Number子类的Pair类型。加入extend之后泛型擦拭将为Number而不是Object。</Integer></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，给方法传入Pair<Integer>类型时，它符合参数Pair&lt;? extends Number&gt;类型。这种使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。<br>
除了可以传入Pair<Integer>类型，我们还可以传入Pair<Double>类型，Pair<BigDecimal>类型等等，因为Double和BigDecimal都是Number的子类。</BigDecimal></Double></Integer></Integer></p>
<h3 id="不可传入泛型类型的引用给泛型类型的set方法"><a class="header-anchor" href="#不可传入泛型类型的引用给泛型类型的set方法"></a>不可传入泛型类型的引用给泛型类型的set方法</h3>
<p>编译错误发生在p.setFirst()传入的参数是Integer类型。有些童鞋会问了，既然p的定义是Pair&lt;? extends Number&gt;，那么setFirst(? extends Number)为什么不能传入Integer？<br>
原因还在于擦拭法。如果我们传入的p是Pair<Double>，显然它满足参数定义Pair&lt;? extends Number&gt;，然而，Pair<Double>的setFirst()显然无法接受Integer类型。<br>
这就是&lt;? extends Number&gt;通配符的一个重要限制：方法参数签名setFirst(? extends Number)无法传递任何Number类型给setFirst(? extends Number)。<br>
这里唯一的例外是可以给方法参数传入null。</Double></Double></p>
<h3 id="extend的作用"><a class="header-anchor" href="#extend的作用"></a>extend的作用</h3>
<p>为什么我们定义的方法参数类型是List&lt;? extends Integer&gt;而不是List<Integer>？从方法内部代码看，传入List&lt;? extends Integer&gt;或者List<Integer>是完全一样的，但是，注意到List&lt;? extends Integer&gt;的限制：</Integer></Integer></p>
<p>允许调用get()方法获取Integer的引用；<br>
不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。<br>
因此，方法参数类型List&lt;? extends Integer&gt;表明了该方法内部只会读取List的元素，不会修改List的元素（因为无法调用add(? extends Integer)、remove(? extends Integer)这些方法。换句话说，这是一个对参数List&lt;? extends Integer&gt;进行只读的方法（恶意调用set(null)除外）。</p>
<h3 id="使用extend限定-T-类型"><a class="header-anchor" href="#使用extend限定-T-类型"></a>使用extend限定<T>类型</T></h3>
<p>在定义泛型类型Pair<T>的时候，也可以使用extends通配符来限定T的类型。非Number类型将无法通过编译。</T></p>
<h1>super通配符</h1>
<p>使用的类型只能是泛型的父类。<br>
因此，使用&lt;? super Integer&gt;通配符表示：<br>
允许调用set(? super Integer)方法传入Integer的引用；<br>
不允许调用get()方法获得Integer的引用。因为传入的类型，也有可能是number。<br>
唯一例外是可以获取Object的引用：Object o = p.getFirst()。<br>
换句话说，使用&lt;? super Integer&gt;通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p>
<h3 id="PECS"><a class="header-anchor" href="#PECS"></a>PECS</h3>
<p>何时使用extends，何时使用super？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。<br>
即：如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            T t = src.get(i); <span class="comment">// src是producer</span></span><br><span class="line">            dest.add(t); <span class="comment">// dest是consumer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要返回T的src是生产者，因此声明为List&lt;? extends T&gt;，需要写入T的dest是消费者，因此声明为List&lt;? super T&gt;。</p>
<h1>无限定通配符</h1>
<p>因为&lt;?&gt;通配符既没有extends，也没有super，因此：<br>
不允许调用set(T)方法并传入引用（null除外）；<br>
不允许调用T get()方法并获取T引用（只能获取Object引用）。<br>
换句话说，既不能读，也不能写，那只能做一些null判断</p>
<ul>
<li>Pair&lt;?&gt;是所有Pair<T>的超类，可以安全的向上转型。</T></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">    Pair&lt;?&gt; p2 = p; <span class="comment">// 安全地向上转型</span></span><br><span class="line">    System.out.println(p2.getFirst() + <span class="string">&quot;, &quot;</span> + p2.getLast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>泛型和反射</h1>
<p>部分反射也是泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile warning:</span></span><br><span class="line">Class clazz = String.class;</span><br><span class="line">String str = (String) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// no warning:</span></span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line">String str = clazz.newInstance();</span><br></pre></td></tr></table></figure>
<p>调用Class的getSuperclass()方法返回的Class类型是Class&lt;? super T&gt;。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/07/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"><i class="fa fa-chevron-left">  </i><span>字符流中第一个不重复的字符</span></a></div><div class="next-post pull-right"><a href="/2020/03/06/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%EF%BD%9C%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"><span>替换空格｜《剑指offer》</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://pic.netbian.com/uploads/allimg/200710/220558-1594389958b5b5.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By TYH</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>